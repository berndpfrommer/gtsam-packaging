Description: test patch
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 gtsam (4.0.3-1) UNRELEASED; urgency=low
 .
   [ Frank Dellaert ]
   * Added a number of docker images
 .
   [ Fan Jiang ]
   * Add pybind11
 .
   [ Thomas Jespersen ]
   * Added ported C++ version of ISAM2 Kitti example
 .
   [ kvmanohar22 ]
   * adding functionality to use ISAM2 for imu preintegration example
 .
   [ yetongumich ]
   * remove distance in noisemodel, replace with error
   * add test on robust loss functions to behave like quadratic
   * Revert "add implementation for deprecated Mahalanobis"
   * merge with mahalanobis renaming
   * re-add implemntation for deprecated Mahalanobis
   * renamed mahalanobisDistance
   * add document for robust noise model
   * noise in robust should be gaussian, change variable names
   * revised comments
   * change test cases to use the updated names, remove 2nd Create in robust
   * modified document, remove commented function, add deprecated distance
   * check if noisemodel is gaussian, if not throw exception
   * change unweightedwhiten back
   * rename residual to loss
   * modified document
 .
   [ Frank dellaert ]
   * Inlined derivatives and fixed one issue with Jacobians around image center
   * Re-ordered  and cleaned up tests, added derivative tests for image center
 .
   [ Frank Dellaert ]
   * Setup and simulateMeasurements
   * Built TranslationFactor class and partially completed TranslationRecovery class
   * Added initalizeRandomly
   * Running optimization
   * Moved TranslationFactor prototype into sfm directory
   * unit test, incl Jacobians
   * Optimization works!
   * copyright 2020
   * Move to its own compilation unit
 .
   [ Binit Shah ]
   * Include corrupting noise param to parse3DFactors
 .
   [ Jose Luis Blanco-Claraco ]
   * more precise use of setZero() and add comments
 .
   [ Binit Shah ]
   * Sampler initialized with noise argument
   * Using optional sampler outside loop
 .
   [ Varun Agrawal ]
   * Added FunctorizedFactor and corresponding tests
   * fixes, better tests, docs
   * remove TODO
   * improved documentation
 .
   [ Martin Vonheim Larsen ]
   * Added test for Unit3::operator=
   * Properly handle basis in Unit3::operator=
 .
   [ Varun Agrawal ]
   * removed dependency on Eigen3 since we provide Eigen 3.3.7 and Ubuntu Bionic provides Eigen 3.3.4.
 .
   [ Martin V. Larsen ]
   * Update testUnit3.cpp
 .
   [ Varun Agrawal ]
   * improve and modernize the Dockerfiles
   * small logistical fixes
 .
   [ Gerry Chen ]
   * put file stream inside scope to force buffer flush This was already fixed for serializeXML but not for serializeToXMLFile or deserializeFromXMLFile.
   * bypass assert_equal tests for file roundtrips
   * better comments on serializationTestHelper functions
 .
   [ Jose Luis Blanco-Claraco ]
   * unhide doc section in PDF
 .
   [ Varun Agrawal ]
   * remove extra semicolon
 .
   [ Frank dellaert ]
   * Fixed override warnings and added a few missing headers
 .
   [ Varun Agrawal ]
   * renamed testScenarios to testScenarioRunner
   * set CMAKE_VERBOSE_MAKEFILE flag to OFF
 .
   [ Jose Luis Blanco-Claraco ]
   * Finish undo of #310 fill with zeros (not actually needed)
 .
   [ David ]
   * Add Pose3-Point3 factor
   * Update incorrect test name
   * Add more documentation and clang-format
 .
   [ Frank Dellaert ]
   * Importing Frobenius error factors from Shonan effort
 .
   [ Fan Jiang ]
   * Fix UAF
   * Fixed all alignment problems
   * Add missing include
   * Fix wrap tests
   * Address Frank's comments
   * Move away from boost
 .
   [ Varun Agrawal ]
   * export cython install path so it can be picked up by other cmake projects
   * cmake function to install python package once make install is completed
 .
   [ Gerry Chen ]
   * use boost paths append to have platform agnostic path separators
 .
   [ Varun Agrawal ]
   * add new make command for installing python wrapper
 .
   [ Gerry Chen ]
   * Separate stream creation and serialization Recommended by @ProfFan in #343 with the objective of making (de)serialize to string and to file more similar
   * formatting to Google style
 .
   [ Varun Agrawal ]
   * added comments and removed unnecessary code
 .
   [ Gerry Chen ]
   * fixed unit test failure on `testSerializationBase` object `output` was getting reused, but should be re-loaded into a "blank" object each time.
   * reset filesystem - forgot to uncomment these after debugging
 .
   [ akrishnan86 ]
   * optional initialization for LMParams
 .
   [ Varun Agrawal ]
   * Set minimum supported numpy version to 1.11.0 (#366)
 .
   [ Fan Jiang ]
   * Revise comments
 .
   [ Gerry Chen ]
   * remove file roundtrip test for pointers
 .
   [ Varun Agrawal ]
   * updated comments in shell script
   * added Windows batch script to install python wrapped package
 .
   [ Fan Jiang ]
   * Style fixes as commented by @dellaert
 .
   [ Gerry Chen ]
   * serialization docstrings
   * rename serialization functions with less ambiguous names According to Varun's suggestion. Note: string functions should be automatically inlined by compiler to avoid passing big strings.
 .
   [ Varun Agrawal ]
   * pure CMake script to install Python wrapper after compiling
   * removed extra line
   * reset to previous version
 .
   [ Fan Jiang ]
   * Add comments
   * Switch to the new alignment marker type
 .
   [ Varun Agrawal ]
   * Load Cython requirements file instead of reading it in cmake
   * Added cmake variable GTSAM_CYTHON_INSTALL_FULLPATH to include build tag directly
   * Vastly improved setup.py template
   * Specify working directory from where to call setup.py
   * print Eigen Unsupported status message correctly
   * wrap the biasHat function for PreintegratedMeasurement
   * added .gitignore for when building the sample cmake projects
 .
   [ Fan Jiang ]
   * Add missing lf
 .
   [ akrishnan86 ]
   * fix SfmData naming
 .
   [ Varun Agrawal ]
   * Revert "added .gitignore for when building the sample cmake projects"
 .
   [ akrishnan86 ]
   * review1 changes
 .
   [ Varun Agrawal ]
   * make python-install command depends on gtsam target
   * cleaner version of execution script which only needs 'make install'
   * run setup.py after installing the gtsam_eigency module
   * capture stdout in python test [only for python3]
   * newline added to end of CMake file
   * Set high level Cython/Eigency variables to reduce duplication
   * Create and use cython build directory
   * Use the high level cython variables, improve install process
   * Remove redundant postfix checking since the postfix is already added at the top level
   * updated cython wrapper README
   * In-place cython build
   * fixed CYTHON_INSTALL_PATH cmake variable wrt cache
   * Python Wrapper CMake update
   * removed unneeded install commands and updated README
   * Add python-install dependency for gtsam_unstable as well
   * make utils and test code python2 compliant
   * update python build location in travis script
 .
   [ Fan Jiang ]
   * Fix memory leak in Expressions
   * Fix TranslationFactor with Vector3 as Point3
   * Fix MSVC build
 .
   [ Varun Agrawal ]
   * Improved paths and added checks
 .
   [ Jose Luis Blanco-Claraco ]
   * Fix missing DLL exported symbol
 .
   [ Varun Agrawal ]
   * new definition for FunctorizedFactor to allow for using std::function and lambdas
   * Simplified FunctorizedFactor
 .
   [ Fan Jiang ]
   * Fix FrobeniusWormholeFactor Python test
 .
   [ Varun Agrawal ]
   * fix working directory for python install target
   * test SmartFactor when body_P_sensor is passed in
 .
   [ Thomas Jespersen ]
   * ISAM2 Kitti example: Addressed review comments
 .
   [ Mike Sheffler ]
   * Second attempt at a wrapper fix.
 .
   [ Varun Agrawal ]
   * Abstracted out serialization code for PreintegrationBase
 .
   [ Mike Sheffler ]
   * Unnecessary include statement
 .
   [ Varun Agrawal ]
   * Updated  PreintegratedImuMeasurements docstring
 .
   [ Fan Jiang ]
   * Fix lambda check in logging optimizer
 .
   [ Varun Agrawal ]
   * Replace scoped name with direct name and instantiate base class in constructor
   * Major updates to CombinedImuFactor to make it Testable as well as serializable
   * Fix typo
   * Added and updated serialization tests to include all IMU factors
   * revert variable change
   * reduced tolerance for checking jacobian
 .
   [ Fan Jiang ]
   * add return value in gtsam_optimize
 .
   [ Frank dellaert ]
   * Eliminated some copy/paste
   * Added g2o test files
   * Added tests on determinants of read rotations
   * Normalized quaternions before converting to Rot3 to account for limited precision in text files.
   * Avoided extra conversions to quaternions
 .
   [ Varun Agrawal ]
   * Add indentation
   * Handle extrinsics and intrinsics for jacobian
 .
   [ Frank dellaert ]
   * Formatted and fixed discrete examples
 .
   [ Varun Agrawal ]
   * Use built in Matrix serialization
   * Generic Eigen::Matrix serialization for boost
   * add compiler flags to suppress warnings if built in release mode
   * Add MATLAB root and Mex paths to cmake output, align GTSAM specific output
   * Quote variable so it works on Windows
   * Use static matrix and constexpr
   * use boost serialization macro instead of make_array
 .
   [ Fan Jiang ]
   * Added wrapping for the PCG solver in Cython
   * add comments
 .
   [ Varun Agrawal ]
   * suppress warnings only for 3rd party code for Release builds
   * fix init issues with Vector3, use static matrices where possible
   * added note about code source and eigen resize for both static and dynamic matrices
   * Explicit type definition to handle warning
 .
   [ Fan Jiang ]
   * Add check to ensure we are calling lambda on a LM
 .
   [ Varun Agrawal ]
   * correct compiler flag for Windows
 .
   [ Fan Jiang ]
   * Add unit test
   * use isinstance
 .
   [ Varun Agrawal ]
   * added cmake policy for AppleClang compiler identification
 .
   [ Fan Jiang ]
   * Move the declaration to cpp
 .
   [ Varun Agrawal ]
   * Better way of exporting Boost serialization guid
 .
   [ Frank dellaert ]
   * Resurrecting DiscreteBayesTree tests
 .
   [ yetongumich ]
   * modified test
 .
   [ Frank dellaert ]
   * Checked in pdf for easy reference
   * added printSignature and evaluate
   * Fixed link issue
   * Cleaned up formatting
   * Fixed tests
 .
   [ Varun Agrawal ]
   * perform equality comparison on root of class hierarchy
   * correct vector init
   * delete extra pdf file
   * Revert "delete extra pdf file"
 .
   [ yetongumich ]
   * deprecate error in noisemodel, use loss instead; revise virtual with override
   * deprecate error in noisemodel, use loss instead; revise virtual with override
 .
   [ Frank dellaert ]
   * Extra tests on frontal keys
   * Some more refactoring of marginals
   * Fix confusion between parents and frontals
   * Added code to re-jigger Signature cpt so that frontal keys are always first, consistent with how the DiscreteElimination function works.
   * New discrete example
   * Better print
   * Cleaned up tests
   * Use dict notation in print
   * Add explicit HMM example
   * Modernized sample function
 .
   [ yetongumich ]
   * modify testNoiseModel to use loss instead of error
   * change doc
 .
   [ Varun Agrawal ]
   * fix serialization warning for boost::optional<Vector3>
 .
   [ Frank dellaert ]
   * Partial Specialization
   * Add BayesNet-inst.h at end of BayesNet.h
 .
   [ Varun Agrawal ]
   * correct indentation for Python version
 .
   [ Mike Sheffler ]
   * Missing BOOST_SERIALIZATION_NVP wrapper macro for an argument to be serialized
 .
   [ Jose Luis Blanco Claraco ]
   * docker tag and pip3 fixes; add a readme
   * complete README
 .
   [ acxz ]
   * set default initialization
 .
   [ Frank dellaert ]
   * Fixed conventions for Jacobians
   * Unit test for transformPoseFrom
   * Some more name changes and documentation
 .
   [ Varun Agrawal ]
   * Added more comments for clearer understanding
 .
   [ Fan Jiang ]
   * Bump version and switch Pose3 expmap default
   * Fix test for full Pose3 expmap
   * Remove pybind11
Author: Bernd Pfrommer <bernd.pfrommer@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2020-08-09

--- gtsam-4.0.3.orig/.travis.python.sh
+++ gtsam-4.0.3/.travis.python.sh
@@ -29,7 +29,7 @@ cmake $CURRDIR -DCMAKE_BUILD_TYPE=Releas
     -DGTSAM_BUILD_WITH_MARCH_NATIVE=OFF \
     -DGTSAM_INSTALL_CYTHON_TOOLBOX=ON \
     -DGTSAM_PYTHON_VERSION=$PYTHON_VERSION \
-    -DGTSAM_ALLOW_DEPRECATED_SINCE_V4=OFF \
+    -DGTSAM_ALLOW_DEPRECATED_SINCE_V41=OFF \
     -DCMAKE_INSTALL_PREFIX=$CURRDIR/../gtsam_install
 
 make -j$(nproc) install
--- gtsam-4.0.3.orig/.travis.sh
+++ gtsam-4.0.3/.travis.sh
@@ -61,7 +61,7 @@ function configure()
       -DGTSAM_WITH_TBB=${GTSAM_WITH_TBB:-OFF} \
       -DGTSAM_USE_QUATERNIONS=${GTSAM_USE_QUATERNIONS:-OFF} \
       -DGTSAM_BUILD_EXAMPLES_ALWAYS=${GTSAM_BUILD_EXAMPLES_ALWAYS:-ON} \
-      -DGTSAM_ALLOW_DEPRECATED_SINCE_V4=${GTSAM_ALLOW_DEPRECATED_SINCE_V4:-OFF} \
+      -DGTSAM_ALLOW_DEPRECATED_SINCE_V4=${GTSAM_ALLOW_DEPRECATED_SINCE_V41:-OFF} \
       -DGTSAM_BUILD_WITH_MARCH_NATIVE=OFF \
       -DCMAKE_VERBOSE_MAKEFILE=OFF
 }
--- gtsam-4.0.3.orig/.travis.yml
+++ gtsam-4.0.3/.travis.yml
@@ -1,6 +1,5 @@
 language: cpp
 cache: ccache
-sudo: required
 dist: xenial
 
 addons:
@@ -33,7 +32,7 @@ stages:
 
 env:
   global:
-    - MAKEFLAGS="-j2"
+    - MAKEFLAGS="-j3"
     - CCACHE_SLOPPINESS=pch_defines,time_macros
 
 # Compile stage without building examples/tests to populate the caches.
@@ -88,7 +87,7 @@ jobs:
   - stage: special
     os: linux
     compiler: clang
-    env: CC=clang-9 CXX=clang++-9 CMAKE_BUILD_TYPE=Debug GTSAM_BUILD_UNSTABLE=OFF GTSAM_ALLOW_DEPRECATED_SINCE_V4=ON
+    env: CC=clang-9 CXX=clang++-9 CMAKE_BUILD_TYPE=Debug GTSAM_BUILD_UNSTABLE=OFF GTSAM_ALLOW_DEPRECATED_SINCE_V41=ON
     script: bash .travis.sh -b
 # on Linux, with GTSAM_WITH_TBB on to make sure GTSAM still compiles/tests
   - stage: special
--- gtsam-4.0.3.orig/CMakeLists.txt
+++ gtsam-4.0.3/CMakeLists.txt
@@ -75,7 +75,7 @@ option(GTSAM_WITH_TBB
 option(GTSAM_WITH_EIGEN_MKL              "Eigen will use Intel MKL if available" OFF)
 option(GTSAM_WITH_EIGEN_MKL_OPENMP       "Eigen, when using Intel MKL, will also use OpenMP for multithreading if available" OFF)
 option(GTSAM_THROW_CHEIRALITY_EXCEPTION  "Throw exception when a triangulated point is behind a camera" ON)
-option(GTSAM_ALLOW_DEPRECATED_SINCE_V4   "Allow use of methods/functions deprecated in GTSAM 4" ON)
+option(GTSAM_ALLOW_DEPRECATED_SINCE_V41  "Allow use of methods/functions deprecated in GTSAM 4.1" ON)
 option(GTSAM_TYPEDEF_POINTS_TO_VECTORS   "Typedef Point2 and Point3 to Eigen::Vector equivalents" OFF)
 option(GTSAM_SUPPORT_NESTED_DISSECTION   "Support Metis-based nested dissection" ON)
 option(GTSAM_TANGENT_PREINTEGRATION      "Use new ImuFactor with integration on tangent space" ON)
@@ -590,7 +590,7 @@ print_config_flag(${GTSAM_USE_QUATERNION
 print_config_flag(${GTSAM_ENABLE_CONSISTENCY_CHECKS}   "Runtime consistency checking    ")
 print_config_flag(${GTSAM_ROT3_EXPMAP}                 "Rot3 retract is full ExpMap     ")
 print_config_flag(${GTSAM_POSE3_EXPMAP}                "Pose3 retract is full ExpMap    ")
-print_config_flag(${GTSAM_ALLOW_DEPRECATED_SINCE_V4}   "Deprecated in GTSAM 4 allowed   ")
+print_config_flag(${GTSAM_ALLOW_DEPRECATED_SINCE_V41}  "Allow features deprecated in GTSAM 4.1")
 print_config_flag(${GTSAM_TYPEDEF_POINTS_TO_VECTORS}   "Point3 is typedef to Vector3    ")
 print_config_flag(${GTSAM_SUPPORT_NESTED_DISSECTION}   "Metis-based Nested Dissection   ")
 print_config_flag(${GTSAM_TANGENT_PREINTEGRATION}      "Use tangent-space preintegration")
--- gtsam-4.0.3.orig/CppUnitLite/Test.h
+++ gtsam-4.0.3/CppUnitLite/Test.h
@@ -64,7 +64,7 @@ protected:
   class testGroup##testName##Test : public Test \
   { public: testGroup##testName##Test () : Test (#testName "Test", __FILE__, __LINE__, true) {} \
             virtual ~testGroup##testName##Test () {};\
-            void run (TestResult& result_);} \
+            void run (TestResult& result_) override;} \
     testGroup##testName##Instance; \
   void testGroup##testName##Test::run (TestResult& result_)
 
@@ -82,7 +82,7 @@ protected:
   class testGroup##testName##Test : public Test \
   { public: testGroup##testName##Test () : Test (#testName "Test", __FILE__, __LINE__, false) {} \
             virtual ~testGroup##testName##Test () {};\
-            void run (TestResult& result_);} \
+            void run (TestResult& result_) override;} \
     testGroup##testName##Instance; \
   void testGroup##testName##Test::run (TestResult& result_)
 
--- gtsam-4.0.3.orig/README.md
+++ gtsam-4.0.3/README.md
@@ -1,5 +1,7 @@
 # README - Georgia Tech Smoothing and Mapping Library
 
+**As of August 1, develop is officially in "Pre 4.1" mode, and features deprecated in 4.0 were removed. Use the last 4.0.3 release if you need those features. However, most are easily converted and can be tracked down (in 4.0.3) by disabling the cmake flag GTSAM_ALLOW_DEPRECATED_SINCE_V4**
+
 ## What is GTSAM?
 
 GTSAM is a C++ library that implements smoothing and
@@ -44,9 +46,12 @@ Optional prerequisites - used automatica
 
 ## GTSAM 4 Compatibility
 
-GTSAM 4 introduces several new features, most notably Expressions and a Python toolbox. We also deprecate some legacy functionality and wrongly named methods, but by default the flag GTSAM_ALLOW_DEPRECATED_SINCE_V4 is enabled, allowing anyone to just pull V4 and compile. To build the python toolbox, however, you will have to explicitly disable that flag.
+GTSAM 4 introduces several new features, most notably Expressions and a Python toolbox. It also introduces traits, a C++ technique that allows optimizing with non-GTSAM types. That opens the door to retiring geometric types such as Point2 and Point3 to pure Eigen types, which we also do. A significant change which will not trigger a compile error is that zero-initializing of Point2 and Point3 is deprecated, so please be aware that this might render functions using their default constructor incorrect.
+
+GTSAM 4 also deprecated some legacy functionality and wrongly named methods. If you are on a 4.0.X release, you can define the flag GTSAM_ALLOW_DEPRECATED_SINCE_V4 to use the deprecated methods.
+
+GTSAM 4.1 added a new pybind wrapper, and **removed** the deprecated functionality. There is a flag GTSAM_ALLOW_DEPRECATED_SINCE_V41 for newly deprecated methods since the 4.1 release, which is on by default, allowing anyone to just pull version 4.1 and compile.
 
-Also, GTSAM 4 introduces traits, a C++ technique that allows optimizing with non-GTSAM types. That opens the door to retiring geometric types such as Point2 and Point3 to pure Eigen types, which we also do. A significant change which will not trigger a compile error is that zero-initializing of Point2 and Point3 is deprecated, so please be aware that this might render functions using their default constructor incorrect.
 
 ## Wrappers
 
--- gtsam-4.0.3.orig/cmake/GtsamBuildTypes.cmake
+++ gtsam-4.0.3/cmake/GtsamBuildTypes.cmake
@@ -104,8 +104,24 @@ if(MSVC)
   set(GTSAM_COMPILE_OPTIONS_PRIVATE_TIMING          /MD /O2  CACHE STRING "(User editable) Private compiler flags for Timing configuration.")
 else()
   # Common to all configurations, next for each configuration:
-  # "-fPIC" is to ensure proper code generation for shared libraries
-  set(GTSAM_COMPILE_OPTIONS_PRIVATE_COMMON          -Wall -fPIC CACHE STRING "(User editable) Private compiler flags for all configurations.")
+
+  if (
+      ((CMAKE_CXX_COMPILER_ID MATCHES "Clang") AND (NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 12.0.0)) OR
+      (CMAKE_CXX_COMPILER_ID MATCHES "GNU")
+     )
+    set(flag_override_ -Wsuggest-override) # -Werror=suggest-override: Add again someday
+  endif()
+
+  set(GTSAM_COMPILE_OPTIONS_PRIVATE_COMMON
+    -Wall                                          # Enable common warnings
+    -fPIC                                          # ensure proper code generation for shared libraries
+    $<$<CXX_COMPILER_ID:GNU>:-Wreturn-local-addr -Werror=return-local-addr>            # Error: return local address
+    $<$<CXX_COMPILER_ID:Clang>:-Wreturn-stack-address   -Werror=return-stack-address>  # Error: return local address
+    -Wreturn-type  -Werror=return-type             # Error on missing return()
+    -Wformat -Werror=format-security               # Error on wrong printf() arguments
+    $<$<COMPILE_LANGUAGE:CXX>:${flag_override_}>   # Enforce the use of the override keyword
+    #
+    CACHE STRING "(User editable) Private compiler flags for all configurations.")
   set(GTSAM_COMPILE_OPTIONS_PRIVATE_DEBUG           -g -fno-inline  CACHE STRING "(User editable) Private compiler flags for Debug configuration.")
   set(GTSAM_COMPILE_OPTIONS_PRIVATE_RELWITHDEBINFO  -g -O3  CACHE STRING "(User editable) Private compiler flags for RelWithDebInfo configuration.")
   set(GTSAM_COMPILE_OPTIONS_PRIVATE_RELEASE         -O3  CACHE STRING "(User editable) Private compiler flags for Release configuration.")
--- gtsam-4.0.3.orig/cython/gtsam/utils/plot.py
+++ gtsam-4.0.3/cython/gtsam/utils/plot.py
@@ -135,7 +135,8 @@ def plot_pose2_on_axes(axes, pose, axis_
         axes.add_patch(e1)
 
 
-def plot_pose2(fignum, pose, axis_length=0.1, covariance=None):
+def plot_pose2(fignum, pose, axis_length=0.1, covariance=None,
+               axis_labels=('X axis', 'Y axis', 'Z axis')):
     """
     Plot a 2D pose on given figure with given `axis_length`.
 
@@ -144,6 +145,7 @@ def plot_pose2(fignum, pose, axis_length
         pose (gtsam.Pose2): The pose to be plotted.
         axis_length (float): The length of the camera axes.
         covariance (numpy.ndarray): Marginal covariance matrix to plot the uncertainty of the estimation.
+        axis_labels (iterable[string]): List of axis labels to set.
     """
     # get figure object
     fig = plt.figure(fignum)
@@ -151,6 +153,12 @@ def plot_pose2(fignum, pose, axis_length
     plot_pose2_on_axes(axes, pose, axis_length=axis_length,
                        covariance=covariance)
 
+    axes.set_xlabel(axis_labels[0])
+    axes.set_ylabel(axis_labels[1])
+    axes.set_zlabel(axis_labels[2])
+
+    return fig
+
 
 def plot_point3_on_axes(axes, point, linespec, P=None):
     """
@@ -167,7 +175,8 @@ def plot_point3_on_axes(axes, point, lin
         plot_covariance_ellipse_3d(axes, point.vector(), P)
 
 
-def plot_point3(fignum, point, linespec, P=None):
+def plot_point3(fignum, point, linespec, P=None,
+                axis_labels=('X axis', 'Y axis', 'Z axis')):
     """
     Plot a 3D point on given figure with given `linespec`.
 
@@ -176,13 +185,25 @@ def plot_point3(fignum, point, linespec,
         point (gtsam.Point3): The point to be plotted.
         linespec (string): String representing formatting options for Matplotlib.
         P (numpy.ndarray): Marginal covariance matrix to plot the uncertainty of the estimation.
+        axis_labels (iterable[string]): List of axis labels to set.
+
+    Returns:
+        fig: The matplotlib figure.
+
     """
     fig = plt.figure(fignum)
     axes = fig.gca(projection='3d')
     plot_point3_on_axes(axes, point, linespec, P)
 
+    axes.set_xlabel(axis_labels[0])
+    axes.set_ylabel(axis_labels[1])
+    axes.set_zlabel(axis_labels[2])
+
+    return fig
+
 
-def plot_3d_points(fignum, values, linespec="g*", marginals=None):
+def plot_3d_points(fignum, values, linespec="g*", marginals=None,
+                   title="3D Points", axis_labels=('X axis', 'Y axis', 'Z axis')):
     """
     Plots the Point3s in `values`, with optional covariances.
     Finds all the Point3 objects in the given Values object and plots them.
@@ -193,7 +214,9 @@ def plot_3d_points(fignum, values, lines
         fignum (int): Integer representing the figure number to use for plotting.
         values (gtsam.Values): Values dictionary consisting of points to be plotted.
         linespec (string): String representing formatting options for Matplotlib.
-        covariance (numpy.ndarray): Marginal covariance matrix to plot the uncertainty of the estimation.
+        marginals (numpy.ndarray): Marginal covariance matrix to plot the uncertainty of the estimation.
+        title (string): The title of the plot.
+        axis_labels (iterable[string]): List of axis labels to set.
     """
 
     keys = values.keys()
@@ -208,12 +231,16 @@ def plot_3d_points(fignum, values, lines
             else:
                 covariance = None
 
-            plot_point3(fignum, point, linespec, covariance)
+            fig = plot_point3(fignum, point, linespec, covariance,
+                              axis_labels=axis_labels)
 
         except RuntimeError:
             continue
             # I guess it's not a Point3
 
+    fig.suptitle(title)
+    fig.canvas.set_window_title(title.lower())
+
 
 def plot_pose3_on_axes(axes, pose, axis_length=0.1, P=None, scale=1):
     """
@@ -251,7 +278,8 @@ def plot_pose3_on_axes(axes, pose, axis_
         plot_covariance_ellipse_3d(axes, origin, gPp)
 
 
-def plot_pose3(fignum, pose, axis_length=0.1, P=None):
+def plot_pose3(fignum, pose, axis_length=0.1, P=None,
+               axis_labels=('X axis', 'Y axis', 'Z axis')):
     """
     Plot a 3D pose on given figure with given `axis_length`.
 
@@ -260,6 +288,10 @@ def plot_pose3(fignum, pose, axis_length
         pose (gtsam.Pose3): 3D pose to be plotted.
         linespec (string): String representing formatting options for Matplotlib.
         P (numpy.ndarray): Marginal covariance matrix to plot the uncertainty of the estimation.
+        axis_labels (iterable[string]): List of axis labels to set.
+
+    Returns:
+        fig: The matplotlib figure.
     """
     # get figure object
     fig = plt.figure(fignum)
@@ -267,8 +299,15 @@ def plot_pose3(fignum, pose, axis_length
     plot_pose3_on_axes(axes, pose, P=P,
                        axis_length=axis_length)
 
+    axes.set_xlabel(axis_labels[0])
+    axes.set_ylabel(axis_labels[1])
+    axes.set_zlabel(axis_labels[2])
 
-def plot_trajectory(fignum, values, scale=1, marginals=None):
+    return fig
+
+
+def plot_trajectory(fignum, values, scale=1, marginals=None,
+                    title="Plot Trajectory", axis_labels=('X axis', 'Y axis', 'Z axis')):
     """
     Plot a complete 3D trajectory using poses in `values`.
 
@@ -278,6 +317,8 @@ def plot_trajectory(fignum, values, scal
         scale (float): Value to scale the poses by.
         marginals (gtsam.Marginals): Marginalized probability values of the estimation.
             Used to plot uncertainty bounds.
+        title (string): The title of the plot.
+        axis_labels (iterable[string]): List of axis labels to set.
     """
     pose3Values = gtsam.utilities_allPose3s(values)
     keys = gtsam.KeyVector(pose3Values.keys())
@@ -303,8 +344,8 @@ def plot_trajectory(fignum, values, scal
             else:
                 covariance = None
 
-            plot_pose3(fignum, lastPose,  P=covariance,
-                       axis_length=scale)
+            fig = plot_pose3(fignum, lastPose,  P=covariance,
+                             axis_length=scale, axis_labels=axis_labels)
 
         lastIndex = i
 
@@ -318,8 +359,11 @@ def plot_trajectory(fignum, values, scal
             else:
                 covariance = None
 
-            plot_pose3(fignum, lastPose, P=covariance,
-                       axis_length=scale)
+            fig = plot_pose3(fignum, lastPose, P=covariance,
+                             axis_length=scale, axis_labels=axis_labels)
 
         except:
             pass
+
+    fig.suptitle(title)
+    fig.canvas.set_window_title(title.lower())
--- gtsam-4.0.3.orig/examples/CameraResectioning.cpp
+++ gtsam-4.0.3/examples/CameraResectioning.cpp
@@ -46,8 +46,8 @@ public:
   }
 
   /// evaluate the error
-  virtual Vector evaluateError(const Pose3& pose, boost::optional<Matrix&> H =
-      boost::none) const {
+  Vector evaluateError(const Pose3& pose, boost::optional<Matrix&> H =
+      boost::none) const override {
     PinholeCamera<Cal3_S2> camera(pose, *K_);
     return camera.project(P_, H, boost::none, boost::none) - p_;
   }
--- /dev/null
+++ gtsam-4.0.3/examples/Data/example_with_vertices.g2o
@@ -0,0 +1,16 @@
+VERTEX_SE3:QUAT 8646911284551352320 40 -1.15443e-13 10 0.557345 0.557345 -0.435162 -0.435162
+VERTEX_SE3:QUAT 8646911284551352321 28.2843 28.2843 10 0.301633 0.728207 -0.568567 -0.235508
+VERTEX_SE3:QUAT 8646911284551352322 -1.6986e-08 40 10 -3.89609e-10 0.788205 -0.615412 -2.07622e-10
+VERTEX_SE3:QUAT 8646911284551352323 -28.2843 28.2843 10 -0.301633 0.728207 -0.568567 0.235508
+VERTEX_SE3:QUAT 8646911284551352324 -40 -2.32554e-10 10 -0.557345 0.557345 -0.435162 0.435162
+VERTEX_SE3:QUAT 8646911284551352325 -28.2843 -28.2843 10 -0.728207 0.301633 -0.235508 0.568567
+VERTEX_SE3:QUAT 8646911284551352326 -2.53531e-09 -40 10 -0.788205 -1.25891e-11 -3.82742e-13 0.615412
+VERTEX_SE3:QUAT 8646911284551352327 28.2843 -28.2843 10 -0.728207 -0.301633 0.235508 0.568567
+VERTEX_TRACKXYZ 7782220156096217088 10 10 10
+VERTEX_TRACKXYZ 7782220156096217089 -10 10 10
+VERTEX_TRACKXYZ 7782220156096217090 -10 -10 10
+VERTEX_TRACKXYZ 7782220156096217091 10 -10 10
+VERTEX_TRACKXYZ 7782220156096217092 10 10 -10
+VERTEX_TRACKXYZ 7782220156096217093 -10 10 -10
+VERTEX_TRACKXYZ 7782220156096217094 -10 -10 -10
+VERTEX_TRACKXYZ 7782220156096217095 10 -10 -10
--- gtsam-4.0.3.orig/examples/LocalizationExample.cpp
+++ gtsam-4.0.3/examples/LocalizationExample.cpp
@@ -85,7 +85,7 @@ class UnaryFactor: public NoiseModelFact
   // function, returning a vector of errors when evaluated at the provided variable value. It
   // must also calculate the Jacobians for this measurement function, if requested.
   Vector evaluateError(const Pose2& q,
-                       boost::optional<Matrix&> H = boost::none) const {
+                       boost::optional<Matrix&> H = boost::none) const override {
     // The measurement function for a GPS-like measurement is simple:
     // error_x = pose.x - measurement.x
     // error_y = pose.y - measurement.y
@@ -99,7 +99,7 @@ class UnaryFactor: public NoiseModelFact
   // The second is a 'clone' function that allows the factor to be copied. Under most
   // circumstances, the following code that employs the default copy constructor should
   // work fine.
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new UnaryFactor(*this))); }
 
--- gtsam-4.0.3.orig/examples/SolverComparer.cpp
+++ gtsam-4.0.3/examples/SolverComparer.cpp
@@ -50,11 +50,11 @@
 #include <boost/program_options.hpp>
 #include <boost/range/algorithm/set_algorithm.hpp>
 #include <boost/range/adaptor/reversed.hpp>
-#include <boost/random.hpp>
 #include <boost/serialization/export.hpp>
 
 #include <fstream>
 #include <iostream>
+#include <random>
 
 #ifdef GTSAM_USE_TBB
 #include <tbb/task_arena.h> // tbb::task_arena
@@ -554,8 +554,8 @@ void runCompare()
 void runPerturb()
 {
   // Set up random number generator
-  boost::mt19937 rng;
-  boost::normal_distribution<double> normal(0.0, perturbationNoise);
+  std::mt19937 rng;
+  std::normal_distribution<double> normal(0.0, perturbationNoise);
 
   // Perturb values
   VectorValues noise;
--- gtsam-4.0.3.orig/gtsam.h
+++ gtsam-4.0.3/gtsam.h
@@ -2369,6 +2369,7 @@ virtual class NonlinearOptimizer {
   double error() const;
   int iterations() const;
   gtsam::Values values() const;
+  gtsam::NonlinearFactorGraph graph() const;
   gtsam::GaussianFactorGraph* iterate() const;
 };
 
@@ -2996,6 +2997,7 @@ class PreintegratedImuMeasurements {
   void resetIntegrationAndSetBias(const gtsam::imuBias::ConstantBias& biasHat);
 
   Matrix preintMeasCov() const;
+  Vector preintegrated() const;
   double deltaTij() const;
   gtsam::Rot3 deltaRij() const;
   Vector deltaPij() const;
--- gtsam-4.0.3.orig/gtsam/CMakeLists.txt
+++ gtsam-4.0.3/gtsam/CMakeLists.txt
@@ -14,7 +14,6 @@ set (gtsam_subdirs
     sam
     sfm
     slam
-    smart
 	  navigation
 )
 
--- gtsam-4.0.3.orig/gtsam/base/DSFVector.h
+++ gtsam-4.0.3/gtsam/base/DSFVector.h
@@ -55,11 +55,6 @@ public:
 
   /// Merge the sets containing i1 and i2. Does nothing if i1 and i2 are already in the same set.
   void merge(const size_t& i1, const size_t& i2);
-
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  inline size_t findSet(size_t key) const {return find(key);}
-  inline void makeUnionInPlace(const size_t& i1, const size_t& i2) {return merge(i1,i2);}
-#endif
 };
 
 /**
--- gtsam-4.0.3.orig/gtsam/base/GenericValue.h
+++ gtsam-4.0.3/gtsam/base/GenericValue.h
@@ -70,7 +70,7 @@ public:
   }
 
   /// equals implementing generic Value interface
-  virtual bool equals_(const Value& p, double tol = 1e-9) const {
+  bool equals_(const Value& p, double tol = 1e-9) const override {
     // Cast the base class Value pointer to a templated generic class pointer
     const GenericValue& genericValue2 = static_cast<const GenericValue&>(p);
     // Return the result of using the equals traits for the derived class
@@ -83,15 +83,15 @@ public:
   }
 
   /// Virtual print function, uses traits
-  virtual void print(const std::string& str) const {
-    std::cout << "(" << demangle(typeid(T).name()) << ") ";
+  void print(const std::string& str) const override {
+    std::cout << "(" << demangle(typeid(T).name()) << ")\n";
     traits<T>::Print(value_, str);
   }
 
     /**
      * Create a duplicate object returned as a pointer to the generic Value interface.
      */
-    virtual Value* clone_() const {
+    Value* clone_() const override {
       GenericValue* ptr = new GenericValue(*this); // calls copy constructor to fill in
       return ptr;
     }
@@ -99,19 +99,19 @@ public:
     /**
      * Destroy and deallocate this object, only if it was originally allocated using clone_().
      */
-    virtual void deallocate_() const {
+    void deallocate_() const override {
       delete this;
     }
 
     /**
      * Clone this value (normal clone on the heap, delete with 'delete' operator)
      */
-    virtual boost::shared_ptr<Value> clone() const {
+    boost::shared_ptr<Value> clone() const override {
 		return boost::allocate_shared<GenericValue>(Eigen::aligned_allocator<GenericValue>(), *this);
     }
 
     /// Generic Value interface version of retract
-    virtual Value* retract_(const Vector& delta) const {
+    Value* retract_(const Vector& delta) const override {
       // Call retract on the derived class using the retract trait function
       const T retractResult = traits<T>::Retract(GenericValue<T>::value(), delta);
 
@@ -122,7 +122,7 @@ public:
     }
 
     /// Generic Value interface version of localCoordinates
-    virtual Vector localCoordinates_(const Value& value2) const {
+    Vector localCoordinates_(const Value& value2) const override {
       // Cast the base class Value pointer to a templated generic class pointer
       const GenericValue<T>& genericValue2 =
           static_cast<const GenericValue<T>&>(value2);
@@ -142,12 +142,12 @@ public:
     }
 
     /// Return run-time dimensionality
-    virtual size_t dim() const {
+    size_t dim() const override {
       return traits<T>::GetDimension(value_);
     }
 
     /// Assignment operator
-    virtual Value& operator=(const Value& rhs) {
+    Value& operator=(const Value& rhs) override {
       // Cast the base class Value pointer to a derived class pointer
       const GenericValue& derivedRhs = static_cast<const GenericValue&>(rhs);
 
@@ -198,4 +198,12 @@ const ValueType& Value::cast() const {
   return dynamic_cast<const GenericValue<ValueType>&>(*this).value();
 }
 
+/** Functional constructor of GenericValue<T> so T can be automatically deduced
+  */
+template<class T>
+GenericValue<T> genericValue(const T& v) {
+  return GenericValue<T>(v);
+}
+
+
 } /* namespace gtsam */
--- gtsam-4.0.3.orig/gtsam/base/Manifold.h
+++ gtsam-4.0.3/gtsam/base/Manifold.h
@@ -167,62 +167,6 @@ struct FixedDimension {
   BOOST_STATIC_ASSERT_MSG(value != Eigen::Dynamic,
       "FixedDimension instantiated for dymanically-sized type.");
 };
-
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-/// Helper class to construct the product manifold of two other manifolds, M1 and M2
-/// Deprecated because of limited usefulness, maximum obfuscation
-template<typename M1, typename M2>
-class ProductManifold: public std::pair<M1, M2> {
-  BOOST_CONCEPT_ASSERT((IsManifold<M1>));
-  BOOST_CONCEPT_ASSERT((IsManifold<M2>));
-
-protected:
-  enum { dimension1 = traits<M1>::dimension };
-  enum { dimension2 = traits<M2>::dimension };
-
-public:
-  enum { dimension = dimension1 + dimension2 };
-  inline static size_t Dim() { return dimension;}
-  inline size_t dim() const { return dimension;}
-
-  typedef Eigen::Matrix<double, dimension, 1> TangentVector;
-  typedef OptionalJacobian<dimension, dimension> ChartJacobian;
-
-  /// Default constructor needs default constructors to be defined
-  ProductManifold():std::pair<M1,M2>(M1(),M2()) {}
-
-  // Construct from two original manifold values
-  ProductManifold(const M1& m1, const M2& m2):std::pair<M1,M2>(m1,m2) {}
-
-  /// Retract delta to manifold
-  ProductManifold retract(const TangentVector& xi) const {
-    M1 m1 = traits<M1>::Retract(this->first,  xi.template head<dimension1>());
-    M2 m2 = traits<M2>::Retract(this->second, xi.template tail<dimension2>());
-    return ProductManifold(m1,m2);
-  }
-
-  /// Compute the coordinates in the tangent space
-  TangentVector localCoordinates(const ProductManifold& other) const {
-    typename traits<M1>::TangentVector v1 = traits<M1>::Local(this->first,  other.first);
-    typename traits<M2>::TangentVector v2 = traits<M2>::Local(this->second, other.second);
-    TangentVector v;
-    v << v1, v2;
-    return v;
-  }
-
-  // Alignment, see https://eigen.tuxfamily.org/dox/group__TopicStructHavingEigenMembers.html
-  enum { NeedsToAlign = (sizeof(M1) % 16) == 0 || (sizeof(M2) % 16) == 0
-  };
-public:
-	GTSAM_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
-};
-
-// Define any direct product group to be a model of the multiplicative Group concept
-template<typename M1, typename M2>
-struct traits<ProductManifold<M1, M2> > : internal::Manifold<ProductManifold<M1, M2> > {
-};
-#endif
-
 } // \ namespace gtsam
 
 ///**
--- gtsam-4.0.3.orig/gtsam/base/Matrix.cpp
+++ gtsam-4.0.3/gtsam/base/Matrix.cpp
@@ -136,20 +136,24 @@ Vector operator^(const Matrix& A, const
   return A.transpose() * v;
 }
 
+const Eigen::IOFormat& matlabFormat() {
+  static const Eigen::IOFormat matlab(
+    Eigen::StreamPrecision, // precision
+    Eigen::DontAlignCols, // flags set such that rowSpacers are not added
+    ", ", // coeffSeparator
+    ";\n", // rowSeparator
+    "\t",  // rowPrefix
+    "", // rowSuffix
+    "[\n", // matPrefix
+    "\n]" // matSuffix
+  );
+  return matlab;
+}
+
 /* ************************************************************************* */
 //3 argument call
 void print(const Matrix& A, const string &s, ostream& stream) {
-  static const Eigen::IOFormat matlab(
-      Eigen::StreamPrecision, // precision
-      0, // flags
-      ", ", // coeffSeparator
-      ";\n", // rowSeparator
-      "\t",  // rowPrefix
-      "", // rowSuffix
-      "[\n", // matPrefix
-      "\n]" // matSuffix
-      );
-  cout << s << A.format(matlab) << endl;
+  cout << s << A.format(matlabFormat()) << endl;
 }
 
 /* ************************************************************************* */
--- gtsam-4.0.3.orig/gtsam/base/Matrix.h
+++ gtsam-4.0.3/gtsam/base/Matrix.h
@@ -23,14 +23,11 @@
 // \callgraph
 
 #pragma once
+
 #include <gtsam/base/OptionalJacobian.h>
 #include <gtsam/base/Vector.h>
 #include <gtsam/config.h>
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-#include <Eigen/Core>
-#include <Eigen/Cholesky>
-#include <Eigen/LU>
-#endif
+
 #include <boost/format.hpp>
 #include <boost/function.hpp>
 #include <boost/tuple/tuple.hpp>
@@ -76,6 +73,10 @@ GTSAM_MAKE_MATRIX_DEFS(9);
 typedef Eigen::Block<Matrix> SubMatrix;
 typedef Eigen::Block<const Matrix> ConstSubMatrix;
 
+// Matrix formatting arguments when printing.
+// Akin to Matlab style.
+const Eigen::IOFormat& matlabFormat();
+
 /**
  * equals with a tolerance
  */
@@ -517,23 +518,6 @@ struct MultiplyWithInverseFunction {
   const Operator phi_;
 };
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-inline Matrix zeros( size_t m, size_t n ) { return Matrix::Zero(m,n); }
-inline Matrix ones( size_t m, size_t n ) { return Matrix::Ones(m,n); }
-inline Matrix eye( size_t m, size_t n) { return Matrix::Identity(m, n); }
-inline Matrix eye( size_t m ) { return eye(m,m); }
-inline Matrix diag(const Vector& v) { return v.asDiagonal(); }
-inline void multiplyAdd(double alpha, const Matrix& A, const Vector& x, Vector& e) { e += alpha * A * x; }
-inline void multiplyAdd(const Matrix& A, const Vector& x, Vector& e) { e += A * x; }
-inline void transposeMultiplyAdd(double alpha, const Matrix& A, const Vector& e, Vector& x) { x += alpha * A.transpose() * e; }
-inline void transposeMultiplyAdd(const Matrix& A, const Vector& e, Vector& x) { x += A.transpose() * e; }
-inline void transposeMultiplyAdd(double alpha, const Matrix& A, const Vector& e, SubVector x) { x += alpha * A.transpose() * e; }
-inline void insertColumn(Matrix& A, const Vector& col, size_t j) { A.col(j) = col; }
-inline void insertColumn(Matrix& A, const Vector& col, size_t i, size_t j) { A.col(j).segment(i, col.size()) = col; }
-inline void solve(Matrix& A, Matrix& B) { B = A.fullPivLu().solve(B); }
-inline Matrix inverse(const Matrix& A) { return A.inverse(); }
-#endif
-
 GTSAM_EXPORT Matrix LLt(const Matrix& A);
 
 GTSAM_EXPORT Matrix RtR(const Matrix& A);
--- gtsam-4.0.3.orig/gtsam/base/ThreadsafeException.h
+++ gtsam-4.0.3/gtsam/base/ThreadsafeException.h
@@ -71,12 +71,12 @@ protected:
           String(description.begin(), description.end())) {
   }
 
-  /// Default destructor doesn't have the throw()
-  virtual ~ThreadsafeException() throw () {
+  /// Default destructor doesn't have the noexcept
+  virtual ~ThreadsafeException() noexcept {
   }
 
 public:
-  virtual const char* what() const throw () {
+  const char* what() const noexcept override {
     return description_ ? description_->c_str() : "";
   }
 };
@@ -113,8 +113,8 @@ public:
 class CholeskyFailed : public gtsam::ThreadsafeException<CholeskyFailed>
 {
 public:
-  CholeskyFailed() throw() {}
-  virtual ~CholeskyFailed() throw() {}
+  CholeskyFailed() noexcept {}
+  virtual ~CholeskyFailed() noexcept {}
 };
 
 } // namespace gtsam
--- gtsam-4.0.3.orig/gtsam/base/Vector.h
+++ gtsam-4.0.3/gtsam/base/Vector.h
@@ -256,26 +256,6 @@ GTSAM_EXPORT Vector concatVectors(const
  * concatenate Vectors
  */
 GTSAM_EXPORT Vector concatVectors(size_t nrVectors, ...);
-
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-inline Vector abs(const Vector& v){return v.cwiseAbs();}
-inline Vector basis(size_t n, size_t i) { return Vector::Unit(n,i); }
-inline Vector delta(size_t n, size_t i, double value){ return Vector::Unit(n, i) * value;}
-inline size_t dim(const Vector& v) { return v.size(); }
-inline Vector ediv(const Vector &a, const Vector &b) {assert (b.size()==a.size()); return a.cwiseQuotient(b);}
-inline Vector esqrt(const Vector& v) { return v.cwiseSqrt();}
-inline Vector emul(const Vector &a, const Vector &b) {assert (b.size()==a.size()); return a.cwiseProduct(b);}
-inline double max(const Vector &a){return a.maxCoeff();}
-inline double norm_2(const Vector& v) {return v.norm();}
-inline Vector ones(size_t n) { return Vector::Ones(n); }
-inline Vector reciprocal(const Vector &a) {return a.array().inverse();}
-inline Vector repeat(size_t n, double value) {return Vector::Constant(n, value);}
-inline const Vector sub(const Vector &v, size_t i1, size_t i2) {return v.segment(i1,i2-i1);}
-inline void subInsert(Vector& fullVector, const Vector& subVector, size_t i) {fullVector.segment(i, subVector.size()) = subVector;}
-inline double sum(const Vector &a){return a.sum();}
-inline bool zero(const Vector& v){ return v.isZero(); }
-inline Vector zero(size_t n) { return Vector::Zero(n); }
-#endif
 } // namespace gtsam
 
 #include <boost/serialization/nvp.hpp>
--- gtsam-4.0.3.orig/gtsam/base/timing.cpp
+++ gtsam-4.0.3/gtsam/base/timing.cpp
@@ -89,7 +89,7 @@ void TimingOutline::print(const std::str
     childOrder[child.second->myOrder_] = child.second;
   }
   // Print children
-  for(const ChildOrder::value_type order_child: childOrder) {
+  for(const ChildOrder::value_type& order_child: childOrder) {
     std::string childOutline(outline);
     childOutline += "|   ";
     order_child.second->print(childOutline);
--- gtsam-4.0.3.orig/gtsam/base/treeTraversal/parallelTraversalTasks.h
+++ gtsam-4.0.3/gtsam/base/treeTraversal/parallelTraversalTasks.h
@@ -57,7 +57,7 @@ namespace gtsam {
               makeNewTasks(makeNewTasks),
               isPostOrderPhase(false) {}
 
-        tbb::task* execute()
+        tbb::task* execute() override
         {
           if(isPostOrderPhase)
           {
@@ -144,7 +144,7 @@ namespace gtsam {
           roots(roots), myData(myData), visitorPre(visitorPre), visitorPost(visitorPost),
           problemSizeThreshold(problemSizeThreshold) {}
 
-        tbb::task* execute()
+        tbb::task* execute() override
         {
           typedef PreOrderTask<NODE, DATA, VISITOR_PRE, VISITOR_POST> PreOrderTask;
           // Create data and tasks for our children
--- gtsam-4.0.3.orig/gtsam/config.h.in
+++ gtsam-4.0.3/gtsam/config.h.in
@@ -70,7 +70,7 @@
 #cmakedefine GTSAM_THROW_CHEIRALITY_EXCEPTION
 
 // Make sure dependent projects that want it can see deprecated functions
-#cmakedefine GTSAM_ALLOW_DEPRECATED_SINCE_V4
+#cmakedefine GTSAM_ALLOW_DEPRECATED_SINCE_V41
 
 // Publish flag about Eigen typedef
 #cmakedefine GTSAM_TYPEDEF_POINTS_TO_VECTORS
--- gtsam-4.0.3.orig/gtsam/discrete/DecisionTree-inl.h
+++ gtsam-4.0.3/gtsam/discrete/DecisionTree-inl.h
@@ -66,42 +66,42 @@ namespace gtsam {
     }
 
     /// Leaf-Leaf equality
-    bool sameLeaf(const Leaf& q) const {
+    bool sameLeaf(const Leaf& q) const override {
       return constant_ == q.constant_;
     }
 
     /// polymorphic equality: is q is a leaf, could be
-    bool sameLeaf(const Node& q) const {
+    bool sameLeaf(const Node& q) const override {
       return (q.isLeaf() && q.sameLeaf(*this));
     }
 
     /** equality up to tolerance */
-    bool equals(const Node& q, double tol) const {
+    bool equals(const Node& q, double tol) const override {
       const Leaf* other = dynamic_cast<const Leaf*> (&q);
       if (!other) return false;
       return std::abs(double(this->constant_ - other->constant_)) < tol;
     }
 
     /** print */
-    void print(const std::string& s) const {
+    void print(const std::string& s) const override {
       bool showZero = true;
       if (showZero || constant_) std::cout << s << " Leaf " << constant_ << std::endl;
     }
 
     /** to graphviz file */
-    void dot(std::ostream& os, bool showZero) const {
+    void dot(std::ostream& os, bool showZero) const override {
       if (showZero || constant_) os << "\"" << this->id() << "\" [label=\""
           << boost::format("%4.2g") % constant_
           << "\", shape=box, rank=sink, height=0.35, fixedsize=true]\n"; // width=0.55,
     }
 
     /** evaluate */
-    const Y& operator()(const Assignment<L>& x) const {
+    const Y& operator()(const Assignment<L>& x) const override {
       return constant_;
     }
 
     /** apply unary operator */
-    NodePtr apply(const Unary& op) const {
+    NodePtr apply(const Unary& op) const override {
       NodePtr f(new Leaf(op(constant_)));
       return f;
     }
@@ -111,27 +111,27 @@ namespace gtsam {
     // Simply calls apply on argument to call correct virtual method:
     // fL.apply_f_op_g(gL) -> gL.apply_g_op_fL(fL) (below)
     // fL.apply_f_op_g(gC) -> gC.apply_g_op_fL(fL) (Choice)
-    NodePtr apply_f_op_g(const Node& g, const Binary& op) const {
+    NodePtr apply_f_op_g(const Node& g, const Binary& op) const override {
       return g.apply_g_op_fL(*this, op);
     }
 
     // Applying binary operator to two leaves results in a leaf
-    NodePtr apply_g_op_fL(const Leaf& fL, const Binary& op) const {
+    NodePtr apply_g_op_fL(const Leaf& fL, const Binary& op) const override {
       NodePtr h(new Leaf(op(fL.constant_, constant_))); // fL op gL
       return h;
     }
 
     // If second argument is a Choice node, call it's apply with leaf as second
-    NodePtr apply_g_op_fC(const Choice& fC, const Binary& op) const {
+    NodePtr apply_g_op_fC(const Choice& fC, const Binary& op) const override {
       return fC.apply_fC_op_gL(*this, op); // operand order back to normal
     }
 
     /** choose a branch, create new memory ! */
-    NodePtr choose(const L& label, size_t index) const {
+    NodePtr choose(const L& label, size_t index) const override {
       return NodePtr(new Leaf(constant()));
     }
 
-    bool isLeaf() const { return true; }
+    bool isLeaf() const override { return true; }
 
   }; // Leaf
 
@@ -175,7 +175,7 @@ namespace gtsam {
         return f;
     }
 
-    bool isLeaf() const { return false; }
+    bool isLeaf() const override { return false; }
 
     /** Constructor, given choice label and mandatory expected branch count */
     Choice(const L& label, size_t count) :
@@ -236,7 +236,7 @@ namespace gtsam {
     }
 
     /** print (as a tree) */
-    void print(const std::string& s) const {
+    void print(const std::string& s) const override {
       std::cout << s << " Choice(";
       //        std::cout << this << ",";
       std::cout << label_ << ") " << std::endl;
@@ -245,7 +245,7 @@ namespace gtsam {
     }
 
     /** output to graphviz (as a a graph) */
-    void dot(std::ostream& os, bool showZero) const {
+    void dot(std::ostream& os, bool showZero) const override {
       os << "\"" << this->id() << "\" [shape=circle, label=\"" << label_
           << "\"]\n";
       for (size_t i = 0; i < branches_.size(); i++) {
@@ -266,17 +266,17 @@ namespace gtsam {
     }
 
     /// Choice-Leaf equality: always false
-    bool sameLeaf(const Leaf& q) const {
+    bool sameLeaf(const Leaf& q) const override {
       return false;
     }
 
     /// polymorphic equality: if q is a leaf, could be...
-    bool sameLeaf(const Node& q) const {
+    bool sameLeaf(const Node& q) const override {
       return (q.isLeaf() && q.sameLeaf(*this));
     }
 
     /** equality up to tolerance */
-    bool equals(const Node& q, double tol) const {
+    bool equals(const Node& q, double tol) const override {
       const Choice* other = dynamic_cast<const Choice*> (&q);
       if (!other) return false;
       if (this->label_ != other->label_) return false;
@@ -288,7 +288,7 @@ namespace gtsam {
     }
 
     /** evaluate */
-    const Y& operator()(const Assignment<L>& x) const {
+    const Y& operator()(const Assignment<L>& x) const override {
 #ifndef NDEBUG
       typename Assignment<L>::const_iterator it = x.find(label_);
       if (it == x.end()) {
@@ -314,7 +314,7 @@ namespace gtsam {
     }
 
     /** apply unary operator */
-    NodePtr apply(const Unary& op) const {
+    NodePtr apply(const Unary& op) const override {
       boost::shared_ptr<Choice> r(new Choice(label_, *this, op));
       return Unique(r);
     }
@@ -324,12 +324,12 @@ namespace gtsam {
     // Simply calls apply on argument to call correct virtual method:
     // fC.apply_f_op_g(gL) -> gL.apply_g_op_fC(fC) -> (Leaf)
     // fC.apply_f_op_g(gC) -> gC.apply_g_op_fC(fC) -> (below)
-    NodePtr apply_f_op_g(const Node& g, const Binary& op) const {
+    NodePtr apply_f_op_g(const Node& g, const Binary& op) const override {
       return g.apply_g_op_fC(*this, op);
     }
 
     // If second argument of binary op is Leaf node, recurse on branches
-    NodePtr apply_g_op_fL(const Leaf& fL, const Binary& op) const {
+    NodePtr apply_g_op_fL(const Leaf& fL, const Binary& op) const override {
       boost::shared_ptr<Choice> h(new Choice(label(), nrChoices()));
       for(NodePtr branch: branches_)
               h->push_back(fL.apply_f_op_g(*branch, op));
@@ -337,7 +337,7 @@ namespace gtsam {
     }
 
     // If second argument of binary op is Choice, call constructor
-    NodePtr apply_g_op_fC(const Choice& fC, const Binary& op) const {
+    NodePtr apply_g_op_fC(const Choice& fC, const Binary& op) const override {
       boost::shared_ptr<Choice> h(new Choice(fC, *this, op));
       return Unique(h);
     }
@@ -352,7 +352,7 @@ namespace gtsam {
     }
 
     /** choose a branch, recursively */
-    NodePtr choose(const L& label, size_t index) const {
+    NodePtr choose(const L& label, size_t index) const override {
       if (label_ == label)
         return branches_[index]; // choose branch
 
--- gtsam-4.0.3.orig/gtsam/discrete/DecisionTreeFactor.cpp
+++ gtsam-4.0.3/gtsam/discrete/DecisionTreeFactor.cpp
@@ -69,7 +69,7 @@ namespace gtsam {
     for(Key j: f.keys()) cs[j] = f.cardinality(j);
     // Convert map into keys
     DiscreteKeys keys;
-    for(const DiscreteKey& key: cs)
+    for(const std::pair<const Key,size_t>& key: cs)
       keys.push_back(key);
     // apply operand
     ADT result = ADT::apply(f, op);
--- gtsam-4.0.3.orig/gtsam/discrete/DecisionTreeFactor.h
+++ gtsam-4.0.3/gtsam/discrete/DecisionTreeFactor.h
@@ -69,23 +69,23 @@ namespace gtsam {
     /// @{
 
     /// equality
-    bool equals(const DiscreteFactor& other, double tol = 1e-9) const;
+    bool equals(const DiscreteFactor& other, double tol = 1e-9) const override;
 
     // print
-    virtual void print(const std::string& s = "DecisionTreeFactor:\n",
-        const KeyFormatter& formatter = DefaultKeyFormatter) const;
+    void print(const std::string& s = "DecisionTreeFactor:\n",
+        const KeyFormatter& formatter = DefaultKeyFormatter) const override;
 
     /// @}
     /// @name Standard Interface
     /// @{
 
     /// Value is just look up in AlgebraicDecisonTree
-    virtual double operator()(const Values& values) const {
+    double operator()(const Values& values) const override {
       return Potentials::operator()(values);
     }
 
     /// multiply two factors
-    DecisionTreeFactor operator*(const DecisionTreeFactor& f) const {
+    DecisionTreeFactor operator*(const DecisionTreeFactor& f) const override {
       return apply(f, ADT::Ring::mul);
     }
 
@@ -95,7 +95,7 @@ namespace gtsam {
     }
 
     /// Convert into a decisiontree
-    virtual DecisionTreeFactor toDecisionTreeFactor() const {
+    DecisionTreeFactor toDecisionTreeFactor() const override {
       return *this;
     }
 
--- gtsam-4.0.3.orig/gtsam/discrete/DiscreteBayesTree.h
+++ gtsam-4.0.3/gtsam/discrete/DiscreteBayesTree.h
@@ -45,6 +45,7 @@ class GTSAM_EXPORT DiscreteBayesTreeCliq
   typedef boost::shared_ptr<This> shared_ptr;
   typedef boost::weak_ptr<This> weak_ptr;
   DiscreteBayesTreeClique() {}
+  virtual ~DiscreteBayesTreeClique() {}
   DiscreteBayesTreeClique(
       const boost::shared_ptr<DiscreteConditional>& conditional)
       : Base(conditional) {}
--- gtsam-4.0.3.orig/gtsam/discrete/DiscreteConditional.h
+++ gtsam-4.0.3/gtsam/discrete/DiscreteConditional.h
@@ -85,10 +85,10 @@ public:
 
   /// GTSAM-style print
   void print(const std::string& s = "Discrete Conditional: ",
-      const KeyFormatter& formatter = DefaultKeyFormatter) const;
+      const KeyFormatter& formatter = DefaultKeyFormatter) const override;
 
   /// GTSAM-style equals
-  bool equals(const DiscreteFactor& other, double tol = 1e-9) const;
+  bool equals(const DiscreteFactor& other, double tol = 1e-9) const override;
 
   /// @}
   /// @name Standard Interface
@@ -102,7 +102,7 @@ public:
   }
 
   /// Evaluate, just look up in AlgebraicDecisonTree
-  virtual double operator()(const Values& values) const {
+  double operator()(const Values& values) const override {
     return Potentials::operator()(values);
   }
 
--- gtsam-4.0.3.orig/gtsam/discrete/Potentials.cpp
+++ gtsam-4.0.3/gtsam/discrete/Potentials.cpp
@@ -56,7 +56,7 @@ bool Potentials::equals(const Potentials
 /* ************************************************************************* */
 void Potentials::print(const string& s, const KeyFormatter& formatter) const {
   cout << s << "\n  Cardinalities: {";
-  for (const DiscreteKey& key : cardinalities_)
+  for (const std::pair<const Key,size_t>& key : cardinalities_)
     cout << formatter(key.first) << ":" << key.second << ", ";
   cout << "}" << endl;
   ADT::print(" ");
--- gtsam-4.0.3.orig/gtsam/geometry/Cal3DS2.h
+++ gtsam-4.0.3/gtsam/geometry/Cal3DS2.h
@@ -60,7 +60,7 @@ public:
   /// @{
 
   /// print with optional string
-  virtual void print(const std::string& s = "") const ;
+  void print(const std::string& s = "") const override;
 
   /// assert equality up to a tolerance
   bool equals(const Cal3DS2& K, double tol = 10e-9) const;
@@ -86,7 +86,7 @@ public:
   /// @{
 
   /// @return a deep copy of this object
-  virtual boost::shared_ptr<Base> clone() const {
+  boost::shared_ptr<Base> clone() const override {
     return boost::shared_ptr<Base>(new Cal3DS2(*this));
   }
 
--- gtsam-4.0.3.orig/gtsam/geometry/Cal3DS2_Base.h
+++ gtsam-4.0.3/gtsam/geometry/Cal3DS2_Base.h
@@ -69,7 +69,7 @@ public:
   /// @{
 
   /// print with optional string
-  virtual void print(const std::string& s = "") const ;
+  virtual void print(const std::string& s = "") const;
 
   /// assert equality up to a tolerance
   bool equals(const Cal3DS2_Base& K, double tol = 10e-9) const;
--- gtsam-4.0.3.orig/gtsam/geometry/Cal3Unified.h
+++ gtsam-4.0.3/gtsam/geometry/Cal3Unified.h
@@ -75,7 +75,7 @@ public:
   /// @{
 
   /// print with optional string
-  virtual void print(const std::string& s = "") const ;
+  void print(const std::string& s = "") const override;
 
   /// assert equality up to a tolerance
   bool equals(const Cal3Unified& K, double tol = 10e-9) const;
--- gtsam-4.0.3.orig/gtsam/geometry/EssentialMatrix.h
+++ gtsam-4.0.3/gtsam/geometry/EssentialMatrix.h
@@ -176,17 +176,6 @@ class EssentialMatrix {
 
   /// @}
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  Point3 transform_to(const Point3& p,
-      OptionalJacobian<3, 5> DE = boost::none,
-      OptionalJacobian<3, 3> Dpoint = boost::none) const {
-    return transformTo(p, DE, Dpoint);
-  };
-  /// @}
-#endif
-
  private:
   /// @name Advanced Interface
   /// @{
--- gtsam-4.0.3.orig/gtsam/geometry/PinholeCamera.h
+++ gtsam-4.0.3/gtsam/geometry/PinholeCamera.h
@@ -175,7 +175,7 @@ public:
   }
 
   /// return calibration
-  const Calibration& calibration() const {
+  const Calibration& calibration() const override {
     return K_;
   }
 
--- gtsam-4.0.3.orig/gtsam/geometry/PinholePose.h
+++ gtsam-4.0.3/gtsam/geometry/PinholePose.h
@@ -361,7 +361,7 @@ public:
   }
 
   /// return calibration
-  virtual const CALIBRATION& calibration() const {
+  const CALIBRATION& calibration() const override {
     return *K_;
   }
 
--- gtsam-4.0.3.orig/gtsam/geometry/PinholeSet.h
+++ gtsam-4.0.3/gtsam/geometry/PinholeSet.h
@@ -45,7 +45,7 @@ public:
   /// @{
 
   /// print
-  virtual void print(const std::string& s = "") const {
+  void print(const std::string& s = "") const override {
     Base::print(s);
   }
 
--- gtsam-4.0.3.orig/gtsam/geometry/Point2.cpp
+++ gtsam-4.0.3/gtsam/geometry/Point2.cpp
@@ -79,18 +79,6 @@ ostream &operator<<(ostream &os, const P
   return os;
 }
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-boost::optional<Point2> CircleCircleIntersection(double R_d, double r_d, double tol) {
-  return circleCircleIntersection(R_d, r_d, tol);
-}
-std::list<Point2> CircleCircleIntersection(Point2 c1, Point2 c2, boost::optional<Point2> fh) {
-  return circleCircleIntersection(c1, c2, fh);
-}
-std::list<Point2> CircleCircleIntersection(Point2 c1, double r1, Point2 c2, double r2, double tol) {
-  return circleCircleIntersection(c1, r1, c2, r2, tol);
-}
-#endif
-
 #endif // GTSAM_TYPEDEF_POINTS_TO_VECTORS
 
 /* ************************************************************************* */
--- gtsam-4.0.3.orig/gtsam/geometry/Point2.h
+++ gtsam-4.0.3/gtsam/geometry/Point2.h
@@ -46,12 +46,7 @@ public:
   /// @{
 
   /// default constructor
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-    // Deprecated default constructor initializes to zero, in contrast to new behavior below
-    Point2() { setZero(); }
-#else
-    Point2() {}
-#endif
+  Point2() {}
 
   using Vector2::Vector2;
 
@@ -113,25 +108,7 @@ public:
   /// Streaming
   GTSAM_EXPORT friend std::ostream &operator<<(std::ostream &os, const Point2& p);
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  Point2 inverse() const { return -(*this); }
-  Point2 compose(const Point2& q) const { return (*this)+q;}
-  Point2 between(const Point2& q) const { return q-(*this);}
-  Vector2 localCoordinates(const Point2& q) const { return between(q);}
-  Point2 retract(const Vector2& v) const { return compose(Point2(v));}
-  static Vector2 Logmap(const Point2& p) { return p;}
-  static Point2 Expmap(const Vector2& v) { return Point2(v);}
-  inline double dist(const Point2& p2) const {return distance(p2);}
-  GTSAM_EXPORT static boost::optional<Point2> CircleCircleIntersection(double R_d, double r_d, double tol = 1e-9);
-  GTSAM_EXPORT static std::list<Point2> CircleCircleIntersection(Point2 c1, Point2 c2, boost::optional<Point2> fh);
-  GTSAM_EXPORT static std::list<Point2> CircleCircleIntersection(Point2 c1, double r1, Point2 c2, double r2, double tol = 1e-9);
-  /// @}
-#endif
-
-private:
-
+ private:
   /// @name Advanced Interface
   /// @{
 
--- gtsam-4.0.3.orig/gtsam/geometry/Point3.cpp
+++ gtsam-4.0.3/gtsam/geometry/Point3.cpp
@@ -62,23 +62,6 @@ ostream &operator<<(ostream &os, const P
   return os;
 }
 
-/* ************************************************************************* */
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-Point3 Point3::add(const Point3 &q, OptionalJacobian<3,3> H1,
-    OptionalJacobian<3,3> H2) const {
-  if (H1) *H1 = I_3x3;
-  if (H2) *H2 = I_3x3;
-  return *this + q;
-}
-
-Point3 Point3::sub(const Point3 &q, OptionalJacobian<3,3> H1,
-    OptionalJacobian<3,3> H2) const {
-  if (H1) *H1 = I_3x3;
-  if (H2) *H2 = -I_3x3;
-  return *this - q;
-}
-#endif
-
 #endif
 /* ************************************************************************* */
 double distance3(const Point3 &p1, const Point3 &q, OptionalJacobian<1, 3> H1,
--- gtsam-4.0.3.orig/gtsam/geometry/Point3.h
+++ gtsam-4.0.3/gtsam/geometry/Point3.h
@@ -51,11 +51,6 @@ class Point3 : public Vector3 {
     /// @name Standard Constructors
     /// @{
 
-    // Deprecated default constructor initializes to zero, in contrast to new behavior below
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-    Point3() { setZero(); }
-#endif
-
     using Vector3::Vector3;
 
     /// @}
@@ -118,27 +113,7 @@ class Point3 : public Vector3 {
     /// Output stream operator
     GTSAM_EXPORT friend std::ostream &operator<<(std::ostream &os, const Point3& p);
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-    /// @name Deprecated
-    /// @{
-    Point3 inverse() const { return -(*this);}
-    Point3 compose(const Point3& q) const { return (*this)+q;}
-    Point3 between(const Point3& q) const { return q-(*this);}
-    Vector3 localCoordinates(const Point3& q) const { return between(q);}
-    Point3 retract(const Vector3& v) const { return compose(Point3(v));}
-    static Vector3 Logmap(const Point3& p) { return p;}
-    static Point3 Expmap(const Vector3& v) { return Point3(v);}
-    inline double dist(const Point3& q) const { return (q - *this).norm(); }
-    Point3 normalize(OptionalJacobian<3, 3> H = boost::none) const { return normalized(H);}
-	GTSAM_EXPORT Point3 add(const Point3& q, OptionalJacobian<3, 3> H1 = boost::none,
-               OptionalJacobian<3, 3> H2 = boost::none) const;
-	GTSAM_EXPORT Point3 sub(const Point3& q, OptionalJacobian<3, 3> H1 = boost::none,
-               OptionalJacobian<3, 3> H2 = boost::none) const;
-  /// @}
-#endif
-
-  private:
-
+   private:
     /** Serialization function */
     friend class boost::serialization::access;
     template<class ARCHIVE>
--- gtsam-4.0.3.orig/gtsam/geometry/Pose2.h
+++ gtsam-4.0.3/gtsam/geometry/Pose2.h
@@ -289,22 +289,6 @@ public:
 
   /// @}
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  Point2 transform_from(const Point2& point,
-                        OptionalJacobian<2, 3> Dpose = boost::none,
-                        OptionalJacobian<2, 2> Dpoint = boost::none) const {
-    return transformFrom(point, Dpose, Dpoint);
-  }
-  Point2 transform_to(const Point2& point,
-                      OptionalJacobian<2, 3> Dpose = boost::none,
-                      OptionalJacobian<2, 2> Dpoint = boost::none) const {
-    return transformTo(point, Dpose, Dpoint);
-  }
-    /// @}
-#endif
-
  private:
 
   // Serialization function
--- gtsam-4.0.3.orig/gtsam/geometry/Pose3.cpp
+++ gtsam-4.0.3/gtsam/geometry/Pose3.cpp
@@ -106,9 +106,7 @@ Vector6 Pose3::adjointTranspose(const Ve
 
 /* ************************************************************************* */
 void Pose3::print(const string& s) const {
-  cout << s;
-  R_.print("R:\n");
-  cout << t_ << ";" << endl;
+  cout << (s.empty() ? s : s + " ") << *this << endl;
 }
 
 /* ************************************************************************* */
@@ -293,15 +291,6 @@ Pose3 Pose3::transformPoseFrom(const Pos
 }
 
 /* ************************************************************************* */
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-Pose3 Pose3::transform_to(const Pose3& pose) const {
-  Rot3 cRv = R_ * Rot3(pose.R_.inverse());
-  Point3 t = pose.transform_to(t_);
-  return Pose3(cRv, t);
-}
-#endif
-
-/* ************************************************************************* */
 Pose3 Pose3::transformPoseTo(const Pose3& wTb, OptionalJacobian<6, 6> Hself,
                                                OptionalJacobian<6, 6> HwTb) const {
   if (Hself) *Hself = -wTb.inverse().AdjointMap() * AdjointMap();
@@ -439,9 +428,9 @@ boost::optional<Pose3> align(const vecto
 
 /* ************************************************************************* */
 std::ostream &operator<<(std::ostream &os, const Pose3& pose) {
-  os << pose.rotation() << "\n";
-  const Point3& t = pose.translation();
-  os << '[' << t.x() << ", " << t.y() << ", " << t.z() << "]\';\n";
+  // Both Rot3 and Point3 have ostream definitions so we use them.
+  os << "R: " << pose.rotation() << "\n";
+  os << "t: " << pose.translation();
   return os;
 }
 
--- gtsam-4.0.3.orig/gtsam/geometry/Pose3.h
+++ gtsam-4.0.3/gtsam/geometry/Pose3.h
@@ -326,30 +326,6 @@ public:
   GTSAM_EXPORT
   friend std::ostream &operator<<(std::ostream &os, const Pose3& p);
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  Point3 transform_from(const Point3& point,
-                        OptionalJacobian<3, 6> Hself = boost::none,
-                        OptionalJacobian<3, 3> Hpoint = boost::none) const {
-    return transformFrom(point, Hself, Hpoint);
-  }
-  Point3 transform_to(const Point3& point,
-                      OptionalJacobian<3, 6> Hself = boost::none,
-                      OptionalJacobian<3, 3> Hpoint = boost::none) const {
-    return transformTo(point, Hself, Hpoint);
-  }
-  Pose3 transform_pose_to(const Pose3& pose,
-                          OptionalJacobian<6, 6> Hself = boost::none,
-                          OptionalJacobian<6, 6> Hpose = boost::none) const {
-    return transformPoseTo(pose, Hself, Hpose);
-  }
-  /** 
-  * @deprecated: this function is neither here not there. */
-  Pose3 transform_to(const Pose3& pose) const;
-  /// @}
-#endif
-
  private:
   /** Serialization function */
   friend class boost::serialization::access;
@@ -380,11 +356,6 @@ inline Matrix wedge<Pose3>(const Vector&
   return Pose3::wedge(xi(0), xi(1), xi(2), xi(3), xi(4), xi(5));
 }
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-// deprecated: use Pose3::Align with point pairs ordered the opposite way
-GTSAM_EXPORT boost::optional<Pose3> align(const std::vector<Point3Pair>& baPointPairs);
-#endif
-
 // For MATLAB wrapper
 typedef std::vector<Pose3> Pose3Vector;
 
--- gtsam-4.0.3.orig/gtsam/geometry/Rot3.cpp
+++ gtsam-4.0.3/gtsam/geometry/Rot3.cpp
@@ -32,7 +32,8 @@ namespace gtsam {
 
 /* ************************************************************************* */
 void Rot3::print(const std::string& s) const {
-  gtsam::print((Matrix)matrix(), s);
+  cout << (s.empty() ? "R: " : s + " ");
+  gtsam::print(static_cast<Matrix>(matrix()));
 }
 
 /* ************************************************************************* */
@@ -222,10 +223,7 @@ pair<Matrix3, Vector3> RQ(const Matrix3&
 
 /* ************************************************************************* */
 ostream &operator<<(ostream &os, const Rot3& R) {
-  os << "\n";
-  os << '|' << R.r1().x() << ", " << R.r2().x() << ", " << R.r3().x() << "|\n";
-  os << '|' << R.r1().y() << ", " << R.r2().y() << ", " << R.r3().y() << "|\n";
-  os << '|' << R.r1().z() << ", " << R.r2().z() << ", " << R.r3().z() << "|\n";
+  os << R.matrix().format(matlabFormat());
   return os;
 }
 
--- gtsam-4.0.3.orig/gtsam/geometry/Rot3.h
+++ gtsam-4.0.3/gtsam/geometry/Rot3.h
@@ -254,7 +254,7 @@ namespace gtsam {
     /// @{
 
     /** print */
-    void print(const std::string& s="R") const;
+    void print(const std::string& s="") const;
 
     /** equals with an tolerance */
     bool equals(const Rot3& p, double tol = 1e-9) const;
@@ -500,23 +500,6 @@ namespace gtsam {
 
     /// @}
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-    /// @name Deprecated
-    /// @{
-    static Rot3 rodriguez(const Point3&  axis, double angle) { return AxisAngle(axis, angle); }
-    static Rot3 rodriguez(const Unit3&   axis, double angle) { return AxisAngle(axis, angle); }
-    static Rot3 rodriguez(const Vector3& w)                  { return Rodrigues(w); }
-    static Rot3 rodriguez(double wx, double wy, double wz)   { return Rodrigues(wx, wy, wz); }
-    static Rot3 yaw  (double t) { return Yaw(t); }
-    static Rot3 pitch(double t) { return Pitch(t); }
-    static Rot3 roll (double t) { return Roll(t); }
-    static Rot3 ypr(double y, double p, double r) { return Ypr(r,p,y);}
-    static Rot3 quaternion(double w, double x, double y, double z) {
-      return Rot3::Quaternion(w, x, y, z);
-    }
-  /// @}
-#endif
-
    private:
     /** Serialization function */
     friend class boost::serialization::access;
--- gtsam-4.0.3.orig/gtsam/geometry/SO4.cpp
+++ gtsam-4.0.3/gtsam/geometry/SO4.cpp
@@ -35,7 +35,7 @@ namespace gtsam {
 
 // TODO(frank): is this better than SOn::Random?
 // /* *************************************************************************
-// */ static Vector3 randomOmega(boost::mt19937 &rng) {
+// */ static Vector3 randomOmega(std::mt19937 &rng) {
 //   static std::uniform_real_distribution<double> randomAngle(-M_PI, M_PI);
 //   return Unit3::Random(rng).unitVector() * randomAngle(rng);
 // }
@@ -43,7 +43,7 @@ namespace gtsam {
 // /* *************************************************************************
 // */
 // // Create random SO(4) element using direct product of lie algebras.
-// SO4 SO4::Random(boost::mt19937 &rng) {
+// SO4 SO4::Random(std::mt19937 &rng) {
 //   Vector6 delta;
 //   delta << randomOmega(rng), randomOmega(rng);
 //   return SO4::Expmap(delta);
--- gtsam-4.0.3.orig/gtsam/geometry/SO4.h
+++ gtsam-4.0.3/gtsam/geometry/SO4.h
@@ -34,7 +34,7 @@ namespace gtsam {
 using SO4 = SO<4>;
 
 // /// Random SO(4) element (no big claims about uniformity)
-// static SO4 Random(boost::mt19937 &rng);
+// static SO4 Random(std::mt19937 &rng);
 
 // Below are all declarations of SO<4> specializations.
 // They are *defined* in SO4.cpp.
--- gtsam-4.0.3.orig/gtsam/geometry/SOn-inl.h
+++ gtsam-4.0.3/gtsam/geometry/SOn-inl.h
@@ -26,13 +26,13 @@ using namespace std;
 
 namespace gtsam {
 
-// Implementation for N>5 just uses dynamic version
+// Implementation for N>=5 just uses dynamic version
 template <int N>
 typename SO<N>::MatrixNN SO<N>::Hat(const TangentVector& xi) {
   return SOn::Hat(xi);
 }
 
-// Implementation for N>5 just uses dynamic version
+// Implementation for N>=5 just uses dynamic version
 template <int N>
 typename SO<N>::TangentVector SO<N>::Vee(const MatrixNN& X) {
   return SOn::Vee(X);
@@ -99,12 +99,8 @@ typename SO<N>::VectorN2 SO<N>::vec(
   if (H) {
     // Calculate P matrix of vectorized generators
     // TODO(duy): Should we refactor this as the jacobian of Hat?
+    Matrix P = VectorizedGenerators(n);
     const size_t d = dim();
-    Matrix P(n2, d);
-    for (size_t j = 0; j < d; j++) {
-      const auto X = Hat(Eigen::VectorXd::Unit(d, j));
-      P.col(j) = Eigen::Map<const Matrix>(X.data(), n2, 1);
-    }
     H->resize(n2, d);
     for (size_t i = 0; i < n; i++) {
       H->block(i * n, 0, n, d) = matrix_ * P.block(i * n, 0, n, d);
--- gtsam-4.0.3.orig/gtsam/geometry/SOn.h
+++ gtsam-4.0.3/gtsam/geometry/SOn.h
@@ -290,7 +290,34 @@ class SO : public LieGroup<SO<N>, intern
    * */
   VectorN2 vec(OptionalJacobian<internal::NSquaredSO(N), dimension> H =
                    boost::none) const;
-  /// @}
+
+  /// Calculate N^2 x dim matrix of vectorized Lie algebra generators for SO(N)
+  template <int N_ = N, typename = IsFixed<N_>>
+  static Matrix VectorizedGenerators() {
+    constexpr size_t N2 = static_cast<size_t>(N * N);
+    Matrix G(N2, dimension);
+    for (size_t j = 0; j < dimension; j++) {
+      const auto X = Hat(Vector::Unit(dimension, j));
+      G.col(j) = Eigen::Map<const Matrix>(X.data(), N2, 1);
+    }
+    return G;
+  }
+
+  /// Calculate n^2 x dim matrix of vectorized Lie algebra generators for SO(n)
+  template <int N_ = N, typename = IsDynamic<N_>>
+  static Matrix VectorizedGenerators(size_t n = 0) {
+    const size_t n2 = n * n, dim = Dimension(n);
+    Matrix G(n2, dim);
+    for (size_t j = 0; j < dim; j++) {
+      const auto X = Hat(Vector::Unit(dim, j));
+      G.col(j) = Eigen::Map<const Matrix>(X.data(), n2, 1);
+    }
+    return G;
+  }
+
+  /// @{
+  /// @name Serialization
+  /// @{
 
   template <class Archive>
   friend void save(Archive&, SO&, const unsigned int);
@@ -300,6 +327,8 @@ class SO : public LieGroup<SO<N>, intern
   friend void serialize(Archive&, SO&, const unsigned int);
   friend class boost::serialization::access;
   friend class Rot3;  // for serialize
+
+  /// @}
 };
 
 using SOn = SO<Eigen::Dynamic>;
--- gtsam-4.0.3.orig/gtsam/geometry/tests/testPose3.cpp
+++ gtsam-4.0.3/gtsam/geometry/tests/testPose3.cpp
@@ -862,7 +862,15 @@ TEST( Pose3, stream)
   Pose3 T;
   std::ostringstream os;
   os << T;
-  EXPECT(os.str() == "\n|1, 0, 0|\n|0, 1, 0|\n|0, 0, 1|\n\n[0, 0, 0]';\n");
+
+  string expected;
+#ifdef GTSAM_TYPEDEF_POINTS_TO_VECTORS
+  expected = "R: [\n\t1, 0, 0;\n\t0, 1, 0;\n\t0, 0, 1\n]\nt: 0\n0\n0";;
+#else
+  expected = "R: [\n\t1, 0, 0;\n\t0, 1, 0;\n\t0, 0, 1\n]\nt: [0, 0, 0]'";
+#endif
+
+  EXPECT(os.str() == expected);
 }
 
 //******************************************************************************
@@ -1032,19 +1040,22 @@ TEST(Pose3, print) {
   std::stringstream expected;
   Point3 translation(1, 2, 3);
 
+  // Add expected rotation
+  expected << "R: [\n\t1, 0, 0;\n\t0, 1, 0;\n\t0, 0, 1\n]\n";
+
 #ifdef GTSAM_TYPEDEF_POINTS_TO_VECTORS
-  expected << "1\n"
+  expected << "t: 1\n"
               "2\n"
-              "3;\n";
+              "3\n";
 #else
-  expected << '[' << translation.x() << ", " << translation.y() << ", " << translation.z() << "]\';";
+  expected << "t: [" << translation.x() << ", " << translation.y() << ", " << translation.z() << "]'\n";
 #endif
 
   // reset cout to the original stream
   std::cout.rdbuf(oldbuf);
 
   // Get substring corresponding to translation part
-  std::string actual = redirectStream.str().substr(38, 11);
+  std::string actual = redirectStream.str();
 
   CHECK_EQUAL(expected.str(), actual);
 }
--- gtsam-4.0.3.orig/gtsam/geometry/tests/testRot3.cpp
+++ gtsam-4.0.3/gtsam/geometry/tests/testRot3.cpp
@@ -608,7 +608,8 @@ TEST( Rot3, stream)
   Rot3 R;
   std::ostringstream os;
   os << R;
-  EXPECT(os.str() == "\n|1, 0, 0|\n|0, 1, 0|\n|0, 0, 1|\n");
+  string expected = "[\n\t1, 0, 0;\n\t0, 1, 0;\n\t0, 0, 1\n]";
+  EXPECT(os.str() == expected);
 }
 
 /* ************************************************************************* */
--- gtsam-4.0.3.orig/gtsam/geometry/triangulation.h
+++ gtsam-4.0.3/gtsam/geometry/triangulation.h
@@ -123,27 +123,6 @@ std::pair<NonlinearFactorGraph, Values>
   return std::make_pair(graph, values);
 }
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-/// DEPRECATED: PinholeCamera specific version
-template<class CALIBRATION>
-Point3 triangulateNonlinear(
-    const CameraSet<PinholeCamera<CALIBRATION> >& cameras,
-    const Point2Vector& measurements, const Point3& initialEstimate) {
-  return triangulateNonlinear<PinholeCamera<CALIBRATION> > //
-  (cameras, measurements, initialEstimate);
-}
-
-/// DEPRECATED: PinholeCamera specific version
-template<class CALIBRATION>
-std::pair<NonlinearFactorGraph, Values> triangulationGraph(
-    const CameraSet<PinholeCamera<CALIBRATION> >& cameras,
-    const Point2Vector& measurements, Key landmarkKey,
-    const Point3& initialEstimate) {
-  return triangulationGraph<PinholeCamera<CALIBRATION> > //
-  (cameras, measurements, landmarkKey, initialEstimate);
-}
-#endif
-
 /**
  * Optimize for triangulation
  * @param graph nonlinear factors for projection
--- gtsam-4.0.3.orig/gtsam/inference/BayesTree.h
+++ gtsam-4.0.3/gtsam/inference/BayesTree.h
@@ -249,25 +249,6 @@ namespace gtsam {
     // Friend JunctionTree because it directly fills roots and nodes index.
     template<class BAYESRTEE, class GRAPH> friend class EliminatableClusterTree;
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-   public:
-    /// @name Deprecated
-    /// @{
-    void removePath(sharedClique clique, BayesNetType& bn, Cliques& orphans) {
-      removePath(clique, &bn, &orphans);
-    }
-    void removeTop(const KeyVector& keys, BayesNetType& bn, Cliques& orphans) {
-      removeTop(keys, &bn, &orphans);
-    }
-    void getCliqueData(BayesTreeCliqueData& stats, sharedClique clique) const {
-      getCliqueData(clique, &stats);
-    }
-    void addFactorsToGraph(FactorGraph<FactorType>& graph) const{
-      addFactorsToGraph(& graph);
-    }
-    /// @}
-#endif
-
    private:
     /** Serialization function */
     friend class boost::serialization::access;
@@ -299,7 +280,7 @@ namespace gtsam {
       this->keys_.assign(clique->conditional()->beginParents(), clique->conditional()->endParents());
     }
 
-    void print(const std::string& s="", const KeyFormatter& formatter = DefaultKeyFormatter) const {
+    void print(const std::string& s="", const KeyFormatter& formatter = DefaultKeyFormatter) const override {
       clique->print(s + "stored clique", formatter);
     }
   };
--- gtsam-4.0.3.orig/gtsam/inference/BayesTreeCliqueBase.h
+++ gtsam-4.0.3/gtsam/inference/BayesTreeCliqueBase.h
@@ -100,7 +100,7 @@ namespace gtsam {
     bool equals(const DERIVED& other, double tol = 1e-9) const;
 
     /** print this node */
-    void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+    virtual void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
 
     /// @}
     /// @name Standard Interface
--- gtsam-4.0.3.orig/gtsam/inference/ISAM.h
+++ gtsam-4.0.3/gtsam/inference/ISAM.h
@@ -72,17 +72,6 @@ class ISAM : public BAYESTREE {
       const Eliminate& function = EliminationTraitsType::DefaultEliminate);
 
   /// @}
-
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  void update_internal(
-      const FactorGraphType& newFactors, Cliques& orphans,
-      const Eliminate& function = EliminationTraitsType::DefaultEliminate) {
-    updateInternal(newFactors, &orphans, function);
-  }
-  /// @}
-#endif
 };
 
 }  // namespace gtsam
--- gtsam-4.0.3.orig/gtsam/inference/inferenceExceptions.h
+++ gtsam-4.0.3/gtsam/inference/inferenceExceptions.h
@@ -28,9 +28,9 @@ namespace gtsam {
    *  with an ordering that does not include all of the variables. */
   class InconsistentEliminationRequested : public std::exception {
   public:
-    InconsistentEliminationRequested() throw() {}
-    virtual ~InconsistentEliminationRequested() throw() {}
-    virtual const char* what() const throw() {
+    InconsistentEliminationRequested() noexcept {}
+    virtual ~InconsistentEliminationRequested() noexcept {}
+    const char* what() const noexcept override {
       return
         "An inference algorithm was called with inconsistent arguments.  The\n"
         "factor graph, ordering, or variable index were inconsistent with each\n"
--- gtsam-4.0.3.orig/gtsam/linear/BinaryJacobianFactor.h
+++ gtsam-4.0.3/gtsam/linear/BinaryJacobianFactor.h
@@ -49,7 +49,7 @@ struct BinaryJacobianFactor: JacobianFac
 
   // Fixed-size matrix update
   void updateHessian(const KeyVector& infoKeys,
-      SymmetricBlockMatrix* info) const {
+      SymmetricBlockMatrix* info) const override {
     gttic(updateHessian_BinaryJacobianFactor);
     // Whiten the factor if it has a noise model
     const SharedDiagonal& model = get_model();
--- gtsam-4.0.3.orig/gtsam/linear/ConjugateGradientSolver.h
+++ gtsam-4.0.3/gtsam/linear/ConjugateGradientSolver.h
@@ -80,7 +80,7 @@ public:
 
 
   void print() const { Base::print(); }
-  virtual void print(std::ostream &os) const;
+  void print(std::ostream &os) const override;
 
   static std::string blasTranslator(const BLASKernel k) ;
   static BLASKernel blasTranslator(const std::string &s) ;
--- gtsam-4.0.3.orig/gtsam/linear/GaussianBayesTree.h
+++ gtsam-4.0.3/gtsam/linear/GaussianBayesTree.h
@@ -41,6 +41,7 @@ namespace gtsam {
     typedef boost::shared_ptr<This> shared_ptr;
     typedef boost::weak_ptr<This> weak_ptr;
     GaussianBayesTreeClique() {}
+    virtual ~GaussianBayesTreeClique() {}
     GaussianBayesTreeClique(const boost::shared_ptr<GaussianConditional>& conditional) : Base(conditional) {}
   };
 
--- gtsam-4.0.3.orig/gtsam/linear/GaussianConditional.h
+++ gtsam-4.0.3/gtsam/linear/GaussianConditional.h
@@ -88,10 +88,10 @@ namespace gtsam {
 
     /** print */
     void print(const std::string& = "GaussianConditional",
-      const KeyFormatter& formatter = DefaultKeyFormatter) const;
+      const KeyFormatter& formatter = DefaultKeyFormatter) const override;
 
     /** equals function */
-    bool equals(const GaussianFactor&cg, double tol = 1e-9) const;
+    bool equals(const GaussianFactor&cg, double tol = 1e-9) const override;
 
     /** Return a view of the upper-triangular R block of the conditional */
     constABlock R() const { return Ab_.range(0, nrFrontals()); }
@@ -128,17 +128,9 @@ namespace gtsam {
     /** Scale the values in \c gy according to the sigmas for the frontal variables in this
      *  conditional. */
     void scaleFrontalsBySigma(VectorValues& gy) const;
-//    __declspec(deprecated) void scaleFrontalsBySigma(VectorValues& gy) const; // FIXME: depreciated flag doesn't appear to exist?
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-    /// @name Deprecated
-    /// @{
-    constABlock get_R() const { return R(); }
-    constABlock get_S() const { return S(); }
-    constABlock get_S(const_iterator it) const { return S(it); }
-    const constBVector get_d() const { return d(); }
-    /// @}
-#endif
+    // FIXME: deprecated flag doesn't appear to exist?
+    // __declspec(deprecated) void scaleFrontalsBySigma(VectorValues& gy) const; 
 
    private:
     /** Serialization function */
--- gtsam-4.0.3.orig/gtsam/linear/GaussianDensity.h
+++ gtsam-4.0.3/gtsam/linear/GaussianDensity.h
@@ -57,7 +57,7 @@ namespace gtsam {
 
     /// print
     void print(const std::string& = "GaussianDensity",
-      const KeyFormatter& formatter = DefaultKeyFormatter) const;
+      const KeyFormatter& formatter = DefaultKeyFormatter) const override;
 
     /// Mean \f$ \mu = R^{-1} d \f$
     Vector mean() const;
--- gtsam-4.0.3.orig/gtsam/linear/GaussianISAM.h
+++ gtsam-4.0.3/gtsam/linear/GaussianISAM.h
@@ -20,6 +20,7 @@
 
 #include <gtsam/linear/GaussianBayesTree.h>
 #include <gtsam/inference/ISAM.h>
+#include <gtsam/base/Testable.h>
 
 namespace gtsam {
 
@@ -43,4 +44,8 @@ namespace gtsam {
 
   };
 
+  /// traits
+  template <>
+  struct traits<GaussianISAM> : public Testable<GaussianISAM> {};
+
 }
--- gtsam-4.0.3.orig/gtsam/linear/HessianFactor.h
+++ gtsam-4.0.3/gtsam/linear/HessianFactor.h
@@ -354,16 +354,7 @@ namespace gtsam {
       /// Solve the system A'*A delta = A'*b in-place, return delta as VectorValues
     VectorValues solve();
 
-
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-    /// @name Deprecated
-    /// @{
-    const SymmetricBlockMatrix& matrixObject() const { return info_; }
-    /// @}
-#endif
-
-  private:
-
+ private:
     /// Allocate for given scatter pattern
     void Allocate(const Scatter& scatter);
 
--- gtsam-4.0.3.orig/gtsam/linear/JacobianFactor.cpp
+++ gtsam-4.0.3/gtsam/linear/JacobianFactor.cpp
@@ -421,21 +421,11 @@ JacobianFactor::JacobianFactor(const Gau
 /* ************************************************************************* */
 void JacobianFactor::print(const string& s,
     const KeyFormatter& formatter) const {
-  static const Eigen::IOFormat matlab(
-      Eigen::StreamPrecision, // precision
-      0, // flags
-      " ", // coeffSeparator
-      ";\n", // rowSeparator
-      "\t",  // rowPrefix
-      "", // rowSuffix
-      "[\n", // matPrefix
-      "\n  ]" // matSuffix
-      );
   if (!s.empty())
     cout << s << "\n";
   for (const_iterator key = begin(); key != end(); ++key) {
     cout << boost::format("  A[%1%] = ") % formatter(*key);
-    cout << getA(key).format(matlab) << endl;
+    cout << getA(key).format(matlabFormat()) << endl;
   }
   cout << formatMatrixIndented("  b = ", getb(), true) << "\n";
   if (model_)
--- gtsam-4.0.3.orig/gtsam/linear/LossFunctions.h
+++ gtsam-4.0.3/gtsam/linear/LossFunctions.h
@@ -82,10 +82,6 @@ class GTSAM_EXPORT Base {
    */
   virtual double loss(double distance) const { return 0; };
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  virtual double residual(double distance) const { return loss(distance); };
-#endif
-
   /*
    * This method is responsible for returning the weight function for a given
    * amount of error. The weight function is related to the analytic derivative
@@ -134,10 +130,10 @@ class GTSAM_EXPORT Null : public Base {
 
   Null(const ReweightScheme reweight = Block) : Base(reweight) {}
   ~Null() {}
-  double weight(double /*error*/) const { return 1.0; }
-  double loss(double distance) const { return 0.5 * distance * distance; }
-  void print(const std::string &s) const;
-  bool equals(const Base & /*expected*/, double /*tol*/) const { return true; }
+  double weight(double /*error*/) const override { return 1.0; }
+  double loss(double distance) const override { return 0.5 * distance * distance; }
+  void print(const std::string &s) const override;
+  bool equals(const Base & /*expected*/, double /*tol*/) const override { return true; }
   static shared_ptr Create();
 
  private:
@@ -278,14 +274,6 @@ class GTSAM_EXPORT Welsch : public Base
     ar &BOOST_SERIALIZATION_NVP(c_);
   }
 };
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-/// @name Deprecated
-/// @{
-// Welsh implements the "Welsch" robust error model (Zhang97ivc)
-// This was misspelled in previous versions of gtsam and should be
-// removed in the future.
-using Welsh = Welsch;
-#endif
 
 /// GemanMcClure implements the "Geman-McClure" robust error model
 /// (Zhang97ivc).
--- gtsam-4.0.3.orig/gtsam/linear/NoiseModel.cpp
+++ gtsam-4.0.3/gtsam/linear/NoiseModel.cpp
@@ -376,17 +376,6 @@ Vector Constrained::whiten(const Vector&
   return c;
 }
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-/* ************************************************************************* */
-double Constrained::error(const Vector& v) const {
-  Vector w = Diagonal::whiten(v); // get noisemodel for constrained elements
-  for (size_t i=0; i<dim_; ++i)  // add mu weights on constrained variables
-    if (constrained(i)) // whiten makes constrained variables zero
-      w[i] = v[i] * sqrt(mu_[i]); // TODO: may want to store sqrt rather than rebuild
-  return 0.5 * w.dot(w);
-}
-#endif
-
 /* ************************************************************************* */
 double Constrained::squaredMahalanobisDistance(const Vector& v) const {
   Vector w = Diagonal::whiten(v); // get noisemodel for constrained elements
--- gtsam-4.0.3.orig/gtsam/linear/NoiseModel.h
+++ gtsam-4.0.3/gtsam/linear/NoiseModel.h
@@ -103,15 +103,6 @@ namespace gtsam {
         return 0.5 * squared_distance;
       }
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-      /// calculate the error value given measurement error vector
-      virtual double error(const Vector& v) const = 0;
-
-      virtual double distance(const Vector& v) {
-        return error(v) * 2;
-      }      
-#endif
-
       virtual void WhitenSystem(std::vector<Matrix>& A, Vector& b) const = 0;
       virtual void WhitenSystem(Matrix& A, Vector& b) const = 0;
       virtual void WhitenSystem(Matrix& A1, Matrix& A2, Vector& b) const = 0;
@@ -226,19 +217,6 @@ namespace gtsam {
       Vector whiten(const Vector& v) const override;
       Vector unwhiten(const Vector& v) const override;
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-      virtual double Mahalanobis(const Vector& v) const {
-        return squaredMahalanobisDistance(v);
-      }
-
-      /**
-       * error value 0.5 * v'*R'*R*v
-       */
-      inline double error(const Vector& v) const override {
-        return 0.5 * squaredMahalanobisDistance(v);
-      }
-#endif
-
       /**
        * Multiply a derivative with R (derivative of whiten)
        * Equivalent to whitening each column of the input matrix.
@@ -483,15 +461,6 @@ namespace gtsam {
         return MixedVariances(precisions.array().inverse());
       }
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-      /**
-       * The error function for a constrained noisemodel,
-       * for non-constrained versions, uses sigmas, otherwise
-       * uses the penalty function with mu
-       */
-      double error(const Vector& v) const override;
-#endif
-
       double squaredMahalanobisDistance(const Vector& v) const override;
 
       /** Fully constrained variations */
@@ -720,14 +689,6 @@ namespace gtsam {
       { Vector b; Matrix B=A; this->WhitenSystem(B,b); return B; }
       inline Vector unwhiten(const Vector& /*v*/) const override
       { throw std::invalid_argument("unwhiten is not currently supported for robust noise models."); }
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-      inline double distance(const Vector& v) override {
-        return robust_->loss(this->unweightedWhiten(v).norm());
-      }
-      // Fold the use of the m-estimator loss(...) function into error(...)
-      inline double error(const Vector& v) const override
-      { return robust_->loss(noise_->mahalanobisDistance(v)); }
-#endif
 
       double loss(const double squared_distance) const override {
         return robust_->loss(std::sqrt(squared_distance));
--- gtsam-4.0.3.orig/gtsam/linear/PCGSolver.h
+++ gtsam-4.0.3/gtsam/linear/PCGSolver.h
@@ -41,7 +41,7 @@ public:
   PCGSolverParameters() {
   }
 
-  virtual void print(std::ostream &os) const;
+  void print(std::ostream &os) const override;
 
   /* interface to preconditioner parameters */
   inline const PreconditionerParameters& preconditioner() const {
@@ -77,9 +77,9 @@ public:
 
   using IterativeSolver::optimize;
 
-  virtual VectorValues optimize(const GaussianFactorGraph &gfg,
+  VectorValues optimize(const GaussianFactorGraph &gfg,
       const KeyInfo &keyInfo, const std::map<Key, Vector> &lambda,
-      const VectorValues &initial);
+      const VectorValues &initial) override;
 
 };
 
--- gtsam-4.0.3.orig/gtsam/linear/Preconditioner.cpp
+++ gtsam-4.0.3/gtsam/linear/Preconditioner.cpp
@@ -145,7 +145,7 @@ void BlockJacobiPreconditioner::build(
 
   /* getting the block diagonals over the factors */
   std::map<Key, Matrix> hessianMap =gfg.hessianBlockDiagonal();
-  for ( const Matrix hessian: hessianMap | boost::adaptors::map_values)
+  for (const Matrix& hessian: hessianMap | boost::adaptors::map_values)
     blocks.push_back(hessian);
 
   /* if necessary, allocating the memory for cacheing the factorization results */
--- gtsam-4.0.3.orig/gtsam/linear/Preconditioner.h
+++ gtsam-4.0.3/gtsam/linear/Preconditioner.h
@@ -111,13 +111,13 @@ public:
   virtual ~DummyPreconditioner() {}
 
   /* Computation Interfaces for raw vector */
-  virtual void solve(const Vector& y, Vector &x) const { x = y; }
-  virtual void transposeSolve(const Vector& y, Vector& x) const { x = y; }
-  virtual void build(
+  void solve(const Vector& y, Vector &x) const override { x = y; }
+  void transposeSolve(const Vector& y, Vector& x) const  override { x = y; }
+  void build(
     const GaussianFactorGraph &gfg,
     const KeyInfo &info,
     const std::map<Key,Vector> &lambda
-    )  {}
+    ) override {}
 };
 
 /*******************************************************************************************/
@@ -135,13 +135,13 @@ public:
   virtual ~BlockJacobiPreconditioner() ;
 
   /* Computation Interfaces for raw vector */
-  virtual void solve(const Vector& y, Vector &x) const;
-  virtual void transposeSolve(const Vector& y, Vector& x) const ;
-  virtual void build(
+  void solve(const Vector& y, Vector &x) const override;
+  void transposeSolve(const Vector& y, Vector& x) const override;
+  void build(
     const GaussianFactorGraph &gfg,
     const KeyInfo &info,
     const std::map<Key,Vector> &lambda
-    ) ;
+    ) override;
 
 protected:
 
--- gtsam-4.0.3.orig/gtsam/linear/RegularHessianFactor.h
+++ gtsam-4.0.3/gtsam/linear/RegularHessianFactor.h
@@ -109,8 +109,8 @@ private:
 public:
 
   /** y += alpha * A'*A*x */
-  virtual void multiplyHessianAdd(double alpha, const VectorValues& x,
-      VectorValues& y) const {
+  void multiplyHessianAdd(double alpha, const VectorValues& x,
+      VectorValues& y) const override {
     HessianFactor::multiplyHessianAdd(alpha, x, y);
   }
 
@@ -182,7 +182,7 @@ public:
   }
 
   /** Return the diagonal of the Hessian for this factor (raw memory version) */
-  virtual void hessianDiagonal(double* d) const {
+  void hessianDiagonal(double* d) const override {
 
     // Loop over all variables in the factor
     for (DenseIndex pos = 0; pos < (DenseIndex) size(); ++pos) {
@@ -193,7 +193,7 @@ public:
   }
 
   /// Add gradient at zero to d TODO: is it really the goal to add ??
-  virtual void gradientAtZero(double* d) const {
+  void gradientAtZero(double* d) const override {
 
     // Loop over all variables in the factor
     for (DenseIndex pos = 0; pos < (DenseIndex) size(); ++pos) {
--- gtsam-4.0.3.orig/gtsam/linear/RegularJacobianFactor.h
+++ gtsam-4.0.3/gtsam/linear/RegularJacobianFactor.h
@@ -70,8 +70,8 @@ public:
   using JacobianFactor::multiplyHessianAdd;
 
   /** y += alpha * A'*A*x */
-  virtual void multiplyHessianAdd(double alpha, const VectorValues& x,
-      VectorValues& y) const {
+  void multiplyHessianAdd(double alpha, const VectorValues& x,
+      VectorValues& y) const override {
     JacobianFactor::multiplyHessianAdd(alpha, x, y);
   }
 
@@ -106,7 +106,7 @@ public:
   using GaussianFactor::hessianDiagonal;
 
   /// Raw memory access version of hessianDiagonal
-  void hessianDiagonal(double* d) const {
+  void hessianDiagonal(double* d) const override {
     // Loop over all variables in the factor
     for (DenseIndex j = 0; j < (DenseIndex) size(); ++j) {
       // Get the diagonal block, and insert its diagonal
@@ -125,12 +125,12 @@ public:
   }
 
   /// Expose base class gradientAtZero
-  virtual VectorValues gradientAtZero() const {
+  VectorValues gradientAtZero() const override {
     return JacobianFactor::gradientAtZero();
   }
 
   /// Raw memory access version of gradientAtZero
-  void gradientAtZero(double* d) const {
+  void gradientAtZero(double* d) const override {
 
     // Get vector b not weighted
     Vector b = getb();
--- gtsam-4.0.3.orig/gtsam/linear/Sampler.cpp
+++ gtsam-4.0.3/gtsam/linear/Sampler.cpp
@@ -55,16 +55,5 @@ Vector Sampler::sample() const {
 }
 
 /* ************************************************************************* */
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-Sampler::Sampler(uint_fast64_t seed) : generator_(seed) {}
-
-Vector Sampler::sampleNewModel(
-    const noiseModel::Diagonal::shared_ptr& model) const {
-  assert(model.get());
-  const Vector& sigmas = model->sigmas();
-  return sampleDiagonal(sigmas);
-}
-#endif
-/* ************************************************************************* */
 
 }  // namespace gtsam
--- gtsam-4.0.3.orig/gtsam/linear/Sampler.h
+++ gtsam-4.0.3/gtsam/linear/Sampler.h
@@ -84,14 +84,6 @@ class GTSAM_EXPORT Sampler {
 
   /// @}
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  explicit Sampler(uint_fast64_t seed = 42u);
-  Vector sampleNewModel(const noiseModel::Diagonal::shared_ptr& model) const;
-  /// @}
-#endif
-
  protected:
   /** given sigmas for a diagonal model, returns a sample */
   Vector sampleDiagonal(const Vector& sigmas) const;
--- gtsam-4.0.3.orig/gtsam/linear/SubgraphSolver.cpp
+++ gtsam-4.0.3/gtsam/linear/SubgraphSolver.cpp
@@ -66,23 +66,6 @@ SubgraphSolver::SubgraphSolver(const Gau
                      parameters) {}
 
 /**************************************************************************************************/
-// deprecated variants
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-SubgraphSolver::SubgraphSolver(const GaussianBayesNet::shared_ptr &Rc1,
-                               const GaussianFactorGraph &Ab2,
-                               const Parameters &parameters)
-    : SubgraphSolver(Rc1, boost::make_shared<GaussianFactorGraph>(Ab2),
-                     parameters) {}
-
-SubgraphSolver::SubgraphSolver(const GaussianFactorGraph &Ab1,
-                               const GaussianFactorGraph &Ab2,
-                               const Parameters &parameters,
-                               const Ordering &ordering)
-    : SubgraphSolver(Ab1, boost::make_shared<GaussianFactorGraph>(Ab2),
-                     parameters, ordering) {}
-#endif
-
-/**************************************************************************************************/
 VectorValues SubgraphSolver::optimize() const {
   VectorValues ybar = conjugateGradients<SubgraphPreconditioner, VectorValues,
       Errors>(*pc_, pc_->zero(), parameters_);
--- gtsam-4.0.3.orig/gtsam/linear/SubgraphSolver.h
+++ gtsam-4.0.3/gtsam/linear/SubgraphSolver.h
@@ -38,7 +38,7 @@ struct GTSAM_EXPORT SubgraphSolverParame
   explicit SubgraphSolverParameters(const SubgraphBuilderParameters &p = SubgraphBuilderParameters())
     : builderParams(p) {}
   void print() const { Base::print(); }
-  virtual void print(std::ostream &os) const {
+  void print(std::ostream &os) const override {
     Base::print(os);
   }
 };
@@ -136,23 +136,6 @@ class GTSAM_EXPORT SubgraphSolver : publ
           const GaussianFactorGraph &gfg);
 
   /// @}
-
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  SubgraphSolver(const boost::shared_ptr<GaussianFactorGraph> &A,
-                 const Parameters &parameters, const Ordering &ordering)
-      : SubgraphSolver(*A, parameters, ordering) {}
-  SubgraphSolver(const GaussianFactorGraph &, const GaussianFactorGraph &,
-                 const Parameters &, const Ordering &);
-  SubgraphSolver(const boost::shared_ptr<GaussianFactorGraph> &Ab1,
-                 const boost::shared_ptr<GaussianFactorGraph> &Ab2,
-                 const Parameters &parameters, const Ordering &ordering)
-      : SubgraphSolver(*Ab1, Ab2, parameters, ordering) {}
-  SubgraphSolver(const boost::shared_ptr<GaussianBayesNet> &,
-                 const GaussianFactorGraph &, const Parameters &);
-  /// @}
-#endif
 };
 
 }  // namespace gtsam
--- gtsam-4.0.3.orig/gtsam/linear/VectorValues.cpp
+++ gtsam-4.0.3/gtsam/linear/VectorValues.cpp
@@ -45,7 +45,7 @@ namespace gtsam {
 
   /* ************************************************************************* */
   VectorValues::VectorValues(const Vector& x, const Dims& dims) {
-    typedef pair<Key, size_t> Pair;
+    using Pair = pair<const Key, size_t>;
     size_t j = 0;
     for (const Pair& v : dims) {
       Key key;
--- gtsam-4.0.3.orig/gtsam/linear/linearExceptions.cpp
+++ gtsam-4.0.3/gtsam/linear/linearExceptions.cpp
@@ -24,7 +24,7 @@
 namespace gtsam {
 
   /* ************************************************************************* */
-  const char* IndeterminantLinearSystemException::what() const throw()
+  const char* IndeterminantLinearSystemException::what() const noexcept
   {
     if(!description_) {
       description_ = String(
@@ -43,7 +43,7 @@ more information.");
   }
 
   /* ************************************************************************* */
-  const char* InvalidNoiseModel::what() const throw() {
+  const char* InvalidNoiseModel::what() const noexcept {
     if(description_.empty())
       description_ = (boost::format(
       "A JacobianFactor was attempted to be constructed or modified to use a\n"
@@ -54,7 +54,7 @@ more information.");
   }
 
   /* ************************************************************************* */
-  const char* InvalidMatrixBlock::what() const throw() {
+  const char* InvalidMatrixBlock::what() const noexcept {
     if(description_.empty())
       description_ = (boost::format(
       "A JacobianFactor was attempted to be constructed with a matrix block of\n"
--- gtsam-4.0.3.orig/gtsam/linear/linearExceptions.h
+++ gtsam-4.0.3/gtsam/linear/linearExceptions.h
@@ -94,10 +94,10 @@ namespace gtsam {
   class GTSAM_EXPORT IndeterminantLinearSystemException : public ThreadsafeException<IndeterminantLinearSystemException> {
     Key j_;
   public:
-    IndeterminantLinearSystemException(Key j) throw() : j_(j) {}
-    virtual ~IndeterminantLinearSystemException() throw() {}
+    IndeterminantLinearSystemException(Key j) noexcept : j_(j) {}
+    virtual ~IndeterminantLinearSystemException() noexcept {}
     Key nearbyVariable() const { return j_; }
-    virtual const char* what() const throw();
+    const char* what() const noexcept override;
   };
 
   /* ************************************************************************* */
@@ -110,9 +110,9 @@ namespace gtsam {
 
     InvalidNoiseModel(DenseIndex factorDims, DenseIndex noiseModelDims) :
       factorDims(factorDims), noiseModelDims(noiseModelDims) {}
-    virtual ~InvalidNoiseModel() throw() {}
+    virtual ~InvalidNoiseModel() noexcept {}
 
-    virtual const char* what() const throw();
+    const char* what() const noexcept override;
 
   private:
     mutable std::string description_;
@@ -128,9 +128,9 @@ namespace gtsam {
 
     InvalidMatrixBlock(DenseIndex factorRows, DenseIndex blockRows) :
       factorRows(factorRows), blockRows(blockRows) {}
-    virtual ~InvalidMatrixBlock() throw() {}
+    virtual ~InvalidMatrixBlock() noexcept {}
 
-    virtual const char* what() const throw();
+    const char* what() const noexcept override;
 
   private:
     mutable std::string description_;
--- gtsam-4.0.3.orig/gtsam/linear/tests/testGaussianBayesNet.cpp
+++ gtsam-4.0.3/gtsam/linear/tests/testGaussianBayesNet.cpp
@@ -137,7 +137,7 @@ TEST( GaussianBayesNet, optimize3 )
 }
 
 /* ************************************************************************* */
-TEST(GaussianBayesNet, ordering) 
+TEST(GaussianBayesNet, ordering)
 {
   Ordering expected;
   expected += _x_, _y_;
@@ -155,7 +155,7 @@ TEST( GaussianBayesNet, MatrixStress )
   bn.emplace_shared<GC>(_z_, Vector2(5, 6), 6 * I_2x2);
 
   const VectorValues expected = bn.optimize();
-  for (const auto keys :
+  for (const auto& keys :
        {KeyVector({_x_, _y_, _z_}), KeyVector({_x_, _z_, _y_}),
         KeyVector({_y_, _x_, _z_}), KeyVector({_y_, _z_, _x_}),
         KeyVector({_z_, _x_, _y_}), KeyVector({_z_, _y_, _x_})}) {
@@ -183,7 +183,7 @@ TEST( GaussianBayesNet, backSubstituteTr
 
   VectorValues actual = smallBayesNet.backSubstituteTranspose(x);
   EXPECT(assert_equal(expected, actual));
-  
+
   const auto ordering = noisyBayesNet.ordering();
   const Matrix R = smallBayesNet.matrix(ordering).first;
   const Vector expected_vector = R.transpose().inverse() * x.vector(ordering);
@@ -206,7 +206,7 @@ TEST( GaussianBayesNet, backSubstituteTr
 
   VectorValues actual = noisyBayesNet.backSubstituteTranspose(x);
   EXPECT(assert_equal(expected, actual));
-  
+
   const auto ordering = noisyBayesNet.ordering();
   const Matrix R = noisyBayesNet.matrix(ordering).first;
   const Vector expected_vector = R.transpose().inverse() * x.vector(ordering);
--- gtsam-4.0.3.orig/gtsam/navigation/AHRSFactor.h
+++ gtsam-4.0.3/gtsam/navigation/AHRSFactor.h
@@ -75,7 +75,7 @@ class GTSAM_EXPORT PreintegratedAhrsMeas
       biasHat_(bias_hat),
       preintMeasCov_(preint_meas_cov) {}
 
-  const Params& p() const { return *boost::static_pointer_cast<const Params>(p_);}
+  Params& p() const { return *boost::static_pointer_cast<Params>(p_);}
   const Vector3& biasHat() const { return biasHat_; }
   const Matrix3& preintMeasCov() const { return preintMeasCov_; }
 
@@ -158,14 +158,14 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const;
+  gtsam::NonlinearFactor::shared_ptr clone() const override;
 
   /// print
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const;
+  void print(const std::string& s, const KeyFormatter& keyFormatter =
+      DefaultKeyFormatter) const override;
 
   /// equals
-  virtual bool equals(const NonlinearFactor&, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor&, double tol = 1e-9) const override;
 
   /// Access the preintegrated measurements.
   const PreintegratedAhrsMeasurements& preintegratedMeasurements() const {
@@ -178,7 +178,7 @@ public:
   Vector evaluateError(const Rot3& rot_i, const Rot3& rot_j,
       const Vector3& bias, boost::optional<Matrix&> H1 = boost::none,
       boost::optional<Matrix&> H2 = boost::none, boost::optional<Matrix&> H3 =
-          boost::none) const;
+          boost::none) const override;
 
   /// predicted states from IMU
   /// TODO(frank): relationship with PIM predict ??
--- gtsam-4.0.3.orig/gtsam/navigation/AttitudeFactor.h
+++ gtsam-4.0.3/gtsam/navigation/AttitudeFactor.h
@@ -108,21 +108,21 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   /** print */
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const;
+  void print(const std::string& s, const KeyFormatter& keyFormatter =
+      DefaultKeyFormatter) const override;
 
   /** equals */
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
 
   /** vector of errors */
-  virtual Vector evaluateError(const Rot3& nRb, //
-      boost::optional<Matrix&> H = boost::none) const {
+  Vector evaluateError(const Rot3& nRb, //
+      boost::optional<Matrix&> H = boost::none) const override {
     return attitudeError(nRb, H);
   }
 
@@ -182,21 +182,21 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   /** print */
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const;
+  void print(const std::string& s, const KeyFormatter& keyFormatter =
+      DefaultKeyFormatter) const override;
 
   /** equals */
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
 
   /** vector of errors */
-  virtual Vector evaluateError(const Pose3& nTb, //
-      boost::optional<Matrix&> H = boost::none) const {
+  Vector evaluateError(const Pose3& nTb, //
+      boost::optional<Matrix&> H = boost::none) const override {
     Vector e = attitudeError(nTb.rotation(), H);
     if (H) {
       Matrix H23 = *H;
--- gtsam-4.0.3.orig/gtsam/navigation/CombinedImuFactor.cpp
+++ gtsam-4.0.3/gtsam/navigation/CombinedImuFactor.cpp
@@ -149,29 +149,6 @@ void PreintegratedCombinedMeasurements::
 }
 
 //------------------------------------------------------------------------------
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-PreintegratedCombinedMeasurements::PreintegratedCombinedMeasurements(
-    const imuBias::ConstantBias& biasHat, const Matrix3& measuredAccCovariance,
-    const Matrix3& measuredOmegaCovariance,
-    const Matrix3& integrationErrorCovariance, const Matrix3& biasAccCovariance,
-    const Matrix3& biasOmegaCovariance, const Matrix6& biasAccOmegaInt,
-    const bool use2ndOrderIntegration) {
-  if (!use2ndOrderIntegration)
-  throw("PreintegratedImuMeasurements no longer supports first-order integration: it incorrectly compensated for gravity");
-  biasHat_ = biasHat;
-  boost::shared_ptr<Params> p = Params::MakeSharedD();
-  p->gyroscopeCovariance = measuredOmegaCovariance;
-  p->accelerometerCovariance = measuredAccCovariance;
-  p->integrationCovariance = integrationErrorCovariance;
-  p->biasAccCovariance = biasAccCovariance;
-  p->biasOmegaCovariance = biasOmegaCovariance;
-  p->biasAccOmegaInt = biasAccOmegaInt;
-  p_ = p;
-  resetIntegration();
-  preintMeasCov_.setZero();
-}
-#endif
-//------------------------------------------------------------------------------
 // CombinedImuFactor methods
 //------------------------------------------------------------------------------
 CombinedImuFactor::CombinedImuFactor(Key pose_i, Key vel_i, Key pose_j,
@@ -275,41 +252,6 @@ std::ostream& operator<<(std::ostream& o
   os << "  noise model sigmas: " << f.noiseModel_->sigmas().transpose();
   return os;
 }
-
-//------------------------------------------------------------------------------
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-CombinedImuFactor::CombinedImuFactor(
-    Key pose_i, Key vel_i, Key pose_j, Key vel_j, Key bias_i, Key bias_j,
-    const CombinedPreintegratedMeasurements& pim, const Vector3& n_gravity,
-    const Vector3& omegaCoriolis, const boost::optional<Pose3>& body_P_sensor,
-    const bool use2ndOrderCoriolis)
-: Base(noiseModel::Gaussian::Covariance(pim.preintMeasCov_), pose_i, vel_i,
-    pose_j, vel_j, bias_i, bias_j),
-_PIM_(pim) {
-  using P = CombinedPreintegratedMeasurements::Params;
-  auto p = boost::allocate_shared<P>(Eigen::aligned_allocator<P>(), pim.p());
-  p->n_gravity = n_gravity;
-  p->omegaCoriolis = omegaCoriolis;
-  p->body_P_sensor = body_P_sensor;
-  p->use2ndOrderCoriolis = use2ndOrderCoriolis;
-  _PIM_.p_ = p;
-}
-
-void CombinedImuFactor::Predict(const Pose3& pose_i, const Vector3& vel_i,
-    Pose3& pose_j, Vector3& vel_j,
-    const imuBias::ConstantBias& bias_i,
-    CombinedPreintegratedMeasurements& pim,
-    const Vector3& n_gravity,
-    const Vector3& omegaCoriolis,
-    const bool use2ndOrderCoriolis) {
-  // use deprecated predict
-  PoseVelocityBias pvb = pim.predict(pose_i, vel_i, bias_i, n_gravity,
-      omegaCoriolis, use2ndOrderCoriolis);
-  pose_j = pvb.pose;
-  vel_j = pvb.velocity;
-}
-#endif
-
 }
  /// namespace gtsam
 
--- gtsam-4.0.3.orig/gtsam/navigation/CombinedImuFactor.h
+++ gtsam-4.0.3/gtsam/navigation/CombinedImuFactor.h
@@ -87,8 +87,8 @@ struct GTSAM_EXPORT PreintegrationCombin
     return boost::shared_ptr<PreintegrationCombinedParams>(new PreintegrationCombinedParams(Vector3(0, 0, -g)));
   }
 
-  void print(const std::string& s="") const;
-  bool equals(const PreintegratedRotationParams& other, double tol) const;
+  void print(const std::string& s="") const override;
+  bool equals(const PreintegratedRotationParams& other, double tol) const override;
 
   void setBiasAccCovariance(const Matrix3& cov) { biasAccCovariance=cov; }
   void setBiasOmegaCovariance(const Matrix3& cov) { biasOmegaCovariance=cov; }
@@ -220,17 +220,6 @@ public:
 
   /// @}
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// deprecated constructor
-  /// NOTE(frank): assumes Z-Down convention, only second order integration supported
-  PreintegratedCombinedMeasurements(const imuBias::ConstantBias& biasHat,
-      const Matrix3& measuredAccCovariance,
-      const Matrix3& measuredOmegaCovariance,
-      const Matrix3& integrationErrorCovariance,
-      const Matrix3& biasAccCovariance, const Matrix3& biasOmegaCovariance,
-      const Matrix6& biasAccOmegaInt, const bool use2ndOrderIntegration = true);
-#endif
-
  private:
   /// Serialization function
   friend class boost::serialization::access;
@@ -305,7 +294,7 @@ public:
   virtual ~CombinedImuFactor() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const;
+  gtsam::NonlinearFactor::shared_ptr clone() const override;
 
   /** implement functions needed for Testable */
 
@@ -314,11 +303,11 @@ public:
   GTSAM_EXPORT friend std::ostream& operator<<(std::ostream& os,
                                                const CombinedImuFactor&);
   /// print
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const;
+  void print(const std::string& s, const KeyFormatter& keyFormatter =
+      DefaultKeyFormatter) const override;
 
   /// equals
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
   /// @}
 
   /** Access the preintegrated measurements. */
@@ -336,28 +325,9 @@ public:
       boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 =
           boost::none, boost::optional<Matrix&> H3 = boost::none,
       boost::optional<Matrix&> H4 = boost::none, boost::optional<Matrix&> H5 =
-          boost::none, boost::optional<Matrix&> H6 = boost::none) const;
-
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @deprecated typename
-  typedef gtsam::PreintegratedCombinedMeasurements CombinedPreintegratedMeasurements;
-
-  /// @deprecated constructor
-  CombinedImuFactor(Key pose_i, Key vel_i, Key pose_j, Key vel_j, Key bias_i,
-                    Key bias_j, const CombinedPreintegratedMeasurements& pim,
-                    const Vector3& n_gravity, const Vector3& omegaCoriolis,
-                    const boost::optional<Pose3>& body_P_sensor = boost::none,
-                    const bool use2ndOrderCoriolis = false);
-
-  // @deprecated use PreintegrationBase::predict
-  static void Predict(const Pose3& pose_i, const Vector3& vel_i, Pose3& pose_j,
-                      Vector3& vel_j, const imuBias::ConstantBias& bias_i,
-                      CombinedPreintegratedMeasurements& pim,
-                      const Vector3& n_gravity, const Vector3& omegaCoriolis,
-                      const bool use2ndOrderCoriolis = false);
-#endif
+          boost::none, boost::optional<Matrix&> H6 = boost::none) const override;
 
-private:
+ private:
   /** Serialization function */
   friend class boost::serialization::access;
   template <class ARCHIVE>
--- gtsam-4.0.3.orig/gtsam/navigation/GPSFactor.h
+++ gtsam-4.0.3/gtsam/navigation/GPSFactor.h
@@ -65,21 +65,21 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   /// print
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const;
+  void print(const std::string& s, const KeyFormatter& keyFormatter =
+      DefaultKeyFormatter) const override;
 
   /// equals
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
 
   /// vector of errors
   Vector evaluateError(const Pose3& p,
-      boost::optional<Matrix&> H = boost::none) const;
+      boost::optional<Matrix&> H = boost::none) const override;
 
   inline const Point3 & measurementIn() const {
     return nT_;
@@ -137,21 +137,21 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   /// print
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const;
+  void print(const std::string& s, const KeyFormatter& keyFormatter =
+      DefaultKeyFormatter) const override;
 
   /// equals
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
 
   /// vector of errors
   Vector evaluateError(const NavState& p,
-      boost::optional<Matrix&> H = boost::none) const;
+      boost::optional<Matrix&> H = boost::none) const override;
 
   inline const Point3 & measurementIn() const {
     return nT_;
--- gtsam-4.0.3.orig/gtsam/navigation/ImuFactor.cpp
+++ gtsam-4.0.3/gtsam/navigation/ImuFactor.cpp
@@ -107,32 +107,6 @@ void PreintegratedImuMeasurements::merge
 }
 #endif
 //------------------------------------------------------------------------------
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-PreintegratedImuMeasurements::PreintegratedImuMeasurements(
-    const imuBias::ConstantBias& biasHat, const Matrix3& measuredAccCovariance,
-    const Matrix3& measuredOmegaCovariance,
-    const Matrix3& integrationErrorCovariance, bool use2ndOrderIntegration) {
-  if (!use2ndOrderIntegration)
-  throw("PreintegratedImuMeasurements no longer supports first-order integration: it incorrectly compensated for gravity");
-  biasHat_ = biasHat;
-  boost::shared_ptr<Params> p = Params::MakeSharedD();
-  p->gyroscopeCovariance = measuredOmegaCovariance;
-  p->accelerometerCovariance = measuredAccCovariance;
-  p->integrationCovariance = integrationErrorCovariance;
-  p_ = p;
-  resetIntegration();
-}
-
-void PreintegratedImuMeasurements::integrateMeasurement(
-    const Vector3& measuredAcc, const Vector3& measuredOmega, double deltaT,
-    boost::optional<Pose3> body_P_sensor) {
-  // modify parameters to accommodate deprecated method:-(
-  p_->body_P_sensor = body_P_sensor;
-  integrateMeasurement(measuredAcc, measuredOmega, deltaT);
-}
-#endif
-
-//------------------------------------------------------------------------------
 // ImuFactor methods
 //------------------------------------------------------------------------------
 ImuFactor::ImuFactor(Key pose_i, Key vel_i, Key pose_j, Key vel_j, Key bias,
@@ -218,44 +192,16 @@ ImuFactor::shared_ptr ImuFactor::Merge(c
   // return new factor
   auto pim02 =
   Merge(f01->preintegratedMeasurements(), f12->preintegratedMeasurements());
-  return boost::make_shared<ImuFactor>(f01->key1(),// P0
-      f01->key2(),// V0
-      f12->key3(),// P2
-      f12->key4(),// V2
-      f01->key5(),// B
+  return boost::make_shared<ImuFactor>(f01->key1(),  // P0
+      f01->key2(),  // V0
+      f12->key3(),  // P2
+      f12->key4(),  // V2
+      f01->key5(),  // B
       pim02);
 }
 #endif
 
 //------------------------------------------------------------------------------
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-ImuFactor::ImuFactor(Key pose_i, Key vel_i, Key pose_j, Key vel_j, Key bias,
-    const PreintegratedImuMeasurements& pim, const Vector3& n_gravity,
-    const Vector3& omegaCoriolis, const boost::optional<Pose3>& body_P_sensor,
-    const bool use2ndOrderCoriolis) :
-Base(noiseModel::Gaussian::Covariance(pim.preintMeasCov_), pose_i, vel_i,
-    pose_j, vel_j, bias), _PIM_(pim) {
-  boost::shared_ptr<PreintegrationParams> p = boost::make_shared<
-  PreintegrationParams>(pim.p());
-  p->n_gravity = n_gravity;
-  p->omegaCoriolis = omegaCoriolis;
-  p->body_P_sensor = body_P_sensor;
-  p->use2ndOrderCoriolis = use2ndOrderCoriolis;
-  _PIM_.p_ = p;
-}
-
-void ImuFactor::Predict(const Pose3& pose_i, const Vector3& vel_i,
-    Pose3& pose_j, Vector3& vel_j, const imuBias::ConstantBias& bias_i,
-    PreintegratedImuMeasurements& pim, const Vector3& n_gravity,
-    const Vector3& omegaCoriolis, const bool use2ndOrderCoriolis) {
-  // use deprecated predict
-  PoseVelocityBias pvb = pim.predict(pose_i, vel_i, bias_i, n_gravity,
-      omegaCoriolis, use2ndOrderCoriolis);
-  pose_j = pvb.pose;
-  vel_j = pvb.velocity;
-}
-#endif
-//------------------------------------------------------------------------------
 // ImuFactor2 methods
 //------------------------------------------------------------------------------
 ImuFactor2::ImuFactor2(Key state_i, Key state_j, Key bias,
--- gtsam-4.0.3.orig/gtsam/navigation/ImuFactor.h
+++ gtsam-4.0.3/gtsam/navigation/ImuFactor.h
@@ -140,24 +140,7 @@ public:
   void mergeWith(const PreintegratedImuMeasurements& pim, Matrix9* H1, Matrix9* H2);
 #endif
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @deprecated constructor
-  /// NOTE(frank): assumes Z-Down convention, only second order integration supported
-  PreintegratedImuMeasurements(const imuBias::ConstantBias& biasHat,
-      const Matrix3& measuredAccCovariance,
-      const Matrix3& measuredOmegaCovariance,
-      const Matrix3& integrationErrorCovariance,
-      bool use2ndOrderIntegration = true);
-
-  /// @deprecated version of integrateMeasurement with body_P_sensor
-  /// Use parameters instead
-  void integrateMeasurement(const Vector3& measuredAcc,
-      const Vector3& measuredOmega, double dt,
-      boost::optional<Pose3> body_P_sensor);
-#endif
-
-private:
-
+ private:
   /// Serialization function
   friend class boost::serialization::access;
   template<class ARCHIVE>
@@ -217,14 +200,14 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const;
+  gtsam::NonlinearFactor::shared_ptr clone() const override;
 
   /// @name Testable
   /// @{
   GTSAM_EXPORT friend std::ostream& operator<<(std::ostream& os, const ImuFactor&);
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const;
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  void print(const std::string& s, const KeyFormatter& keyFormatter =
+      DefaultKeyFormatter) const override;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
   /// @}
 
   /** Access the preintegrated measurements. */
@@ -241,7 +224,7 @@ public:
       const imuBias::ConstantBias& bias_i, boost::optional<Matrix&> H1 =
           boost::none, boost::optional<Matrix&> H2 = boost::none,
       boost::optional<Matrix&> H3 = boost::none, boost::optional<Matrix&> H4 =
-          boost::none, boost::optional<Matrix&> H5 = boost::none) const;
+          boost::none, boost::optional<Matrix&> H5 = boost::none) const override;
 
 #ifdef GTSAM_TANGENT_PREINTEGRATION
   /// Merge two pre-integrated measurement classes
@@ -253,27 +236,7 @@ public:
   static shared_ptr Merge(const shared_ptr& f01, const shared_ptr& f12);
 #endif
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @deprecated typename
-  typedef PreintegratedImuMeasurements PreintegratedMeasurements;
-
-  /// @deprecated constructor, in the new one gravity, coriolis settings are in PreintegrationParams
-  ImuFactor(Key pose_i, Key vel_i, Key pose_j, Key vel_j, Key bias,
-      const PreintegratedMeasurements& preintegratedMeasurements,
-      const Vector3& n_gravity, const Vector3& omegaCoriolis,
-      const boost::optional<Pose3>& body_P_sensor = boost::none,
-      const bool use2ndOrderCoriolis = false);
-
-  /// @deprecated use PreintegrationBase::predict,
-  /// in the new one gravity, coriolis settings are in PreintegrationParams
-  static void Predict(const Pose3& pose_i, const Vector3& vel_i, Pose3& pose_j,
-      Vector3& vel_j, const imuBias::ConstantBias& bias_i,
-      PreintegratedMeasurements& pim, const Vector3& n_gravity,
-      const Vector3& omegaCoriolis, const bool use2ndOrderCoriolis = false);
-#endif
-
-private:
-
+ private:
   /** Serialization function */
   friend class boost::serialization::access;
   template<class ARCHIVE>
@@ -315,14 +278,14 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const;
+  gtsam::NonlinearFactor::shared_ptr clone() const override;
 
   /// @name Testable
   /// @{
   GTSAM_EXPORT friend std::ostream& operator<<(std::ostream& os, const ImuFactor2&);
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const;
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  void print(const std::string& s, const KeyFormatter& keyFormatter =
+      DefaultKeyFormatter) const override;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
   /// @}
 
   /** Access the preintegrated measurements. */
@@ -338,7 +301,7 @@ public:
                        const imuBias::ConstantBias& bias_i,  //
                        boost::optional<Matrix&> H1 = boost::none,
                        boost::optional<Matrix&> H2 = boost::none,
-                       boost::optional<Matrix&> H3 = boost::none) const;
+                       boost::optional<Matrix&> H3 = boost::none) const override;
 
 private:
 
--- gtsam-4.0.3.orig/gtsam/navigation/MagFactor.h
+++ gtsam-4.0.3/gtsam/navigation/MagFactor.h
@@ -53,7 +53,7 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual NonlinearFactor::shared_ptr clone() const {
+  NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<NonlinearFactor>(
         NonlinearFactor::shared_ptr(new MagFactor(*this)));
   }
@@ -73,7 +73,7 @@ public:
    * @brief vector of errors
    */
   Vector evaluateError(const Rot2& nRb,
-      boost::optional<Matrix&> H = boost::none) const {
+      boost::optional<Matrix&> H = boost::none) const override {
     // measured bM = nRb * nM + b
     Point3 hx = unrotate(nRb, nM_, H) + bias_;
     return (hx - measured_);
@@ -102,7 +102,7 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual NonlinearFactor::shared_ptr clone() const {
+  NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<NonlinearFactor>(
         NonlinearFactor::shared_ptr(new MagFactor1(*this)));
   }
@@ -111,7 +111,7 @@ public:
    * @brief vector of errors
    */
   Vector evaluateError(const Rot3& nRb,
-      boost::optional<Matrix&> H = boost::none) const {
+      boost::optional<Matrix&> H = boost::none) const override {
     // measured bM = nRb * nM + b
     Point3 hx = nRb.unrotate(nM_, H, boost::none) + bias_;
     return (hx - measured_);
@@ -138,7 +138,7 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual NonlinearFactor::shared_ptr clone() const {
+  NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<NonlinearFactor>(
         NonlinearFactor::shared_ptr(new MagFactor2(*this)));
   }
@@ -150,7 +150,7 @@ public:
    */
   Vector evaluateError(const Point3& nM, const Point3& bias,
       boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 =
-          boost::none) const {
+          boost::none) const override {
     // measured bM = nRb * nM + b, where b is unknown bias
     Point3 hx = bRn_.rotate(nM, boost::none, H1) + bias;
     if (H2)
@@ -179,7 +179,7 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual NonlinearFactor::shared_ptr clone() const {
+  NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<NonlinearFactor>(
         NonlinearFactor::shared_ptr(new MagFactor3(*this)));
   }
@@ -192,7 +192,7 @@ public:
   Vector evaluateError(const double& scale, const Unit3& direction,
       const Point3& bias, boost::optional<Matrix&> H1 = boost::none,
       boost::optional<Matrix&> H2 = boost::none, boost::optional<Matrix&> H3 =
-          boost::none) const {
+          boost::none) const override {
     // measured bM = nRb * nM + b, where b is unknown bias
     Unit3 rotated = bRn_.rotate(direction, boost::none, H2);
     Point3 hx = scale * rotated.point3() + bias;
--- gtsam-4.0.3.orig/gtsam/navigation/NavState.cpp
+++ gtsam-4.0.3/gtsam/navigation/NavState.cpp
@@ -88,15 +88,15 @@ Matrix7 NavState::matrix() const {
 
 //------------------------------------------------------------------------------
 ostream& operator<<(ostream& os, const NavState& state) {
-  os << "R:" << state.attitude();
-  os << "p:" << state.position() << endl;
-  os << "v:" << Point3(state.velocity()) << endl;
+  os << "R: " << state.attitude() << "\n";
+  os << "p: " << state.position() << "\n";
+  os << "v: " << Point3(state.velocity());
   return os;
 }
 
 //------------------------------------------------------------------------------
 void NavState::print(const string& s) const {
-  cout << s << *this << endl;
+  cout << (s.empty() ? s : s + " ") << *this << endl;
 }
 
 //------------------------------------------------------------------------------
--- gtsam-4.0.3.orig/gtsam/navigation/PreintegrationBase.cpp
+++ gtsam-4.0.3/gtsam/navigation/PreintegrationBase.cpp
@@ -194,21 +194,5 @@ Vector9 PreintegrationBase::computeError
 }
 
 //------------------------------------------------------------------------------
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-PoseVelocityBias PreintegrationBase::predict(const Pose3& pose_i,
-    const Vector3& vel_i, const imuBias::ConstantBias& bias_i,
-    const Vector3& n_gravity, const Vector3& omegaCoriolis,
-    const bool use2ndOrderCoriolis) const {
-// NOTE(frank): parameters are supposed to be constant, below is only provided for compatibility
-  boost::shared_ptr<Params> q = boost::make_shared<Params>(p());
-  q->n_gravity = n_gravity;
-  q->omegaCoriolis = omegaCoriolis;
-  q->use2ndOrderCoriolis = use2ndOrderCoriolis;
-  p_ = q;
-  return PoseVelocityBias(predict(NavState(pose_i, vel_i), bias_i), bias_i);
-}
-
-#endif
-//------------------------------------------------------------------------------
 
 }  // namespace gtsam
--- gtsam-4.0.3.orig/gtsam/navigation/PreintegrationBase.h
+++ gtsam-4.0.3/gtsam/navigation/PreintegrationBase.h
@@ -32,25 +32,6 @@
 
 namespace gtsam {
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-/// @deprecated
-struct PoseVelocityBias {
-  Pose3 pose;
-  Vector3 velocity;
-  imuBias::ConstantBias bias;
-  PoseVelocityBias(const Pose3& _pose, const Vector3& _velocity,
-      const imuBias::ConstantBias _bias) :
-      pose(_pose), velocity(_velocity), bias(_bias) {
-  }
-  PoseVelocityBias(const NavState& navState, const imuBias::ConstantBias _bias) :
-      pose(navState.pose()), velocity(navState.velocity()), bias(_bias) {
-  }
-  NavState navState() const {
-    return NavState(pose, velocity);
-  }
-};
-#endif
-
 /**
  * PreintegrationBase is the base class for PreintegratedMeasurements
  * (in ImuFactor) and CombinedPreintegratedMeasurements (in CombinedImuFactor).
@@ -63,11 +44,6 @@ class GTSAM_EXPORT PreintegrationBase {
   typedef PreintegrationParams Params;
 
  protected:
-  /// Parameters. Declared mutable only for deprecated predict method.
-  /// TODO(frank): make const once deprecated method is removed
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  mutable
-#endif
   boost::shared_ptr<Params> p_;
 
   /// Acceleration and gyro bias used for preintegration
@@ -117,16 +93,11 @@ class GTSAM_EXPORT PreintegrationBase {
   }
 
   /// const reference to params
-  const Params& p() const {
-    return *boost::static_pointer_cast<Params>(p_);
+  Params& p() const {
+    return *p_;
   }
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  void set_body_P_sensor(const Pose3& body_P_sensor) {
-    p_->body_P_sensor = body_P_sensor;
-  }
-#endif
-/// @}
+  /// @}
 
   /// @name Instance variables access
   /// @{
@@ -201,18 +172,6 @@ class GTSAM_EXPORT PreintegrationBase {
       OptionalJacobian<9, 6> H3 = boost::none, OptionalJacobian<9, 3> H4 =
           boost::none, OptionalJacobian<9, 6> H5 = boost::none) const;
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-
-  /// @deprecated predict
-  PoseVelocityBias predict(const Pose3& pose_i, const Vector3& vel_i,
-      const imuBias::ConstantBias& bias_i, const Vector3& n_gravity,
-      const Vector3& omegaCoriolis, const bool use2ndOrderCoriolis = false) const;
-
-  /// @}
-#endif
-
  private:
   /** Serialization function */
   friend class boost::serialization::access;
--- gtsam-4.0.3.orig/gtsam/navigation/PreintegrationParams.h
+++ gtsam-4.0.3/gtsam/navigation/PreintegrationParams.h
@@ -56,8 +56,8 @@ struct GTSAM_EXPORT PreintegrationParams
     return boost::shared_ptr<PreintegrationParams>(new PreintegrationParams(Vector3(0, 0, -g)));
   }
 
-  void print(const std::string& s="") const;
-  bool equals(const PreintegratedRotationParams& other, double tol) const;
+  void print(const std::string& s="") const override;
+  bool equals(const PreintegratedRotationParams& other, double tol) const override;
 
   void setAccelerometerCovariance(const Matrix3& cov) { accelerometerCovariance = cov; }
   void setIntegrationCovariance(const Matrix3& cov)   { integrationCovariance = cov; }
--- gtsam-4.0.3.orig/gtsam/navigation/ScenarioRunner.h
+++ gtsam-4.0.3/gtsam/navigation/ScenarioRunner.h
@@ -104,15 +104,6 @@ class GTSAM_EXPORT ScenarioRunner {
 
   /// Estimate covariance of sampled noise for sanity-check
   Matrix6 estimateNoiseCovariance(size_t N = 1000) const;
-
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  ScenarioRunner(const Scenario* scenario, const SharedParams& p,
-                 double imuSampleTime = 1.0 / 100.0, const Bias& bias = Bias())
-      : ScenarioRunner(*scenario, p, imuSampleTime, bias) {}
-  /// @}
-#endif
 };
 
 }  // namespace gtsam
--- gtsam-4.0.3.orig/gtsam/navigation/tests/testNavState.cpp
+++ gtsam-4.0.3/gtsam/navigation/tests/testNavState.cpp
@@ -164,37 +164,6 @@ TEST( NavState, Manifold ) {
 }
 
 /* ************************************************************************* */
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-TEST(NavState, Update) {
-  Vector3 omega(M_PI / 100.0, 0.0, 0.0);
-  Vector3 acc(0.1, 0.0, 0.0);
-  double dt = 10;
-  Matrix9 aF;
-  Matrix93 aG1, aG2;
-  boost::function<NavState(const NavState&, const Vector3&, const Vector3&)> update =
-  boost::bind(&NavState::update, _1, _2, _3, dt, boost::none,
-      boost::none, boost::none);
-  Vector3 b_acc = kAttitude * acc;
-  NavState expected(kAttitude.expmap(dt * omega),
-      kPosition + Point3((kVelocity + b_acc * dt / 2) * dt),
-      kVelocity + b_acc * dt);
-  NavState actual = kState1.update(acc, omega, dt, aF, aG1, aG2);
-  EXPECT(assert_equal(expected, actual));
-  EXPECT(assert_equal(numericalDerivative31(update, kState1, acc, omega, 1e-7), aF, 1e-7));
-  EXPECT(assert_equal(numericalDerivative32(update, kState1, acc, omega, 1e-7), aG1, 1e-7));
-  EXPECT(assert_equal(numericalDerivative33(update, kState1, acc, omega, 1e-7), aG2, 1e-7));
-
-  // Try different values
-  omega = Vector3(0.1, 0.2, 0.3);
-  acc = Vector3(0.4, 0.5, 0.6);
-  kState1.update(acc, omega, dt, aF, aG1, aG2);
-  EXPECT(assert_equal(numericalDerivative31(update, kState1, acc, omega, 1e-7), aF, 1e-7));
-  EXPECT(assert_equal(numericalDerivative32(update, kState1, acc, omega, 1e-7), aG1, 1e-7));
-  EXPECT(assert_equal(numericalDerivative33(update, kState1, acc, omega, 1e-7), aG2, 1e-7));
-}
-#endif
-
-/* ************************************************************************* */
 static const double dt = 2.0;
 boost::function<Vector9(const NavState&, const bool&)> coriolis = boost::bind(
     &NavState::coriolis, _1, dt, kOmegaCoriolis, _2, boost::none);
@@ -238,6 +207,25 @@ TEST(NavState, CorrectPIM) {
 }
 
 /* ************************************************************************* */
+TEST(NavState, Stream)
+{
+  NavState state;
+
+  std::ostringstream os;
+  os << state;
+
+  string expected;
+#ifdef GTSAM_TYPEDEF_POINTS_TO_VECTORS
+  expected = "R: [\n\t1, 0, 0;\n\t0, 1, 0;\n\t0, 0, 1\n]\np: 0\n0\n0\nv: 0\n0\n0";
+#else
+  expected = "R: [\n\t1, 0, 0;\n\t0, 1, 0;\n\t0, 0, 1\n]\np: [0, 0, 0]'\nv: [0, 0, 0]'";
+#endif
+
+  EXPECT(os.str() == expected);
+}
+
+
+/* ************************************************************************* */
 int main() {
   TestResult tr;
   return TestRegistry::runAllTests(tr);
--- gtsam-4.0.3.orig/gtsam/navigation/tests/testPoseVelocityBias.cpp
+++ gtsam-4.0.3/gtsam/navigation/tests/testPoseVelocityBias.cpp
@@ -25,40 +25,6 @@
 using namespace std;
 using namespace gtsam;
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-
-// Should be seen as between(pvb1,pvb2), i.e., written as pvb2 \omin pvb1
-Vector9 error(const PoseVelocityBias& pvb1, const PoseVelocityBias& pvb2) {
-  Matrix3 R1 = pvb1.pose.rotation().matrix();
-  // Ri.transpose() translate the error from the global frame into pose1's frame
-  const Vector3 fp = R1.transpose() * (pvb2.pose.translation() - pvb1.pose.translation());
-  const Vector3 fv = R1.transpose() * (pvb2.velocity - pvb1.velocity);
-  const Rot3 R1BetweenR2 = pvb1.pose.rotation().between(pvb2.pose.rotation());
-  const Vector3 fR = Rot3::Logmap(R1BetweenR2);
-  Vector9 r;
-  r << fp, fv, fR;
-  return r;
-}
-
-/* ************************************************************************************************/
-TEST(PoseVelocityBias, error) {
-  Point3 i1(0, 1, 0), j1(-1, 0, 0), k1(0, 0, 1);
-  Pose3 x1(Rot3(i1, j1, k1), Point3(5.0, 1.0, 0.0));
-  Vector3 v1(Vector3(0.5, 0.0, 0.0));
-  imuBias::ConstantBias bias1(Vector3(0.2, 0, 0), Vector3(0.1, 0, 0.3));
-
-  Pose3 x2(Rot3(i1, j1, k1).expmap(Vector3(0.1, 0.2, 0.3)), Point3(5.5, 1.0, 6.0));
-  Vector3 v2(Vector3(0.5, 4.0, 3.0));
-  imuBias::ConstantBias bias2(Vector3(0.1, 0.2, -0.3), Vector3(0.2, 0.3, 0.1));
-
-  PoseVelocityBias pvb1(x1, v1, bias1), pvb2(x2, v2, bias2);
-
-  Vector9 expected, actual = error(pvb1, pvb2);
-  expected << 0.0, -0.5, 6.0, 4.0, 0.0, 3.0, 0.1, 0.2, 0.3;
-  EXPECT(assert_equal(expected, actual, 1e-9));
-}
-#endif
-
 /* ************************************************************************************************/
 int main() {
   TestResult tr;
--- gtsam-4.0.3.orig/gtsam/nonlinear/ExpressionFactor.h
+++ gtsam-4.0.3/gtsam/nonlinear/ExpressionFactor.h
@@ -19,16 +19,26 @@
 
 #pragma once
 
+#include <array>
+#include <gtsam/config.h>
+#include <gtsam/base/Testable.h>
 #include <gtsam/nonlinear/Expression.h>
 #include <gtsam/nonlinear/NonlinearFactor.h>
-#include <gtsam/base/Testable.h>
 #include <numeric>
 
 namespace gtsam {
 
 /**
-
- * Factor that supports arbitrary expressions via AD
+ * Factor that supports arbitrary expressions via AD.
+ *
+ * Arbitrary instances of this template can be directly inserted into a factor
+ * graph for optimization. However, to enable the correct (de)serialization of
+ * such instances, the user should declare derived classes from this template,
+ * implementing expresion(), serialize(), clone(), print(), and defining the
+ * corresponding `struct traits<NewFactor> : public Testable<NewFactor> {}`.
+ *
+ * \tparam T Type for measurements.
+ *
  */
 template<typename T>
 class ExpressionFactor: public NoiseModelFactor {
@@ -68,13 +78,13 @@ protected:
 
   /// print relies on Testable traits being defined for T
   void print(const std::string& s = "",
-             const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+             const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     NoiseModelFactor::print(s, keyFormatter);
     traits<T>::Print(measured_, "ExpressionFactor with measurement: ");
   }
 
   /// equals relies on Testable traits being defined for T
-  bool equals(const NonlinearFactor& f, double tol) const {
+  bool equals(const NonlinearFactor& f, double tol) const override {
     const ExpressionFactor* p = dynamic_cast<const ExpressionFactor*>(&f);
     return p && NoiseModelFactor::equals(f, tol) &&
            traits<T>::Equals(measured_, p->measured_, tol) &&
@@ -86,8 +96,8 @@ protected:
    * We override this method to provide
    * both the function evaluation and its derivative(s) in H.
    */
-  virtual Vector unwhitenedError(const Values& x,
-                                 boost::optional<std::vector<Matrix>&> H = boost::none) const {
+  Vector unwhitenedError(const Values& x,
+    boost::optional<std::vector<Matrix>&> H = boost::none) const override {
     if (H) {
       const T value = expression_.valueAndDerivatives(x, keys_, dims_, *H);
       // NOTE(hayk): Doing the reverse, AKA Local(measured_, value) is not correct here
@@ -99,7 +109,7 @@ protected:
     }
   }
 
-  virtual boost::shared_ptr<GaussianFactor> linearize(const Values& x) const {
+  boost::shared_ptr<GaussianFactor> linearize(const Values& x) const override {
     // Only linearize if the factor is active
     if (!active(x))
       return boost::shared_ptr<JacobianFactor>();
@@ -138,7 +148,7 @@ protected:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
@@ -218,25 +228,97 @@ template <typename T>
 struct traits<ExpressionFactor<T> > : public Testable<ExpressionFactor<T> > {};
 
 /**
+ * N-ary variadic template for ExpressionFactor meant as a base class for N-ary
+ * factors. Enforces an 'expression' method with N keys.
+ * Derived class (an N-factor!) needs to call 'initialize'.
+ *
+ * Does not provide backward compatible 'evaluateError'.
+ *
+ * \tparam T Type for measurements. The rest of template arguments are types
+ *         for the N key-indexed Values.
+ *
+ */
+template <typename T, typename... Args>
+class ExpressionFactorN : public ExpressionFactor<T> {
+public:
+  static const std::size_t NARY_EXPRESSION_SIZE = sizeof...(Args);
+  using ArrayNKeys = std::array<Key, NARY_EXPRESSION_SIZE>;
+
+  /// Destructor
+  virtual ~ExpressionFactorN() = default;
+
+  // Don't provide backward compatible evaluateVector(), due to its problematic
+  // variable length of optional Jacobian arguments. Vector evaluateError(const
+  // Args... args,...);
+
+  /// Recreate expression from given keys_ and measured_, used in load
+  /// Needed to deserialize a derived factor
+  virtual Expression<T> expression(const ArrayNKeys &keys) const {
+    throw std::runtime_error(
+        "ExpressionFactorN::expression not provided: cannot deserialize.");
+  }
+
+protected:
+  /// Default constructor, for serialization
+  ExpressionFactorN() = default;
+
+  /// Constructor takes care of keys, but still need to call initialize
+  ExpressionFactorN(const ArrayNKeys &keys, const SharedNoiseModel &noiseModel,
+                    const T &measurement)
+      : ExpressionFactor<T>(noiseModel, measurement) {
+    for (const auto &key : keys)
+      Factor::keys_.push_back(key);
+  }
+
+private:
+  /// Return an expression that predicts the measurement given Values
+  Expression<T> expression() const override {
+    ArrayNKeys keys;
+    int idx = 0;
+    for (const auto &key : Factor::keys_)
+      keys[idx++] = key;
+    return expression(keys);
+  }
+
+  friend class boost::serialization::access;
+  template <class ARCHIVE>
+  void serialize(ARCHIVE &ar, const unsigned int /*version*/) {
+    ar &boost::serialization::make_nvp(
+        "ExpressionFactorN",
+        boost::serialization::base_object<ExpressionFactor<T>>(*this));
+  }
+};
+/// traits
+template <typename T, typename... Args>
+struct traits<ExpressionFactorN<T, Args...>>
+    : public Testable<ExpressionFactorN<T, Args...>> {};
+// ExpressionFactorN
+
+
+#if defined(GTSAM_ALLOW_DEPRECATED_SINCE_V41)
+/**
  * Binary specialization of ExpressionFactor meant as a base class for binary
- * factors. Enforces an 'expression' method with two keys, and provides 'evaluateError'.
- * Derived class (a binary factor!) needs to call 'initialize'.
+ * factors. Enforces an 'expression' method with two keys, and provides
+ * 'evaluateError'. Derived class (a binary factor!) needs to call 'initialize'.
+ *
+ * \sa ExpressionFactorN
+ * \deprecated Prefer the more general ExpressionFactorN<>.
  */
 template <typename T, typename A1, typename A2>
-class ExpressionFactor2 : public ExpressionFactor<T> {
- public:
+class ExpressionFactor2 : public ExpressionFactorN<T, A1, A2> {
+public:
   /// Destructor
-  virtual ~ExpressionFactor2() {}
+  ~ExpressionFactor2() override {}
 
   /// Backwards compatible evaluateError, to make existing tests compile
-  Vector evaluateError(const A1& a1, const A2& a2,
-                       boost::optional<Matrix&> H1 = boost::none,
-                       boost::optional<Matrix&> H2 = boost::none) const {
+  Vector evaluateError(const A1 &a1, const A2 &a2,
+                       boost::optional<Matrix &> H1 = boost::none,
+                       boost::optional<Matrix &> H2 = boost::none) const {
     Values values;
     values.insert(this->keys_[0], a1);
     values.insert(this->keys_[1], a2);
     std::vector<Matrix> H(2);
-    Vector error = this->unwhitenedError(values, H);
+    Vector error = ExpressionFactor<T>::unwhitenedError(values, H);
     if (H1) (*H1) = H[0];
     if (H2) (*H2) = H[1];
     return error;
@@ -245,35 +327,25 @@ class ExpressionFactor2 : public Express
   /// Recreate expression from given keys_ and measured_, used in load
   /// Needed to deserialize a derived factor
   virtual Expression<T> expression(Key key1, Key key2) const {
-    throw std::runtime_error("ExpressionFactor2::expression not provided: cannot deserialize.");
+    throw std::runtime_error(
+        "ExpressionFactor2::expression not provided: cannot deserialize.");
+  }
+  virtual Expression<T>
+  expression(const typename ExpressionFactorN<T, A1, A2>::ArrayNKeys &keys)
+      const override {
+    return expression(keys[0], keys[1]);
   }
 
- protected:
+protected:
   /// Default constructor, for serialization
   ExpressionFactor2() {}
 
   /// Constructor takes care of keys, but still need to call initialize
-  ExpressionFactor2(Key key1, Key key2,
-                                const SharedNoiseModel& noiseModel,
-                                const T& measurement)
-      : ExpressionFactor<T>(noiseModel, measurement) {
-    this->keys_.push_back(key1);
-    this->keys_.push_back(key2);
-  }
-
- private:
-  /// Return an expression that predicts the measurement given Values
-  virtual Expression<T> expression() const {
-    return expression(this->keys_[0], this->keys_[1]);
-  }
-
-  friend class boost::serialization::access;
-  template <class ARCHIVE>
-  void serialize(ARCHIVE& ar, const unsigned int /*version*/) {
-    ar& boost::serialization::make_nvp(
-        "ExpressionFactor", boost::serialization::base_object<ExpressionFactor<T> >(*this));
-  }
+  ExpressionFactor2(Key key1, Key key2, const SharedNoiseModel &noiseModel,
+                    const T &measurement)
+      : ExpressionFactorN<T, A1, A2>({key1, key2}, noiseModel, measurement) {}
 };
 // ExpressionFactor2
+#endif
 
-}// \ namespace gtsam
+} // namespace gtsam
--- gtsam-4.0.3.orig/gtsam/nonlinear/FunctorizedFactor.h
+++ gtsam-4.0.3/gtsam/nonlinear/FunctorizedFactor.h
@@ -82,13 +82,13 @@ class GTSAM_EXPORT FunctorizedFactor : p
   virtual ~FunctorizedFactor() {}
 
   /// @return a deep copy of this factor
-  virtual NonlinearFactor::shared_ptr clone() const {
+  NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<NonlinearFactor>(
         NonlinearFactor::shared_ptr(new FunctorizedFactor<R, T>(*this)));
   }
 
   Vector evaluateError(const T &params,
-                       boost::optional<Matrix &> H = boost::none) const {
+                       boost::optional<Matrix &> H = boost::none) const override {
     R x = func_(params, H);
     Vector error = traits<R>::Local(measured_, x);
     return error;
@@ -97,7 +97,7 @@ class GTSAM_EXPORT FunctorizedFactor : p
   /// @name Testable
   /// @{
   void print(const std::string &s = "",
-             const KeyFormatter &keyFormatter = DefaultKeyFormatter) const {
+             const KeyFormatter &keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s, keyFormatter);
     std::cout << s << (s != "" ? " " : "") << "FunctorizedFactor("
               << keyFormatter(this->key()) << ")" << std::endl;
@@ -106,10 +106,9 @@ class GTSAM_EXPORT FunctorizedFactor : p
               << std::endl;
   }
 
-  virtual bool equals(const NonlinearFactor &other, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor &other, double tol = 1e-9) const override {
     const FunctorizedFactor<R, T> *e =
         dynamic_cast<const FunctorizedFactor<R, T> *>(&other);
-    const bool base = Base::equals(*e, tol);
     return e && Base::equals(other, tol) &&
            traits<R>::Equals(this->measured_, e->measured_, tol);
   }
--- gtsam-4.0.3.orig/gtsam/nonlinear/ISAM2Clique.h
+++ gtsam-4.0.3/gtsam/nonlinear/ISAM2Clique.h
@@ -51,6 +51,7 @@ class GTSAM_EXPORT ISAM2Clique
 
   /// Default constructor
   ISAM2Clique() : Base() {}
+  virtual ~ISAM2Clique() = default;
 
   /// Copy constructor, does *not* copy solution pointers as these are invalid
   /// in different trees.
@@ -85,7 +86,7 @@ class GTSAM_EXPORT ISAM2Clique
 
   /** print this node */
   void print(const std::string& s = "",
-             const KeyFormatter& formatter = DefaultKeyFormatter) const;
+             const KeyFormatter& formatter = DefaultKeyFormatter) const override;
 
   void optimizeWildfire(const KeySet& replaced, double threshold,
                         KeySet* changed, VectorValues* delta,
--- gtsam-4.0.3.orig/gtsam/nonlinear/LinearContainerFactor.h
+++ gtsam-4.0.3/gtsam/nonlinear/LinearContainerFactor.h
@@ -59,10 +59,10 @@ public:
   // Testable
 
   /** print */
-  GTSAM_EXPORT void print(const std::string& s = "", const KeyFormatter& keyFormatter = gtsam::DefaultKeyFormatter) const;
+  GTSAM_EXPORT void print(const std::string& s = "", const KeyFormatter& keyFormatter = gtsam::DefaultKeyFormatter) const override;
 
   /** Check if two factors are equal */
-  GTSAM_EXPORT bool equals(const NonlinearFactor& f, double tol = 1e-9) const;
+  GTSAM_EXPORT bool equals(const NonlinearFactor& f, double tol = 1e-9) const override;
 
   // NonlinearFactor
 
@@ -74,10 +74,10 @@ public:
    *
    * @return nonlinear error if linearizationPoint present, zero otherwise
    */
-  GTSAM_EXPORT double error(const Values& c) const;
+  GTSAM_EXPORT double error(const Values& c) const override;
 
   /** get the dimension of the factor: rows of linear factor */
-  GTSAM_EXPORT size_t dim() const;
+  GTSAM_EXPORT size_t dim() const override;
 
   /** Extract the linearization point used in recalculating error */
   const boost::optional<Values>& linearizationPoint() const { return linearizationPoint_; }
@@ -98,7 +98,7 @@ public:
    * TODO: better approximation of relinearization
    * TODO: switchable modes for approximation technique
    */
-  GTSAM_EXPORT GaussianFactor::shared_ptr linearize(const Values& c) const;
+  GTSAM_EXPORT GaussianFactor::shared_ptr linearize(const Values& c) const override;
 
   /**
    * Creates an anti-factor directly
@@ -116,7 +116,7 @@ public:
    *
    * Clones the underlying linear factor
    */
-  NonlinearFactor::shared_ptr clone() const {
+  NonlinearFactor::shared_ptr clone() const override {
     return NonlinearFactor::shared_ptr(new LinearContainerFactor(factor_,linearizationPoint_));
   }
 
@@ -140,21 +140,14 @@ public:
    * Utility function for converting linear graphs to nonlinear graphs
    * consisting of LinearContainerFactors.
    */
-  GTSAM_EXPORT static NonlinearFactorGraph ConvertLinearGraph(const GaussianFactorGraph& linear_graph,
+  GTSAM_EXPORT
+  static NonlinearFactorGraph ConvertLinearGraph(const GaussianFactorGraph& linear_graph,
       const Values& linearizationPoint = Values());
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  GTSAM_EXPORT static NonlinearFactorGraph convertLinearGraph(const GaussianFactorGraph& linear_graph,
-      const Values& linearizationPoint = Values()) {
-    return ConvertLinearGraph(linear_graph, linearizationPoint);
-  }
-#endif
-
-protected:
-	GTSAM_EXPORT void initializeLinearizationPoint(const Values& linearizationPoint);
-
-private:
+ protected:
+  GTSAM_EXPORT void initializeLinearizationPoint(const Values& linearizationPoint);
 
+ private:
   /** Serialization function */
   friend class boost::serialization::access;
   template<class ARCHIVE>
--- gtsam-4.0.3.orig/gtsam/nonlinear/NonlinearEquality.h
+++ gtsam-4.0.3/gtsam/nonlinear/NonlinearEquality.h
@@ -107,15 +107,15 @@ public:
   /// @name Testable
   /// @{
 
-  virtual void print(const std::string& s = "",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << "Constraint: on [" << keyFormatter(this->key()) << "]\n";
     traits<VALUE>::Print(feasible_, "Feasible Point:\n");
     std::cout << "Variable Dimension: " << traits<T>::GetDimension(feasible_) << std::endl;
   }
 
   /** Check if two factors are equal */
-  virtual bool equals(const NonlinearFactor& f, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& f, double tol = 1e-9) const override {
     const This* e = dynamic_cast<const This*>(&f);
     return e && Base::equals(f) && traits<T>::Equals(feasible_,e->feasible_, tol)
         && std::abs(error_gain_ - e->error_gain_) < tol;
@@ -126,7 +126,7 @@ public:
   /// @{
 
   /** actual error function calculation */
-  virtual double error(const Values& c) const {
+  double error(const Values& c) const override {
     const T& xj = c.at<T>(this->key());
     Vector e = this->unwhitenedError(c);
     if (allow_error_ || !compare_(xj, feasible_)) {
@@ -138,7 +138,7 @@ public:
 
   /** error function */
   Vector evaluateError(const T& xj,
-      boost::optional<Matrix&> H = boost::none) const {
+      boost::optional<Matrix&> H = boost::none) const override {
     const size_t nj = traits<T>::GetDimension(feasible_);
     if (allow_error_) {
       if (H)
@@ -158,7 +158,7 @@ public:
   }
 
   // Linearize is over-written, because base linearization tries to whiten
-  virtual GaussianFactor::shared_ptr linearize(const Values& x) const {
+  GaussianFactor::shared_ptr linearize(const Values& x) const override {
     const T& xj = x.at<T>(this->key());
     Matrix A;
     Vector b = evaluateError(xj, A);
@@ -168,7 +168,7 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
@@ -242,14 +242,14 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   /** g(x) with optional derivative */
   Vector evaluateError(const X& x1,
-      boost::optional<Matrix&> H = boost::none) const {
+      boost::optional<Matrix&> H = boost::none) const override {
     if (H)
       (*H) = Matrix::Identity(traits<X>::GetDimension(x1),traits<X>::GetDimension(x1));
     // manifold equivalent of h(x)-z -> log(z,h(x))
@@ -257,8 +257,8 @@ public:
   }
 
   /** Print */
-  virtual void print(const std::string& s = "",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << ": NonlinearEquality1(" << keyFormatter(this->key())
         << ")," << "\n";
     this->noiseModel_->print();
@@ -317,14 +317,14 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   /** g(x) with optional derivative2 */
   Vector evaluateError(const X& x1, const X& x2, boost::optional<Matrix&> H1 =
-      boost::none, boost::optional<Matrix&> H2 = boost::none) const {
+      boost::none, boost::optional<Matrix&> H2 = boost::none) const override {
     static const size_t p = traits<X>::dimension;
     if (H1) *H1 = -Matrix::Identity(p,p);
     if (H2) *H2 =  Matrix::Identity(p,p);
--- gtsam-4.0.3.orig/gtsam/nonlinear/NonlinearFactor.h
+++ gtsam-4.0.3/gtsam/nonlinear/NonlinearFactor.h
@@ -29,13 +29,6 @@
 #include <boost/serialization/base_object.hpp>
 #include <boost/assign/list_of.hpp>
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-#define ADD_CLONE_NONLINEAR_FACTOR(Derived) \
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const { \
-  return boost::static_pointer_cast<gtsam::NonlinearFactor>( \
-      gtsam::NonlinearFactor::shared_ptr(new Derived(*this))); }
-#endif
-
 namespace gtsam {
 
 using boost::assign::cref_list_of;
@@ -195,14 +188,14 @@ protected:
 public:
 
   /** Print */
-  virtual void print(const std::string& s = "",
-    const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s = "",
+    const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** Check if two factors are equal */
-  virtual bool equals(const NonlinearFactor& f, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& f, double tol = 1e-9) const override;
 
   /** get the dimension of the factor (number of rows on linearization) */
-  virtual size_t dim() const {
+  size_t dim() const override {
     return noiseModel_->dim();
   }
 
@@ -242,30 +235,22 @@ public:
    * In this class, we take the raw prediction error \f$ h(x)-z \f$, ask the noise model
    * to transform it to \f$ (h(x)-z)^2/\sigma^2 \f$, and then multiply by 0.5.
    */
-  virtual double error(const Values& c) const;
+  double error(const Values& c) const override;
 
   /**
    * Linearize a non-linearFactorN to get a GaussianFactor,
    * \f$ Ax-b \approx h(x+\delta x)-z = h(x) + A \delta x - z \f$
    * Hence \f$ b = z - h(x) = - \mathtt{error\_vector}(x) \f$
    */
-  boost::shared_ptr<GaussianFactor> linearize(const Values& x) const;
-
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  SharedNoiseModel get_noiseModel() const { return noiseModel_; }
-  /// @}
-#endif
-
-private:
+  boost::shared_ptr<GaussianFactor> linearize(const Values& x) const override;
 
+ private:
   /** Serialization function */
   friend class boost::serialization::access;
   template<class ARCHIVE>
   void serialize(ARCHIVE & ar, const unsigned int /*version*/) {
     ar & boost::serialization::make_nvp("NonlinearFactor",
-        boost::serialization::base_object<Base>(*this));
+         boost::serialization::base_object<Base>(*this));
     ar & BOOST_SERIALIZATION_NVP(noiseModel_);
   }
 
@@ -296,6 +281,8 @@ protected:
   typedef NoiseModelFactor1<VALUE> This;
 
 public:
+  /// @name Constructors
+  /// @{
 
   /** Default constructor for I/O only */
   NoiseModelFactor1() {}
@@ -309,16 +296,23 @@ public:
    *  @param noiseModel shared pointer to noise model
    *  @param key1 by which to look up X value in Values
    */
-  NoiseModelFactor1(const SharedNoiseModel& noiseModel, Key key1) :
-    Base(noiseModel, cref_list_of<1>(key1)) {}
+  NoiseModelFactor1(const SharedNoiseModel &noiseModel, Key key1)
+      : Base(noiseModel, cref_list_of<1>(key1)) {}
+
+  /// @}
+  /// @name NoiseModelFactor methods
+  /// @{
 
-  /** Calls the 1-key specific version of evaluateError, which is pure virtual
-   *  so must be implemented in the derived class.
+  /**
+   * Calls the 1-key specific version of evaluateError below, which is pure
+   * virtual so must be implemented in the derived class.
    */
-  virtual Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const {
-    if(this->active(x)) {
-      const X& x1 = x.at<X>(keys_[0]);
-      if(H) {
+  Vector unwhitenedError(
+      const Values &x,
+      boost::optional<std::vector<Matrix> &> H = boost::none) const override {
+    if (this->active(x)) {
+      const X &x1 = x.at<X>(keys_[0]);
+      if (H) {
         return evaluateError(x1, (*H)[0]);
       } else {
         return evaluateError(x1);
@@ -328,16 +322,22 @@ public:
     }
   }
 
+  /// @}
+  /// @name Virtual methods
+  /// @{
+
   /**
    *  Override this method to finish implementing a unary factor.
    *  If the optional Matrix reference argument is specified, it should compute
    *  both the function evaluation and its derivative in X.
    */
-  virtual Vector evaluateError(const X& x, boost::optional<Matrix&> H =
-      boost::none) const = 0;
+  virtual Vector
+  evaluateError(const X &x,
+                boost::optional<Matrix &> H = boost::none) const = 0;
 
-private:
+  /// @}
 
+private:
   /** Serialization function */
   friend class boost::serialization::access;
   template<class ARCHIVE>
@@ -389,7 +389,7 @@ public:
 
   /** Calls the 2-key specific version of evaluateError, which is pure virtual
    * so must be implemented in the derived class. */
-  virtual Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const {
+  Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const override {
     if(this->active(x)) {
       const X1& x1 = x.at<X1>(keys_[0]);
       const X2& x2 = x.at<X2>(keys_[1]);
@@ -467,7 +467,7 @@ public:
 
   /** Calls the 3-key specific version of evaluateError, which is pure virtual
    * so must be implemented in the derived class. */
-  virtual Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const {
+  Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const override {
     if(this->active(x)) {
       if(H)
         return evaluateError(x.at<X1>(keys_[0]), x.at<X2>(keys_[1]), x.at<X3>(keys_[2]), (*H)[0], (*H)[1], (*H)[2]);
@@ -547,7 +547,7 @@ public:
 
   /** Calls the 4-key specific version of evaluateError, which is pure virtual
    * so must be implemented in the derived class. */
-  virtual Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const {
+  Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const override {
     if(this->active(x)) {
       if(H)
         return evaluateError(x.at<X1>(keys_[0]), x.at<X2>(keys_[1]), x.at<X3>(keys_[2]), x.at<X4>(keys_[3]), (*H)[0], (*H)[1], (*H)[2], (*H)[3]);
@@ -631,7 +631,7 @@ public:
 
   /** Calls the 5-key specific version of evaluateError, which is pure virtual
    * so must be implemented in the derived class. */
-  virtual Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const {
+  Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const override {
     if(this->active(x)) {
       if(H)
         return evaluateError(x.at<X1>(keys_[0]), x.at<X2>(keys_[1]), x.at<X3>(keys_[2]), x.at<X4>(keys_[3]), x.at<X5>(keys_[4]), (*H)[0], (*H)[1], (*H)[2], (*H)[3], (*H)[4]);
@@ -719,7 +719,7 @@ public:
 
   /** Calls the 6-key specific version of evaluateError, which is pure virtual
    * so must be implemented in the derived class. */
-  virtual Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const {
+  Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const override {
     if(this->active(x)) {
       if(H)
         return evaluateError(x.at<X1>(keys_[0]), x.at<X2>(keys_[1]), x.at<X3>(keys_[2]), x.at<X4>(keys_[3]), x.at<X5>(keys_[4]), x.at<X6>(keys_[5]), (*H)[0], (*H)[1], (*H)[2], (*H)[3], (*H)[4], (*H)[5]);
--- gtsam-4.0.3.orig/gtsam/nonlinear/NonlinearOptimizer.h
+++ gtsam-4.0.3/gtsam/nonlinear/NonlinearOptimizer.h
@@ -105,14 +105,17 @@ public:
    */
   const Values& optimizeSafely();
 
-  /// return error
+  /// return error in current optimizer state
   double error() const;
 
-  /// return number of iterations
+  /// return number of iterations in current optimizer state
   size_t iterations() const;
 
-  /// return values
-  const Values& values() const;
+  /// return values in current optimizer state
+  const Values &values() const;
+
+  /// return the graph with nonlinear factors
+  const NonlinearFactorGraph &graph() const { return graph_; }
 
   /// @}
 
--- gtsam-4.0.3.orig/gtsam/nonlinear/PriorFactor.h
+++ gtsam-4.0.3/gtsam/nonlinear/PriorFactor.h
@@ -65,15 +65,15 @@ namespace gtsam {
     }
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
     /** implement functions needed for Testable */
 
     /** print */
-    virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-                                                 DefaultKeyFormatter) const {
+    void print(const std::string& s,
+       const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "PriorFactor on " << keyFormatter(this->key()) << "\n";
       traits<T>::Print(prior_, "  prior mean: ");
       if (this->noiseModel_)
@@ -83,7 +83,7 @@ namespace gtsam {
     }
 
     /** equals */
-    virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+    bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
       const This* e = dynamic_cast<const This*> (&expected);
       return e != nullptr && Base::equals(*e, tol) && traits<T>::Equals(prior_, e->prior_, tol);
     }
@@ -91,7 +91,7 @@ namespace gtsam {
     /** implement functions needed to derive from Factor */
 
     /** vector of errors */
-    Vector evaluateError(const T& x, boost::optional<Matrix&> H = boost::none) const {
+    Vector evaluateError(const T& x, boost::optional<Matrix&> H = boost::none) const override {
       if (H) (*H) = Matrix::Identity(traits<T>::GetDimension(x),traits<T>::GetDimension(x));
       // manifold equivalent of z-x -> Local(x,z)
       // TODO(ASL) Add Jacobians.
@@ -117,4 +117,9 @@ namespace gtsam {
 	GTSAM_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
   };
 
+  /// traits
+  template<class VALUE>
+  struct traits<PriorFactor<VALUE> > : public Testable<PriorFactor<VALUE> > {};
+
+
 } /// namespace gtsam
--- gtsam-4.0.3.orig/gtsam/nonlinear/Values.cpp
+++ gtsam-4.0.3/gtsam/nonlinear/Values.cpp
@@ -53,6 +53,12 @@ namespace gtsam {
   }
 
   /* ************************************************************************* */
+  Values::Values(std::initializer_list<ConstKeyValuePair> init) {
+    for (const auto &kv : init)
+      insert(kv.key, kv.value);
+  }
+
+  /* ************************************************************************* */
   Values::Values(const Values& other, const VectorValues& delta) {
     for (const_iterator key_value = other.begin(); key_value != other.end(); ++key_value) {
       VectorValues::const_iterator it = delta.find(key_value->key);
@@ -69,7 +75,8 @@ namespace gtsam {
 
   /* ************************************************************************* */
   void Values::print(const string& str, const KeyFormatter& keyFormatter) const {
-    cout << str << "Values with " << size() << " values:" << endl;
+    cout << str << (str == "" ? "" : "\n");
+    cout << "Values with " << size() << " values:\n";
     for(const_iterator key_value = begin(); key_value != end(); ++key_value) {
       cout << "Value " << keyFormatter(key_value->key) << ": ";
       key_value->value.print("");
@@ -214,7 +221,7 @@ namespace gtsam {
   }
 
   /* ************************************************************************* */
-  const char* ValuesKeyAlreadyExists::what() const throw() {
+  const char* ValuesKeyAlreadyExists::what() const noexcept {
     if(message_.empty())
       message_ =
           "Attempting to add a key-value pair with key \"" + DefaultKeyFormatter(key_) + "\", key already exists.";
@@ -222,7 +229,7 @@ namespace gtsam {
   }
 
   /* ************************************************************************* */
-  const char* ValuesKeyDoesNotExist::what() const throw() {
+  const char* ValuesKeyDoesNotExist::what() const noexcept {
     if(message_.empty())
       message_ =
           "Attempting to " + std::string(operation_) + " the key \"" +
@@ -231,7 +238,7 @@ namespace gtsam {
   }
 
   /* ************************************************************************* */
-  const char* ValuesIncorrectType::what() const throw() {
+  const char* ValuesIncorrectType::what() const noexcept {
     if(message_.empty()) {
       std::string storedTypeName = demangle(storedTypeId_.name());
       std::string requestedTypeName = demangle(requestedTypeId_.name());
@@ -251,7 +258,7 @@ namespace gtsam {
   }
 
   /* ************************************************************************* */
-  const char* NoMatchFoundForFixed::what() const throw() {
+  const char* NoMatchFoundForFixed::what() const noexcept {
     if(message_.empty()) {
       ostringstream oss;
     oss
--- gtsam-4.0.3.orig/gtsam/nonlinear/Values.h
+++ gtsam-4.0.3/gtsam/nonlinear/Values.h
@@ -149,6 +149,13 @@ namespace gtsam {
 
     /** Move constructor */
     Values(Values&& other);
+    
+    /** Constructor from initializer list. Example usage:
+     * \code
+     * Values v = {{k1, genericValue(pose1)}, {k2, genericValue(point2)}};
+     * \endcode
+     */
+    Values(std::initializer_list<ConstKeyValuePair> init);
 
     /** Construct from a Values and an update vector: identical to other.retract(delta) */
     Values(const Values& other, const VectorValues& delta);
@@ -432,16 +439,16 @@ namespace gtsam {
 
   public:
     /// Construct with the key-value pair attempted to be added
-    ValuesKeyAlreadyExists(Key key) throw() :
+    ValuesKeyAlreadyExists(Key key) noexcept :
       key_(key) {}
 
-    virtual ~ValuesKeyAlreadyExists() throw() {}
+    virtual ~ValuesKeyAlreadyExists() noexcept {}
 
     /// The duplicate key that was attempted to be added
-    Key key() const throw() { return key_; }
+    Key key() const noexcept { return key_; }
 
     /// The message to be displayed to the user
-    GTSAM_EXPORT virtual const char* what() const throw();
+    GTSAM_EXPORT const char* what() const noexcept override;
   };
 
   /* ************************************************************************* */
@@ -455,16 +462,16 @@ namespace gtsam {
 
   public:
     /// Construct with the key that does not exist in the values
-    ValuesKeyDoesNotExist(const char* operation, Key key) throw() :
+    ValuesKeyDoesNotExist(const char* operation, Key key) noexcept :
       operation_(operation), key_(key) {}
 
-    virtual ~ValuesKeyDoesNotExist() throw() {}
+    virtual ~ValuesKeyDoesNotExist() noexcept {}
 
     /// The key that was attempted to be accessed that does not exist
-    Key key() const throw() { return key_; }
+    Key key() const noexcept { return key_; }
 
     /// The message to be displayed to the user
-    GTSAM_EXPORT virtual const char* what() const throw();
+    GTSAM_EXPORT const char* what() const noexcept override;
   };
 
   /* ************************************************************************* */
@@ -480,13 +487,13 @@ namespace gtsam {
   public:
     /// Construct with the key that does not exist in the values
     ValuesIncorrectType(Key key,
-        const std::type_info& storedTypeId, const std::type_info& requestedTypeId) throw() :
+        const std::type_info& storedTypeId, const std::type_info& requestedTypeId) noexcept :
       key_(key), storedTypeId_(storedTypeId), requestedTypeId_(requestedTypeId) {}
 
-    virtual ~ValuesIncorrectType() throw() {}
+    virtual ~ValuesIncorrectType() noexcept {}
 
     /// The key that was attempted to be accessed that does not exist
-    Key key() const throw() { return key_; }
+    Key key() const noexcept { return key_; }
 
     /// The typeid of the value stores in the Values
     const std::type_info& storedTypeId() const { return storedTypeId_; }
@@ -495,18 +502,18 @@ namespace gtsam {
     const std::type_info& requestedTypeId() const { return requestedTypeId_; }
 
     /// The message to be displayed to the user
-    GTSAM_EXPORT virtual const char* what() const throw();
+    GTSAM_EXPORT const char* what() const noexcept override;
   };
 
   /* ************************************************************************* */
   class DynamicValuesMismatched : public std::exception {
 
   public:
-    DynamicValuesMismatched() throw() {}
+    DynamicValuesMismatched() noexcept {}
 
-    virtual ~DynamicValuesMismatched() throw() {}
+    virtual ~DynamicValuesMismatched() noexcept {}
 
-    virtual const char* what() const throw() {
+    const char* what() const noexcept override {
       return "The Values 'this' and the argument passed to Values::localCoordinates have mismatched keys and values";
     }
   };
@@ -522,14 +529,14 @@ namespace gtsam {
     mutable std::string message_;
 
   public:
-    NoMatchFoundForFixed(size_t M1, size_t N1, size_t M2, size_t N2) throw () :
+    NoMatchFoundForFixed(size_t M1, size_t N1, size_t M2, size_t N2) noexcept :
         M1_(M1), N1_(N1), M2_(M2), N2_(N2) {
     }
 
-    virtual ~NoMatchFoundForFixed() throw () {
+    virtual ~NoMatchFoundForFixed() noexcept {
     }
 
-    GTSAM_EXPORT virtual const char* what() const throw ();
+    GTSAM_EXPORT const char* what() const noexcept override;
   };
 
   /* ************************************************************************* */
--- gtsam-4.0.3.orig/gtsam/nonlinear/WhiteNoiseFactor.h
+++ gtsam-4.0.3/gtsam/nonlinear/WhiteNoiseFactor.h
@@ -109,7 +109,7 @@ namespace gtsam {
 
     /// Print
     void print(const std::string& p = "WhiteNoiseFactor",
-        const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+        const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       Base::print(p, keyFormatter);
       std::cout << p + ".z: " << z_ << std::endl;
     }
@@ -119,12 +119,12 @@ namespace gtsam {
     /// @{
 
     /// get the dimension of the factor (number of rows on linearization)
-    virtual size_t dim() const {
+    size_t dim() const override {
       return 2;
     }
 
     /// Calculate the error of the factor, typically equal to log-likelihood
-    inline double error(const Values& x) const {
+    double error(const Values& x) const override {
       return f(z_, x.at<double>(meanKey_), x.at<double>(precisionKey_));
     }
 
@@ -153,7 +153,7 @@ namespace gtsam {
     /// @{
 
     /// linearize returns a Hessianfactor that is an approximation of error(p)
-    virtual boost::shared_ptr<GaussianFactor> linearize(const Values& x) const {
+    boost::shared_ptr<GaussianFactor> linearize(const Values& x) const override {
       double u = x.at<double>(meanKey_);
       double p = x.at<double>(precisionKey_);
       Key j1 = meanKey_;
@@ -163,7 +163,7 @@ namespace gtsam {
 
     // TODO: Frank commented this out for now, can it go?
     //    /// @return a deep copy of this factor
-    //    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    //    gtsam::NonlinearFactor::shared_ptr clone() const override {
     //      return boost::static_pointer_cast<gtsam::NonlinearFactor>(
     //          gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
--- gtsam-4.0.3.orig/gtsam/nonlinear/internal/CallRecord.h
+++ gtsam-4.0.3/gtsam/nonlinear/internal/CallRecord.h
@@ -144,43 +144,43 @@ private:
     return static_cast<const Derived&>(*this);
   }
 
-  virtual void _print(const std::string& indent) const {
+  void _print(const std::string& indent) const override {
     derived().print(indent);
   }
 
   // Called from base class non-virtual inline method startReverseAD2
   // Calls non-virtual function startReverseAD4, implemented in Derived (ExpressionNode::Record)
-  virtual void _startReverseAD3(JacobianMap& jacobians) const {
+  void _startReverseAD3(JacobianMap& jacobians) const override {
     derived().startReverseAD4(jacobians);
   }
 
-  virtual void _reverseAD3(const Matrix & dFdT, JacobianMap& jacobians) const {
+  void _reverseAD3(const Matrix & dFdT, JacobianMap& jacobians) const override {
     derived().reverseAD4(dFdT, jacobians);
   }
 
-  virtual void _reverseAD3(
+  void _reverseAD3(
       const Eigen::Matrix<double, Eigen::Dynamic, Cols> & dFdT,
-      JacobianMap& jacobians) const {
+      JacobianMap& jacobians) const override {
     derived().reverseAD4(dFdT, jacobians);
   }
-  virtual void _reverseAD3(const Eigen::Matrix<double, 1, Cols> & dFdT,
-      JacobianMap& jacobians) const {
+  void _reverseAD3(const Eigen::Matrix<double, 1, Cols> & dFdT,
+      JacobianMap& jacobians) const override {
     derived().reverseAD4(dFdT, jacobians);
   }
-  virtual void _reverseAD3(const Eigen::Matrix<double, 2, Cols> & dFdT,
-      JacobianMap& jacobians) const {
+  void _reverseAD3(const Eigen::Matrix<double, 2, Cols> & dFdT,
+      JacobianMap& jacobians) const override {
     derived().reverseAD4(dFdT, jacobians);
   }
-  virtual void _reverseAD3(const Eigen::Matrix<double, 3, Cols> & dFdT,
-      JacobianMap& jacobians) const {
+  void _reverseAD3(const Eigen::Matrix<double, 3, Cols> & dFdT,
+      JacobianMap& jacobians) const override {
     derived().reverseAD4(dFdT, jacobians);
   }
-  virtual void _reverseAD3(const Eigen::Matrix<double, 4, Cols> & dFdT,
-      JacobianMap& jacobians) const {
+  void _reverseAD3(const Eigen::Matrix<double, 4, Cols> & dFdT,
+      JacobianMap& jacobians) const override {
     derived().reverseAD4(dFdT, jacobians);
   }
-  virtual void _reverseAD3(const Eigen::Matrix<double, 5, Cols> & dFdT,
-      JacobianMap& jacobians) const {
+  void _reverseAD3(const Eigen::Matrix<double, 5, Cols> & dFdT,
+      JacobianMap& jacobians) const override {
     derived().reverseAD4(dFdT, jacobians);
   }
 };
--- gtsam-4.0.3.orig/gtsam/nonlinear/internal/ExpressionNode.h
+++ gtsam-4.0.3/gtsam/nonlinear/internal/ExpressionNode.h
@@ -135,18 +135,18 @@ public:
   }
 
   /// Print
-  virtual void print(const std::string& indent = "") const {
+  void print(const std::string& indent = "") const override {
     std::cout << indent << "Constant" << std::endl;
   }
 
   /// Return value
-  virtual T value(const Values& values) const {
+  T value(const Values& values) const override {
     return constant_;
   }
 
   /// Construct an execution trace for reverse AD
-  virtual T traceExecution(const Values& values, ExecutionTrace<T>& trace,
-      ExecutionTraceStorage* traceStorage) const {
+  T traceExecution(const Values& values, ExecutionTrace<T>& trace,
+      ExecutionTraceStorage* traceStorage) const override {
     return constant_;
   }
 
@@ -176,30 +176,30 @@ public:
   }
 
   /// Print
-  virtual void print(const std::string& indent = "") const {
+  void print(const std::string& indent = "") const override {
     std::cout << indent << "Leaf, key = " << DefaultKeyFormatter(key_) << std::endl;
   }
 
   /// Return keys that play in this expression
-  virtual std::set<Key> keys() const {
+  std::set<Key> keys() const override {
     std::set<Key> keys;
     keys.insert(key_);
     return keys;
   }
 
   /// Return dimensions for each argument
-  virtual void dims(std::map<Key, int>& map) const {
+  void dims(std::map<Key, int>& map) const override {
     map[key_] = traits<T>::dimension;
   }
 
   /// Return value
-  virtual T value(const Values& values) const {
+  T value(const Values& values) const override {
     return values.at<T>(key_);
   }
 
   /// Construct an execution trace for reverse AD
-  virtual T traceExecution(const Values& values, ExecutionTrace<T>& trace,
-      ExecutionTraceStorage* traceStorage) const {
+  T traceExecution(const Values& values, ExecutionTrace<T>& trace,
+      ExecutionTraceStorage* traceStorage) const override {
     trace.setLeaf(key_);
     return values.at<T>(key_);
   }
@@ -248,23 +248,23 @@ public:
   }
 
   /// Print
-  virtual void print(const std::string& indent = "") const {
+  void print(const std::string& indent = "") const override {
     std::cout << indent << "UnaryExpression" << std::endl;
     expression1_->print(indent + "  ");
   }
 
   /// Return value
-  virtual T value(const Values& values) const {
+  T value(const Values& values) const override {
     return function_(expression1_->value(values), boost::none);
   }
 
   /// Return keys that play in this expression
-  virtual std::set<Key> keys() const {
+  std::set<Key> keys() const override {
     return expression1_->keys();
   }
 
   /// Return dimensions for each argument
-  virtual void dims(std::map<Key, int>& map) const {
+  void dims(std::map<Key, int>& map) const override {
     expression1_->dims(map);
   }
 
@@ -307,8 +307,8 @@ public:
   };
 
   /// Construct an execution trace for reverse AD
-  virtual T traceExecution(const Values& values, ExecutionTrace<T>& trace,
-      ExecutionTraceStorage* ptr) const {
+  T traceExecution(const Values& values, ExecutionTrace<T>& trace,
+      ExecutionTraceStorage* ptr) const override {
     assert(reinterpret_cast<size_t>(ptr) % TraceAlignment == 0);
 
     // Create a Record in the memory pointed to by ptr
@@ -357,21 +357,21 @@ public:
   }
 
   /// Print
-  virtual void print(const std::string& indent = "") const {
+  void print(const std::string& indent = "") const override {
     std::cout << indent << "BinaryExpression" << std::endl;
     expression1_->print(indent + "  ");
     expression2_->print(indent + "  ");
   }
 
   /// Return value
-  virtual T value(const Values& values) const {
+  T value(const Values& values) const override {
     using boost::none;
     return function_(expression1_->value(values), expression2_->value(values),
         none, none);
   }
 
   /// Return keys that play in this expression
-  virtual std::set<Key> keys() const {
+  std::set<Key> keys() const override {
     std::set<Key> keys = expression1_->keys();
     std::set<Key> myKeys = expression2_->keys();
     keys.insert(myKeys.begin(), myKeys.end());
@@ -379,7 +379,7 @@ public:
   }
 
   /// Return dimensions for each argument
-  virtual void dims(std::map<Key, int>& map) const {
+  void dims(std::map<Key, int>& map) const override {
     expression1_->dims(map);
     expression2_->dims(map);
   }
@@ -426,8 +426,8 @@ public:
   };
 
   /// Construct an execution trace for reverse AD, see UnaryExpression for explanation
-  virtual T traceExecution(const Values& values, ExecutionTrace<T>& trace,
-      ExecutionTraceStorage* ptr) const {
+  T traceExecution(const Values& values, ExecutionTrace<T>& trace,
+      ExecutionTraceStorage* ptr) const override {
     assert(reinterpret_cast<size_t>(ptr) % TraceAlignment == 0);
     Record* record = new (ptr) Record(values, *expression1_, *expression2_, ptr);
     trace.setFunction(record);
@@ -464,7 +464,7 @@ public:
   }
 
   /// Print
-  virtual void print(const std::string& indent = "") const {
+  void print(const std::string& indent = "") const override {
     std::cout << indent << "TernaryExpression" << std::endl;
     expression1_->print(indent + "  ");
     expression2_->print(indent + "  ");
@@ -472,14 +472,14 @@ public:
   }
 
   /// Return value
-  virtual T value(const Values& values) const {
+  T value(const Values& values) const override {
     using boost::none;
     return function_(expression1_->value(values), expression2_->value(values),
         expression3_->value(values), none, none, none);
   }
 
   /// Return keys that play in this expression
-  virtual std::set<Key> keys() const {
+  std::set<Key> keys() const override {
     std::set<Key> keys = expression1_->keys();
     std::set<Key> myKeys = expression2_->keys();
     keys.insert(myKeys.begin(), myKeys.end());
@@ -489,7 +489,7 @@ public:
   }
 
   /// Return dimensions for each argument
-  virtual void dims(std::map<Key, int>& map) const {
+  void dims(std::map<Key, int>& map) const override {
     expression1_->dims(map);
     expression2_->dims(map);
     expression3_->dims(map);
@@ -544,8 +544,8 @@ public:
   };
 
   /// Construct an execution trace for reverse AD, see UnaryExpression for explanation
-  virtual T traceExecution(const Values& values, ExecutionTrace<T>& trace,
-                           ExecutionTraceStorage* ptr) const {
+  T traceExecution(const Values& values, ExecutionTrace<T>& trace,
+                           ExecutionTraceStorage* ptr) const override {
     assert(reinterpret_cast<size_t>(ptr) % TraceAlignment == 0);
     Record* record = new (ptr) Record(values, *expression1_, *expression2_, *expression3_, ptr);
     trace.setFunction(record);
@@ -574,23 +574,23 @@ class ScalarMultiplyNode : public Expres
   virtual ~ScalarMultiplyNode() {}
 
   /// Print
-  virtual void print(const std::string& indent = "") const {
+  void print(const std::string& indent = "") const override {
     std::cout << indent << "ScalarMultiplyNode" << std::endl;
     expression_->print(indent + "  ");
   }
 
   /// Return value
-  virtual T value(const Values& values) const {
+  T value(const Values& values) const override {
     return scalar_ * expression_->value(values);
   }
 
   /// Return keys that play in this expression
-  virtual std::set<Key> keys() const {
+  std::set<Key> keys() const override {
     return expression_->keys();
   }
 
   /// Return dimensions for each argument
-  virtual void dims(std::map<Key, int>& map) const {
+  void dims(std::map<Key, int>& map) const override {
     expression_->dims(map);
   }
 
@@ -624,8 +624,8 @@ class ScalarMultiplyNode : public Expres
   };
 
   /// Construct an execution trace for reverse AD
-  virtual T traceExecution(const Values& values, ExecutionTrace<T>& trace,
-                           ExecutionTraceStorage* ptr) const {
+  T traceExecution(const Values& values, ExecutionTrace<T>& trace,
+                           ExecutionTraceStorage* ptr) const override {
     assert(reinterpret_cast<size_t>(ptr) % TraceAlignment == 0);
     Record* record = new (ptr) Record();
     ptr += upAligned(sizeof(Record));
@@ -662,19 +662,19 @@ class BinarySumNode : public ExpressionN
   virtual ~BinarySumNode() {}
 
   /// Print
-  virtual void print(const std::string& indent = "") const {
+  void print(const std::string& indent = "") const override {
     std::cout << indent << "BinarySumNode" << std::endl;
     expression1_->print(indent + "  ");
     expression2_->print(indent + "  ");
   }
 
   /// Return value
-  virtual T value(const Values& values) const {
+  T value(const Values& values) const override {
     return expression1_->value(values) + expression2_->value(values);
   }
 
   /// Return keys that play in this expression
-  virtual std::set<Key> keys() const {
+  std::set<Key> keys() const override {
     std::set<Key> keys = expression1_->keys();
     std::set<Key> myKeys = expression2_->keys();
     keys.insert(myKeys.begin(), myKeys.end());
@@ -682,7 +682,7 @@ class BinarySumNode : public ExpressionN
   }
 
   /// Return dimensions for each argument
-  virtual void dims(std::map<Key, int>& map) const {
+  void dims(std::map<Key, int>& map) const override {
     expression1_->dims(map);
     expression2_->dims(map);
   }
@@ -717,8 +717,8 @@ class BinarySumNode : public ExpressionN
   };
 
   /// Construct an execution trace for reverse AD
-  virtual T traceExecution(const Values& values, ExecutionTrace<T>& trace,
-                           ExecutionTraceStorage* ptr) const {
+  T traceExecution(const Values& values, ExecutionTrace<T>& trace,
+                           ExecutionTraceStorage* ptr) const override {
     assert(reinterpret_cast<size_t>(ptr) % TraceAlignment == 0);
     Record* record = new (ptr) Record();
     trace.setFunction(record);
--- gtsam-4.0.3.orig/gtsam/nonlinear/nonlinearExceptions.h
+++ gtsam-4.0.3/gtsam/nonlinear/nonlinearExceptions.h
@@ -35,11 +35,11 @@ namespace gtsam {
     KeyFormatter formatter_;
     mutable std::string what_;
   public:
-    MarginalizeNonleafException(Key key, KeyFormatter formatter = DefaultKeyFormatter) throw() :
+    MarginalizeNonleafException(Key key, KeyFormatter formatter = DefaultKeyFormatter) noexcept :
       key_(key), formatter_(formatter) {}
-    virtual ~MarginalizeNonleafException() throw() {}
+    virtual ~MarginalizeNonleafException() noexcept {}
     Key key() const { return key_; }
-    virtual const char* what() const throw() {
+    const char* what() const noexcept override {
       if(what_.empty())
         what_ =
 "\nRequested to marginalize out variable " + formatter_(key_) + ", but this variable\n\
--- gtsam-4.0.3.orig/gtsam/nonlinear/tests/testCallRecord.cpp
+++ gtsam-4.0.3/gtsam/nonlinear/tests/testCallRecord.cpp
@@ -98,7 +98,8 @@ struct Record: public internal::CallReco
   friend struct internal::CallRecordImplementor;
 };
 
-internal::JacobianMap & NJM= *static_cast<internal::JacobianMap *>(nullptr);
+internal::JacobianMap* NJM_ptr = static_cast<internal::JacobianMap *>(nullptr);
+internal::JacobianMap & NJM = *NJM_ptr;
 
 /* ************************************************************************* */
 typedef Eigen::Matrix<double, Eigen::Dynamic, Cols> DynRowMat;
--- gtsam-4.0.3.orig/gtsam/nonlinear/tests/testFunctorizedFactor.cpp
+++ gtsam-4.0.3/gtsam/nonlinear/tests/testFunctorizedFactor.cpp
@@ -131,7 +131,7 @@ TEST(FunctorizedFactor, Print) {
       "FunctorizedFactor(X0)\n"
       "  measurement: [\n"
       "	1, 0;\n"
-      " 	0, 1\n"
+      "	0, 1\n"
       "]\n"
       "  noise model sigmas: 1 1 1 1 1 1 1 1 1\n";
 
--- gtsam-4.0.3.orig/gtsam/nonlinear/tests/testValues.cpp
+++ gtsam-4.0.3/gtsam/nonlinear/tests/testValues.cpp
@@ -593,7 +593,7 @@ TEST(Values, Demangle) {
   Values values;
   Matrix13 v; v << 5.0, 6.0, 7.0;
   values.insert(key1, v);
-  string expected = "Values with 1 values:\nValue v1: (Eigen::Matrix<double, 1, 3, 1, 1, 3>) [\n	5, 6, 7\n]\n\n";
+  string expected = "Values with 1 values:\nValue v1: (Eigen::Matrix<double, 1, 3, 1, 1, 3>)\n[\n	5, 6, 7\n]\n\n";
 
   stringstream buffer;
   streambuf * old = cout.rdbuf(buffer.rdbuf());
@@ -607,5 +607,35 @@ TEST(Values, Demangle) {
 }
 
 /* ************************************************************************* */
+TEST(Values, brace_initializer) {
+  const Pose2 poseA(1.0, 2.0, 0.3), poseC(.0, .0, .0);
+  const Pose3 poseB(Pose2(0.1, 0.2, 0.3));
+
+  {
+    Values values;
+    EXPECT_LONGS_EQUAL(0, values.size());
+    values = { {key1, genericValue(1.0)} };
+    EXPECT_LONGS_EQUAL(1, values.size());
+    CHECK(values.at<double>(key1) == 1.0);
+  }
+  {
+    Values values = { {key1, genericValue(poseA)}, {key2, genericValue(poseB)} };
+    EXPECT_LONGS_EQUAL(2, values.size());
+    EXPECT(assert_equal(values.at<Pose2>(key1), poseA));
+    EXPECT(assert_equal(values.at<Pose3>(key2), poseB));
+  }
+  // Test exception: duplicated key:
+  {
+    Values values;
+    CHECK_EXCEPTION((values = {
+      {key1, genericValue(poseA)},
+      {key2, genericValue(poseB)},
+      {key1, genericValue(poseC)} 
+      }), std::exception);
+  }
+}
+
+
+/* ************************************************************************* */
 int main() { TestResult tr; return TestRegistry::runAllTests(tr); }
 /* ************************************************************************* */
--- gtsam-4.0.3.orig/gtsam/sam/BearingFactor.h
+++ gtsam-4.0.3/gtsam/sam/BearingFactor.h
@@ -34,8 +34,8 @@ struct Bearing;
  */
 template <typename A1, typename A2,
           typename T = typename Bearing<A1, A2>::result_type>
-struct BearingFactor : public ExpressionFactor2<T, A1, A2> {
-  typedef ExpressionFactor2<T, A1, A2> Base;
+struct BearingFactor : public ExpressionFactorN<T, A1, A2> {
+  typedef ExpressionFactorN<T, A1, A2> Base;
 
   /// default constructor
   BearingFactor() {}
@@ -43,23 +43,38 @@ struct BearingFactor : public Expression
   /// primary constructor
   BearingFactor(Key key1, Key key2, const T& measured,
                 const SharedNoiseModel& model)
-      : Base(key1, key2, model, measured) {
-    this->initialize(expression(key1, key2));
+      : Base({key1, key2}, model, measured) {
+    this->initialize(expression({key1, key2}));
   }
 
   // Return measurement expression
-  virtual Expression<T> expression(Key key1, Key key2) const {
-    Expression<A1> a1_(key1);
-    Expression<A2> a2_(key2);
+  Expression<T> expression(const typename Base::ArrayNKeys &keys) const override {
+    Expression<A1> a1_(keys[0]);
+    Expression<A2> a2_(keys[1]);
     return Expression<T>(Bearing<A1, A2>(), a1_, a2_);
   }
 
   /// print
   void print(const std::string& s = "",
-             const KeyFormatter& kf = DefaultKeyFormatter) const {
+             const KeyFormatter& kf = DefaultKeyFormatter) const override {
     std::cout << s << "BearingFactor" << std::endl;
     Base::print(s, kf);
   }
+  
+  Vector evaluateError(const A1& a1, const A2& a2,
+    boost::optional<Matrix&> H1 = boost::none,
+    boost::optional<Matrix&> H2 = boost::none) const
+  {
+    std::vector<Matrix> Hs(2);
+    const auto &keys = Factor::keys();
+    const Vector error = unwhitenedError(
+      {{keys[0], genericValue(a1)}, {keys[1], genericValue(a2)}}, 
+      Hs);
+    if (H1) *H1 = Hs[0];
+    if (H2) *H2 = Hs[1];
+    return error;
+  }
+
 
  private:
   friend class boost::serialization::access;
--- gtsam-4.0.3.orig/gtsam/sam/BearingRangeFactor.h
+++ gtsam-4.0.3/gtsam/sam/BearingRangeFactor.h
@@ -33,10 +33,10 @@ template <typename A1, typename A2,
           typename B = typename Bearing<A1, A2>::result_type,
           typename R = typename Range<A1, A2>::result_type>
 class BearingRangeFactor
-    : public ExpressionFactor2<BearingRange<A1, A2>, A1, A2> {
+    : public ExpressionFactorN<BearingRange<A1, A2>, A1, A2> {
  private:
   typedef BearingRange<A1, A2> T;
-  typedef ExpressionFactor2<T, A1, A2> Base;
+  typedef ExpressionFactorN<T, A1, A2> Base;
   typedef BearingRangeFactor<A1, A2> This;
 
  public:
@@ -48,27 +48,41 @@ class BearingRangeFactor
   /// primary constructor
   BearingRangeFactor(Key key1, Key key2, const B& measuredBearing,
                      const R& measuredRange, const SharedNoiseModel& model)
-      : Base(key1, key2, model, T(measuredBearing, measuredRange)) {
-    this->initialize(expression(key1, key2));
+      : Base({key1, key2}, model, T(measuredBearing, measuredRange)) {
+    this->initialize(expression({key1, key2}));
   }
 
   virtual ~BearingRangeFactor() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   // Return measurement expression
-  virtual Expression<T> expression(Key key1, Key key2) const {
-    return Expression<T>(T::Measure, Expression<A1>(key1),
-                         Expression<A2>(key2));
+  Expression<T> expression(const typename Base::ArrayNKeys& keys) const override {
+    return Expression<T>(T::Measure, Expression<A1>(keys[0]),
+                         Expression<A2>(keys[1]));
+  }
+
+  Vector evaluateError(const A1& a1, const A2& a2,
+      boost::optional<Matrix&> H1 = boost::none,
+      boost::optional<Matrix&> H2 = boost::none) const
+  {
+    std::vector<Matrix> Hs(2);
+    const auto &keys = Factor::keys();
+    const Vector error = unwhitenedError(
+      {{keys[0], genericValue(a1)}, {keys[1], genericValue(a2)}}, 
+      Hs);
+    if (H1) *H1 = Hs[0];
+    if (H2) *H2 = Hs[1];
+    return error;
   }
 
   /// print
-  virtual void print(const std::string& s = "",
-                     const KeyFormatter& kf = DefaultKeyFormatter) const {
+  void print(const std::string& s = "",
+                     const KeyFormatter& kf = DefaultKeyFormatter) const override {
     std::cout << s << "BearingRangeFactor" << std::endl;
     Base::print(s, kf);
   }
--- gtsam-4.0.3.orig/gtsam/sam/RangeFactor.h
+++ gtsam-4.0.3/gtsam/sam/RangeFactor.h
@@ -32,36 +32,50 @@ struct Range;
  * @addtogroup SAM
  */
 template <typename A1, typename A2 = A1, typename T = double>
-class RangeFactor : public ExpressionFactor2<T, A1, A2> {
+class RangeFactor : public ExpressionFactorN<T, A1, A2> {
  private:
   typedef RangeFactor<A1, A2> This;
-  typedef ExpressionFactor2<T, A1, A2> Base;
+  typedef ExpressionFactorN<T, A1, A2> Base;
 
  public:
   /// default constructor
   RangeFactor() {}
 
   RangeFactor(Key key1, Key key2, T measured, const SharedNoiseModel& model)
-      : Base(key1, key2, model, measured) {
-    this->initialize(expression(key1, key2));
+      : Base({key1, key2}, model, measured) {
+    this->initialize(expression({key1, key2}));
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   // Return measurement expression
-  virtual Expression<T> expression(Key key1, Key key2) const {
-    Expression<A1> a1_(key1);
-    Expression<A2> a2_(key2);
+  Expression<T> expression(const typename Base::ArrayNKeys& keys) const override {
+    Expression<A1> a1_(keys[0]);
+    Expression<A2> a2_(keys[1]);
     return Expression<T>(Range<A1, A2>(), a1_, a2_);
   }
+  
+  Vector evaluateError(const A1& a1, const A2& a2,
+      boost::optional<Matrix&> H1 = boost::none,
+      boost::optional<Matrix&> H2 = boost::none) const
+  {
+    std::vector<Matrix> Hs(2);
+    const auto &keys = Factor::keys();
+    const Vector error = Base::unwhitenedError(
+      {{keys[0], genericValue(a1)}, {keys[1], genericValue(a2)}}, 
+      Hs);
+    if (H1) *H1 = Hs[0];
+    if (H2) *H2 = Hs[1];
+    return error;
+  }
 
   /// print
   void print(const std::string& s = "",
-             const KeyFormatter& kf = DefaultKeyFormatter) const {
+             const KeyFormatter& kf = DefaultKeyFormatter) const override {
     std::cout << s << "RangeFactor" << std::endl;
     Base::print(s, kf);
   }
@@ -86,10 +100,10 @@ struct traits<RangeFactor<A1, A2, T> >
  */
 template <typename A1, typename A2 = A1,
           typename T = typename Range<A1, A2>::result_type>
-class RangeFactorWithTransform : public ExpressionFactor2<T, A1, A2> {
+class RangeFactorWithTransform : public ExpressionFactorN<T, A1, A2> {
  private:
   typedef RangeFactorWithTransform<A1, A2> This;
-  typedef ExpressionFactor2<T, A1, A2> Base;
+  typedef ExpressionFactorN<T, A1, A2> Base;
 
   A1 body_T_sensor_;  ///< The pose of the sensor in the body frame
 
@@ -100,31 +114,45 @@ class RangeFactorWithTransform : public
   RangeFactorWithTransform(Key key1, Key key2, T measured,
                            const SharedNoiseModel& model,
                            const A1& body_T_sensor)
-      : Base(key1, key2, model, measured), body_T_sensor_(body_T_sensor) {
-    this->initialize(expression(key1, key2));
+      : Base({key1, key2}, model, measured), body_T_sensor_(body_T_sensor) {
+    this->initialize(expression({key1, key2}));
   }
 
   virtual ~RangeFactorWithTransform() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   // Return measurement expression
-  virtual Expression<T> expression(Key key1, Key key2) const {
+  Expression<T> expression(const typename Base::ArrayNKeys& keys) const override {
     Expression<A1> body_T_sensor__(body_T_sensor_);
-    Expression<A1> nav_T_body_(key1);
+    Expression<A1> nav_T_body_(keys[0]);
     Expression<A1> nav_T_sensor_(traits<A1>::Compose, nav_T_body_,
                                  body_T_sensor__);
-    Expression<A2> a2_(key2);
+    Expression<A2> a2_(keys[1]);
     return Expression<T>(Range<A1, A2>(), nav_T_sensor_, a2_);
   }
 
+  Vector evaluateError(const A1& a1, const A2& a2,
+      boost::optional<Matrix&> H1 = boost::none,
+      boost::optional<Matrix&> H2 = boost::none) const
+  {
+    std::vector<Matrix> Hs(2);
+    const auto &keys = Factor::keys();
+    const Vector error = Base::unwhitenedError(
+      {{keys[0], genericValue(a1)}, {keys[1], genericValue(a2)}}, 
+      Hs);
+    if (H1) *H1 = Hs[0];
+    if (H2) *H2 = Hs[1];
+    return error;
+  }
+
   /** print contents */
   void print(const std::string& s = "",
-             const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+             const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << "RangeFactorWithTransform" << std::endl;
     this->body_T_sensor_.print("  sensor pose in body frame: ");
     Base::print(s, keyFormatter);
@@ -135,9 +163,12 @@ class RangeFactorWithTransform : public
   friend class boost::serialization::access;
   template <typename ARCHIVE>
   void serialize(ARCHIVE& ar, const unsigned int /*version*/) {
+    // **IMPORTANT** We need to (de)serialize parameters before the base class,
+    // since it calls expression() and we need all parameters ready at that
+    // point.
+    ar& BOOST_SERIALIZATION_NVP(body_T_sensor_);
     ar& boost::serialization::make_nvp(
         "Base", boost::serialization::base_object<Base>(*this));
-    ar& BOOST_SERIALIZATION_NVP(body_T_sensor_);
   }
 };  // \ RangeFactorWithTransform
 
--- gtsam-4.0.3.orig/gtsam/sam/tests/testBearingFactor.cpp
+++ gtsam-4.0.3/gtsam/sam/tests/testBearingFactor.cpp
@@ -68,7 +68,7 @@ TEST(BearingFactor, 2D) {
   values.insert(poseKey, Pose2(1.0, 2.0, 0.57));
   values.insert(pointKey, Point2(-4.0, 11.0));
 
-  EXPECT_CORRECT_EXPRESSION_JACOBIANS(factor.expression(poseKey, pointKey),
+  EXPECT_CORRECT_EXPRESSION_JACOBIANS(factor.expression({poseKey, pointKey}),
                                       values, 1e-7, 1e-5);
   EXPECT_CORRECT_FACTOR_JACOBIANS(factor, values, 1e-7, 1e-5);
 }
@@ -104,7 +104,7 @@ TEST(BearingFactor, Serialization3D) {
 //  values.insert(poseKey, Pose3());
 //  values.insert(pointKey, Point3(1, 0, 0));
 //
-//  EXPECT_CORRECT_EXPRESSION_JACOBIANS(factor.expression(poseKey, pointKey),
+//  EXPECT_CORRECT_EXPRESSION_JACOBIANS(factor.expression({poseKey, pointKey}),
 //                                      values, 1e-7, 1e-5);
 //  EXPECT_CORRECT_FACTOR_JACOBIANS(factor, values, 1e-7, 1e-5);
 //}
--- gtsam-4.0.3.orig/gtsam/sam/tests/testBearingRangeFactor.cpp
+++ gtsam-4.0.3/gtsam/sam/tests/testBearingRangeFactor.cpp
@@ -67,7 +67,7 @@ TEST(BearingRangeFactor, 2D) {
   values.insert(poseKey, Pose2(1.0, 2.0, 0.57));
   values.insert(pointKey, Point2(-4.0, 11.0));
 
-  EXPECT_CORRECT_EXPRESSION_JACOBIANS(factor.expression(poseKey, pointKey),
+  EXPECT_CORRECT_EXPRESSION_JACOBIANS(factor.expression({poseKey, pointKey}),
                                       values, 1e-7, 1e-5);
   EXPECT_CORRECT_FACTOR_JACOBIANS(factor, values, 1e-7, 1e-5);
 }
@@ -95,7 +95,7 @@ TEST(BearingRangeFactor, Serialization3D
 //  values.insert(poseKey, Pose3());
 //  values.insert(pointKey, Point3(1, 0, 0));
 //
-//  EXPECT_CORRECT_EXPRESSION_JACOBIANS(factor.expression(poseKey, pointKey),
+//  EXPECT_CORRECT_EXPRESSION_JACOBIANS(factor.expression({poseKey, pointKey}),
 //                                      values, 1e-7, 1e-5);
 //  EXPECT_CORRECT_FACTOR_JACOBIANS(factor, values, 1e-7, 1e-5);
 //}
--- gtsam-4.0.3.orig/gtsam/sam/tests/testRangeFactor.cpp
+++ gtsam-4.0.3/gtsam/sam/tests/testRangeFactor.cpp
@@ -141,6 +141,27 @@ TEST( RangeFactor, EqualsWithTransform )
       body_P_sensor_3D);
   CHECK(assert_equal(factor3D_1, factor3D_2));
 }
+/* ************************************************************************* */
+TEST( RangeFactor, EqualsAfterDeserializing) {
+  // Check that the same results are obtained after deserializing:
+  Pose3 body_P_sensor_3D(Rot3::RzRyRx(-M_PI_2, 0.0, -M_PI_2),
+      Point3(0.25, -0.10, 1.0));
+
+  RangeFactorWithTransform3D factor3D_1(poseKey, pointKey, measurement, model,
+      body_P_sensor_3D), factor3D_2;
+
+  // check with Equal() trait:
+  gtsam::serializationTestHelpers::roundtripXML(factor3D_1, factor3D_2);
+  CHECK(assert_equal(factor3D_1, factor3D_2));
+
+  const Pose3 pose(Rot3::RzRyRx(0.2, -0.3, 1.75), Point3(1.0, 2.0, -3.0));
+  const Point3 point(-2.0, 11.0, 1.0);
+  const Values values = {{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}};
+  
+  const Vector error_1 = factor3D_1.unwhitenedError(values);
+  const Vector error_2 = factor3D_2.unwhitenedError(values);
+  CHECK(assert_equal(error_1, error_2));
+}
 
 /* ************************************************************************* */
 TEST( RangeFactor, Error2D ) {
@@ -152,7 +173,7 @@ TEST( RangeFactor, Error2D ) {
   Point2 point(-4.0, 11.0);
 
   // Use the factor to calculate the error
-  Vector actualError(factor.evaluateError(pose, point));
+  Vector actualError(factor.unwhitenedError({{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}}));
 
   // The expected error is ||(5.0, 9.0)|| - 10.0 = 0.295630141 meter / UnitCovariance
   Vector expectedError = (Vector(1) << 0.295630141).finished();
@@ -175,7 +196,7 @@ TEST( RangeFactor, Error2DWithTransform
   Point2 point(-4.0, 11.0);
 
   // Use the factor to calculate the error
-  Vector actualError(factor.evaluateError(pose, point));
+  Vector actualError(factor.unwhitenedError({{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}}));
 
   // The expected error is ||(5.0, 9.0)|| - 10.0 = 0.295630141 meter / UnitCovariance
   Vector expectedError = (Vector(1) << 0.295630141).finished();
@@ -194,7 +215,7 @@ TEST( RangeFactor, Error3D ) {
   Point3 point(-2.0, 11.0, 1.0);
 
   // Use the factor to calculate the error
-  Vector actualError(factor.evaluateError(pose, point));
+  Vector actualError(factor.unwhitenedError({{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}}));
 
   // The expected error is ||(3.0, 9.0, 4.0)|| - 10.0 = 0.295630141 meter / UnitCovariance
   Vector expectedError = (Vector(1) << 0.295630141).finished();
@@ -218,7 +239,7 @@ TEST( RangeFactor, Error3DWithTransform
   Point3 point(-2.0, 11.0, 1.0);
 
   // Use the factor to calculate the error
-  Vector actualError(factor.evaluateError(pose, point));
+  Vector actualError(factor.unwhitenedError({{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}}));
 
   // The expected error is ||(3.0, 9.0, 4.0)|| - 10.0 = 0.295630141 meter / UnitCovariance
   Vector expectedError = (Vector(1) << 0.295630141).finished();
@@ -266,8 +287,10 @@ TEST( RangeFactor, Jacobian2DWithTransfo
   Point2 point(-4.0, 11.0);
 
   // Use the factor to calculate the Jacobians
-  Matrix H1Actual, H2Actual;
-  factor.evaluateError(pose, point, H1Actual, H2Actual);
+  std::vector<Matrix> actualHs(2);
+  factor.unwhitenedError({{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}}, actualHs); 
+  const Matrix& H1Actual = actualHs.at(0);
+  const Matrix& H2Actual = actualHs.at(1);
 
   // Use numerical derivatives to calculate the Jacobians
   Matrix H1Expected, H2Expected;
@@ -291,8 +314,10 @@ TEST( RangeFactor, Jacobian3D ) {
   Point3 point(-2.0, 11.0, 1.0);
 
   // Use the factor to calculate the Jacobians
-  Matrix H1Actual, H2Actual;
-  factor.evaluateError(pose, point, H1Actual, H2Actual);
+  std::vector<Matrix> actualHs(2);
+  factor.unwhitenedError({{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}}, actualHs); 
+  const Matrix& H1Actual = actualHs.at(0);
+  const Matrix& H2Actual = actualHs.at(1);
 
   // Use numerical derivatives to calculate the Jacobians
   Matrix H1Expected, H2Expected;
@@ -321,8 +346,10 @@ TEST( RangeFactor, Jacobian3DWithTransfo
   Point3 point(-2.0, 11.0, 1.0);
 
   // Use the factor to calculate the Jacobians
-  Matrix H1Actual, H2Actual;
-  factor.evaluateError(pose, point, H1Actual, H2Actual);
+  std::vector<Matrix> actualHs(2);
+  factor.unwhitenedError({{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}}, actualHs); 
+  const Matrix& H1Actual = actualHs.at(0);
+  const Matrix& H2Actual = actualHs.at(1);
 
   // Use numerical derivatives to calculate the Jacobians
   Matrix H1Expected, H2Expected;
@@ -350,7 +377,7 @@ TEST(RangeFactor, Point3) {
   Vector expectedError = (Vector(1) << 0.295630141).finished();
 
   // Verify we get the expected error
-  CHECK(assert_equal(expectedError, factor.evaluateError(pose, point), 1e-9));
+  CHECK(assert_equal(expectedError, factor.unwhitenedError({{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}}), 1e-9));
 }
 
 /* ************************************************************************* */
@@ -393,7 +420,7 @@ TEST(RangeFactor, NonGTSAM) {
   Vector expectedError = (Vector(1) << 0.295630141).finished();
 
   // Verify we get the expected error
-  CHECK(assert_equal(expectedError, factor.evaluateError(pose, point), 1e-9));
+  CHECK(assert_equal(expectedError, factor.unwhitenedError({{poseKey, genericValue(pose)}, {pointKey, genericValue(point)}}), 1e-9));
 }
 
 /* ************************************************************************* */
--- gtsam-4.0.3.orig/gtsam/slam/AntiFactor.h
+++ gtsam-4.0.3/gtsam/slam/AntiFactor.h
@@ -52,20 +52,20 @@ namespace gtsam {
     virtual ~AntiFactor() {}
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
     /** implement functions needed for Testable */
 
     /** print */
-    virtual void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "AntiFactor version of:" << std::endl;
       factor_->print(s, keyFormatter);
     }
 
     /** equals */
-    virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+    bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
       const This *e =  dynamic_cast<const This*> (&expected);
       return e != nullptr && Base::equals(*e, tol) && this->factor_->equals(*e->factor_, tol);
     }
@@ -77,16 +77,16 @@ namespace gtsam {
      * For the AntiFactor, this will have the same magnitude of the original factor,
      * but the opposite sign.
      */
-    double error(const Values& c) const { return -factor_->error(c); }
+    double error(const Values& c) const override { return -factor_->error(c); }
 
     /** get the dimension of the factor (same as the original factor) */
-    size_t dim() const { return factor_->dim(); }
+    size_t dim() const override { return factor_->dim(); }
 
     /**
      * Checks whether this factor should be used based on a set of values.
      * The AntiFactor will have the same 'active' profile as the original factor.
      */
-    bool active(const Values& c) const { return factor_->active(c); }
+    bool active(const Values& c) const override { return factor_->active(c); }
 
     /**
      * Linearize to a GaussianFactor. The AntiFactor always returns a Hessian Factor
@@ -94,7 +94,7 @@ namespace gtsam {
      * returns a Jacobian instead of a full Hessian), but with the opposite sign. This
      * effectively cancels the effect of the original factor on the factor graph.
      */
-    boost::shared_ptr<GaussianFactor> linearize(const Values& c) const {
+    boost::shared_ptr<GaussianFactor> linearize(const Values& c) const override {
 
       // Generate the linearized factor from the contained nonlinear factor
       GaussianFactor::shared_ptr gaussianFactor = factor_->linearize(c);
--- gtsam-4.0.3.orig/gtsam/slam/BetweenFactor.h
+++ gtsam-4.0.3/gtsam/slam/BetweenFactor.h
@@ -63,14 +63,16 @@ namespace gtsam {
     virtual ~BetweenFactor() {}
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
-    /** implement functions needed for Testable */
+    /// @}
+    /// @name Testable
+    /// @{
 
-    /** print */
-    virtual void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    /// print with optional string
+    void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "BetweenFactor("
           << keyFormatter(this->key1()) << ","
           << keyFormatter(this->key2()) << ")\n";
@@ -78,17 +80,19 @@ namespace gtsam {
       this->noiseModel_->print("  noise model: ");
     }
 
-    /** equals */
-    virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+    /// assert equality up to a tolerance
+    bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
       const This *e =  dynamic_cast<const This*> (&expected);
       return e != nullptr && Base::equals(*e, tol) && traits<T>::Equals(this->measured_, e->measured_, tol);
     }
 
-    /** implement functions needed to derive from Factor */
-
-    /** vector of errors */
-  Vector evaluateError(const T& p1, const T& p2, boost::optional<Matrix&> H1 =
-      boost::none, boost::optional<Matrix&> H2 = boost::none) const {
+    /// @}
+    /// @name NoiseModelFactor2 methods 
+    /// @{
+
+    /// evaluate error, returns vector of errors size of tangent space
+    Vector evaluateError(const T& p1, const T& p2, boost::optional<Matrix&> H1 =
+      boost::none, boost::optional<Matrix&> H2 = boost::none) const override {
       T hx = traits<T>::Between(p1, p2, H1, H2); // h(x)
       // manifold equivalent of h(x)-z -> log(z,h(x))
 #ifdef SLOW_BUT_CORRECT_BETWEENFACTOR
@@ -102,15 +106,15 @@ namespace gtsam {
 #endif
     }
 
-    /** return the measured */
+    /// @}
+    /// @name Standard interface 
+    /// @{
+
+    /// return the measurement
     const VALUE& measured() const {
       return measured_;
     }
-
-    /** number of variables attached to this factor */
-    std::size_t size() const {
-      return 2;
-    }
+    /// @}
 
   private:
 
--- gtsam-4.0.3.orig/gtsam/slam/BoundingConstraint.h
+++ gtsam-4.0.3/gtsam/slam/BoundingConstraint.h
@@ -58,14 +58,14 @@ struct BoundingConstraint1: public Noise
       boost::none) const = 0;
 
   /** active when constraint *NOT* met */
-  bool active(const Values& c) const {
+  bool active(const Values& c) const override {
     // note: still active at equality to avoid zigzagging
     double x = value(c.at<X>(this->key()));
     return (isGreaterThan_) ? x <= threshold_ : x >= threshold_;
   }
 
   Vector evaluateError(const X& x, boost::optional<Matrix&> H =
-      boost::none) const {
+      boost::none) const override {
     Matrix D;
     double error = value(x, D) - threshold_;
     if (H) {
@@ -126,7 +126,7 @@ struct BoundingConstraint2: public Noise
       boost::optional<Matrix&> H2 = boost::none) const = 0;
 
   /** active when constraint *NOT* met */
-  bool active(const Values& c) const {
+  bool active(const Values& c) const override {
     // note: still active at equality to avoid zigzagging
     double x = value(c.at<X1>(this->key1()), c.at<X2>(this->key2()));
     return (isGreaterThan_) ? x <= threshold_ : x >= threshold_;
@@ -134,7 +134,7 @@ struct BoundingConstraint2: public Noise
 
   Vector evaluateError(const X1& x1, const X2& x2,
       boost::optional<Matrix&> H1 = boost::none,
-      boost::optional<Matrix&> H2 = boost::none) const {
+      boost::optional<Matrix&> H2 = boost::none) const override {
     Matrix D1, D2;
     double error = value(x1, x2, D1, D2) - threshold_;
     if (H1) {
--- gtsam-4.0.3.orig/gtsam/slam/EssentialMatrixConstraint.h
+++ gtsam-4.0.3/gtsam/slam/EssentialMatrixConstraint.h
@@ -61,7 +61,7 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
@@ -69,29 +69,24 @@ public:
   /** implement functions needed for Testable */
 
   /** print */
-  virtual void print(const std::string& s = "",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s = "",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** equals */
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
 
   /** implement functions needed to derive from Factor */
 
   /** vector of errors */
-  virtual Vector evaluateError(const Pose3& p1, const Pose3& p2,
+  Vector evaluateError(const Pose3& p1, const Pose3& p2,
       boost::optional<Matrix&> Hp1 = boost::none, //
-      boost::optional<Matrix&> Hp2 = boost::none) const;
+      boost::optional<Matrix&> Hp2 = boost::none) const override;
 
   /** return the measured */
   const EssentialMatrix& measured() const {
     return measuredE_;
   }
 
-  /** number of variables attached to this factor */
-  std::size_t size() const {
-    return 2;
-  }
-
 private:
 
   /** Serialization function */
--- gtsam-4.0.3.orig/gtsam/slam/EssentialMatrixFactor.h
+++ gtsam-4.0.3/gtsam/slam/EssentialMatrixFactor.h
@@ -58,14 +58,14 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   /// print
-  virtual void print(const std::string& s = "",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s);
     std::cout << "  EssentialMatrixFactor with measurements\n  ("
         << vA_.transpose() << ")' and (" << vB_.transpose() << ")'"
@@ -74,7 +74,7 @@ public:
 
   /// vector of errors returns 1D vector
   Vector evaluateError(const EssentialMatrix& E, boost::optional<Matrix&> H =
-      boost::none) const {
+      boost::none) const override {
     Vector error(1);
     error << E.error(vA_, vB_, H);
     return error;
@@ -131,14 +131,14 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   /// print
-  virtual void print(const std::string& s = "",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s);
     std::cout << "  EssentialMatrixFactor2 with measurements\n  ("
         << dP1_.transpose() << ")' and (" << pn_.transpose()
@@ -152,7 +152,7 @@ public:
    */
   Vector evaluateError(const EssentialMatrix& E, const double& d,
       boost::optional<Matrix&> DE = boost::none, boost::optional<Matrix&> Dd =
-          boost::none) const {
+          boost::none) const override {
 
     // We have point x,y in image 1
     // Given a depth Z, the corresponding 3D point P1 = Z*(x,y,1) = (x,y,1)/d
@@ -250,14 +250,14 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
 
   /// print
-  virtual void print(const std::string& s = "",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s);
     std::cout << "  EssentialMatrixFactor3 with rotation " << cRb_ << std::endl;
   }
@@ -269,7 +269,7 @@ public:
    */
   Vector evaluateError(const EssentialMatrix& E, const double& d,
       boost::optional<Matrix&> DE = boost::none, boost::optional<Matrix&> Dd =
-          boost::none) const {
+          boost::none) const override {
     if (!DE) {
       // Convert E from body to camera frame
       EssentialMatrix cameraE = cRb_ * E;
--- gtsam-4.0.3.orig/gtsam/slam/FrobeniusFactor.cpp
+++ gtsam-4.0.3/gtsam/slam/FrobeniusFactor.cpp
@@ -52,23 +52,40 @@ boost::shared_ptr<noiseModel::Isotropic>
 }
 
 //******************************************************************************
-FrobeniusWormholeFactor::FrobeniusWormholeFactor(Key j1, Key j2, const Rot3& R12,
-                                                 size_t p,
-                                                 const SharedNoiseModel& model)
+FrobeniusWormholeFactor::FrobeniusWormholeFactor(
+    Key j1, Key j2, const Rot3 &R12, size_t p, const SharedNoiseModel &model,
+    const boost::shared_ptr<Matrix> &G)
     : NoiseModelFactor2<SOn, SOn>(ConvertPose3NoiseModel(model, p * 3), j1, j2),
-      M_(R12.matrix()),               // 3*3 in all cases
-      p_(p),                          // 4 for SO(4)
-      pp_(p * p),                     // 16 for SO(4)
-      dimension_(SOn::Dimension(p)),  // 6 for SO(4)
-      G_(pp_, dimension_)             // 16*6 for SO(4)
-{
-  // Calculate G matrix of vectorized generators
-  Matrix Z = Matrix::Zero(p, p);
-  for (size_t j = 0; j < dimension_; j++) {
-    const auto X = SOn::Hat(Eigen::VectorXd::Unit(dimension_, j));
-    G_.col(j) = Eigen::Map<const Matrix>(X.data(), pp_, 1);
+      M_(R12.matrix()), // 3*3 in all cases
+      p_(p),            // 4 for SO(4)
+      pp_(p * p),       // 16 for SO(4)
+      G_(G) {
+  if (noiseModel()->dim() != 3 * p_)
+    throw std::invalid_argument(
+        "FrobeniusWormholeFactor: model with incorrect dimension.");
+  if (!G) {
+    G_ = boost::make_shared<Matrix>();
+    *G_ = SOn::VectorizedGenerators(p); // expensive!
   }
-  assert(noiseModel()->dim() == 3 * p_);
+  if (G_->rows() != pp_ || G_->cols() != SOn::Dimension(p))
+    throw std::invalid_argument("FrobeniusWormholeFactor: passed in generators "
+                                "of incorrect dimension.");
+}
+
+//******************************************************************************
+void FrobeniusWormholeFactor::print(const std::string &s, const KeyFormatter &keyFormatter) const {
+  std::cout << s << "FrobeniusWormholeFactor<" << p_ << ">(" << keyFormatter(key1()) << ","
+            << keyFormatter(key2()) << ")\n";
+  traits<Matrix>::Print(M_, "  M: ");
+  noiseModel_->print("  noise model: ");
+}
+
+//******************************************************************************
+bool FrobeniusWormholeFactor::equals(const NonlinearFactor &expected,
+                                     double tol) const {
+  auto e = dynamic_cast<const FrobeniusWormholeFactor *>(&expected);
+  return e != nullptr && NoiseModelFactor2<SOn, SOn>::equals(*e, tol) &&
+         p_ == e->p_ && M_ == e->M_;
 }
 
 //******************************************************************************
@@ -98,7 +115,7 @@ Vector FrobeniusWormholeFactor::evaluate
     RPxQ.block(0, 0, p_, dim) << M1 * M_(0, 0), M1 * M_(1, 0), M1 * M_(2, 0);
     RPxQ.block(p_, 0, p_, dim) << M1 * M_(0, 1), M1 * M_(1, 1), M1 * M_(2, 1);
     RPxQ.block(p2, 0, p_, dim) << M1 * M_(0, 2), M1 * M_(1, 2), M1 * M_(2, 2);
-    *H1 = -RPxQ * G_;
+    *H1 = -RPxQ * (*G_);
   }
   if (H2) {
     const size_t p2 = 2 * p_;
@@ -106,7 +123,7 @@ Vector FrobeniusWormholeFactor::evaluate
     PxQ.block(0, 0, p_, p_) = M2;
     PxQ.block(p_, p_, p_, p_) = M2;
     PxQ.block(p2, p2, p_, p_) = M2;
-    *H2 = PxQ * G_;
+    *H2 = PxQ * (*G_);
   }
 
   return fQ2 - hQ1;
--- gtsam-4.0.3.orig/gtsam/slam/FrobeniusFactor.h
+++ gtsam-4.0.3/gtsam/slam/FrobeniusFactor.h
@@ -56,7 +56,7 @@ class FrobeniusPrior : public NoiseModel
 
   /// Error is just Frobenius norm between Rot element and vectorized matrix M.
   Vector evaluateError(const Rot& R,
-                       boost::optional<Matrix&> H = boost::none) const {
+                       boost::optional<Matrix&> H = boost::none) const override {
     return R.vec(H) - vecM_;  // Jacobian is computed only when needed.
   }
 };
@@ -78,7 +78,7 @@ class FrobeniusFactor : public NoiseMode
   /// Error is just Frobenius norm between rotation matrices.
   Vector evaluateError(const Rot& R1, const Rot& R2,
                        boost::optional<Matrix&> H1 = boost::none,
-                       boost::optional<Matrix&> H2 = boost::none) const {
+                       boost::optional<Matrix&> H2 = boost::none) const override {
     Vector error = R2.vec(H2) - R1.vec(H1);
     if (H1) *H1 = -*H1;
     return error;
@@ -92,14 +92,17 @@ class FrobeniusFactor : public NoiseMode
  * and in fact only SO3 and SO4 really work, as we need SO<N>::AdjointMap.
  */
 template <class Rot>
-class FrobeniusBetweenFactor : public NoiseModelFactor2<Rot, Rot> {
+GTSAM_EXPORT class FrobeniusBetweenFactor : public NoiseModelFactor2<Rot, Rot> {
   Rot R12_;  ///< measured rotation between R1 and R2
   Eigen::Matrix<double, Rot::dimension, Rot::dimension>
       R2hat_H_R1_;  ///< fixed derivative of R2hat wrpt R1
   enum { Dim = Rot::VectorN2::RowsAtCompileTime };
 
  public:
-  /// Constructor
+  /// @name Constructor
+  /// @{
+
+  /// Construct from two keys and measured rotation
   FrobeniusBetweenFactor(Key j1, Key j2, const Rot& R12,
                          const SharedNoiseModel& model = nullptr)
       : NoiseModelFactor2<Rot, Rot>(
@@ -107,16 +110,44 @@ class FrobeniusBetweenFactor : public No
         R12_(R12),
         R2hat_H_R1_(R12.inverse().AdjointMap()) {}
 
+  /// @}
+  /// @name Testable
+  /// @{
+
+  /// print with optional string
+  void
+  print(const std::string &s,
+        const KeyFormatter &keyFormatter = DefaultKeyFormatter) const override {
+    std::cout << s << "FrobeniusBetweenFactor<" << demangle(typeid(Rot).name())
+              << ">(" << keyFormatter(this->key1()) << ","
+              << keyFormatter(this->key2()) << ")\n";
+    traits<Rot>::Print(R12_, "  R12: ");
+    this->noiseModel_->print("  noise model: ");
+  }
+
+  /// assert equality up to a tolerance
+  bool equals(const NonlinearFactor &expected,
+              double tol = 1e-9) const override {
+    auto e = dynamic_cast<const FrobeniusBetweenFactor *>(&expected);
+    return e != nullptr && NoiseModelFactor2<Rot, Rot>::equals(*e, tol) &&
+           traits<Rot>::Equals(this->R12_, e->R12_, tol);
+  }
+
+  /// @}
+  /// @name NoiseModelFactor2 methods 
+  /// @{
+
   /// Error is Frobenius norm between R1*R12 and R2.
   Vector evaluateError(const Rot& R1, const Rot& R2,
                        boost::optional<Matrix&> H1 = boost::none,
-                       boost::optional<Matrix&> H2 = boost::none) const {
+                       boost::optional<Matrix&> H2 = boost::none) const override {
     const Rot R2hat = R1.compose(R12_);
     Eigen::Matrix<double, Dim, Rot::dimension> vec_H_R2hat;
     Vector error = R2.vec(H2) - R2hat.vec(H1 ? &vec_H_R2hat : nullptr);
     if (H1) *H1 = -vec_H_R2hat * R2hat_H_R1_;
     return error;
   }
+  /// @}
 };
 
 /**
@@ -125,21 +156,46 @@ class FrobeniusBetweenFactor : public No
  * the SO(p) matrices down to a Stiefel manifold of p*d matrices.
  * TODO(frank): template on D=2 or 3
  */
-class GTSAM_EXPORT FrobeniusWormholeFactor : public NoiseModelFactor2<SOn, SOn> {
-  Matrix M_;                   ///< measured rotation between R1 and R2
-  size_t p_, pp_, dimension_;  ///< dimensionality constants
-  Matrix G_;                   ///< matrix of vectorized generators
+class GTSAM_EXPORT FrobeniusWormholeFactor
+    : public NoiseModelFactor2<SOn, SOn> {
+  Matrix M_;                    ///< measured rotation between R1 and R2
+  size_t p_, pp_;               ///< dimensionality constants
+  boost::shared_ptr<Matrix> G_; ///< matrix of vectorized generators
+
+public:
+  /// @name Constructor
+  /// @{
 
- public:
   /// Constructor. Note we convert to 3*p-dimensional noise model.
-  FrobeniusWormholeFactor(Key j1, Key j2, const Rot3& R12, size_t p = 4,
-                          const SharedNoiseModel& model = nullptr);
+  /// To save memory and mallocs, pass in the vectorized Lie algebra generators:
+  ///    G = boost::make_shared<Matrix>(SOn::VectorizedGenerators(p));
+  FrobeniusWormholeFactor(Key j1, Key j2, const Rot3 &R12, size_t p = 4,
+                          const SharedNoiseModel &model = nullptr,
+                          const boost::shared_ptr<Matrix> &G = nullptr);
+
+  /// @}
+  /// @name Testable
+  /// @{
+
+  /// print with optional string
+  void
+  print(const std::string &s,
+        const KeyFormatter &keyFormatter = DefaultKeyFormatter) const override;
+
+  /// assert equality up to a tolerance
+  bool equals(const NonlinearFactor &expected,
+              double tol = 1e-9) const override;
+
+  /// @}
+  /// @name NoiseModelFactor2 methods 
+  /// @{
 
   /// Error is Frobenius norm between Q1*P*R12 and Q2*P, where P=[I_3x3;0]
   /// projects down from SO(p) to the Stiefel manifold of px3 matrices.
   Vector evaluateError(const SOn& Q1, const SOn& Q2,
                        boost::optional<Matrix&> H1 = boost::none,
-                       boost::optional<Matrix&> H2 = boost::none) const;
+                       boost::optional<Matrix&> H2 = boost::none) const override;
+  /// @}
 };
 
 }  // namespace gtsam
--- gtsam-4.0.3.orig/gtsam/slam/GeneralSFMFactor.h
+++ gtsam-4.0.3/gtsam/slam/GeneralSFMFactor.h
@@ -96,7 +96,7 @@ public:
   virtual ~GeneralSFMFactor() {} ///< destructor
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));}
 
@@ -105,7 +105,7 @@ public:
    * @param s optional string naming the factor
    * @param keyFormatter optional formatter for printing out Symbols
    */
-  void print(const std::string& s = "SFMFactor", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "SFMFactor", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s, keyFormatter);
     traits<Point2>::Print(measured_, s + ".z");
   }
@@ -113,14 +113,14 @@ public:
   /**
    * equals
    */
-  bool equals(const NonlinearFactor &p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor &p, double tol = 1e-9) const override {
     const This* e = dynamic_cast<const This*>(&p);
     return e && Base::equals(p, tol) && traits<Point2>::Equals(this->measured_, e->measured_, tol);
   }
 
   /** h(x)-z */
   Vector evaluateError(const CAMERA& camera, const LANDMARK& point,
-      boost::optional<Matrix&> H1=boost::none, boost::optional<Matrix&> H2=boost::none) const {
+      boost::optional<Matrix&> H1=boost::none, boost::optional<Matrix&> H2=boost::none) const override {
     try {
       return camera.project2(point,H1,H2) - measured_;
     }
@@ -133,7 +133,7 @@ public:
   }
 
   /// Linearize using fixed-size matrices
-  boost::shared_ptr<GaussianFactor> linearize(const Values& values) const {
+  boost::shared_ptr<GaussianFactor> linearize(const Values& values) const override {
     // Only linearize if the factor is active
     if (!this->active(values)) return boost::shared_ptr<JacobianFactor>();
 
@@ -230,7 +230,7 @@ public:
   virtual ~GeneralSFMFactor2() {} ///< destructor
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));}
 
@@ -239,7 +239,7 @@ public:
    * @param s optional string naming the factor
    * @param keyFormatter optional formatter useful for printing Symbols
    */
-  void print(const std::string& s = "SFMFactor2", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "SFMFactor2", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s, keyFormatter);
     traits<Point2>::Print(measured_, s + ".z");
   }
@@ -247,7 +247,7 @@ public:
   /**
    * equals
    */
-  bool equals(const NonlinearFactor &p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor &p, double tol = 1e-9) const override {
     const This* e = dynamic_cast<const This*>(&p);
     return e && Base::equals(p, tol) && traits<Point2>::Equals(this->measured_, e->measured_, tol);
   }
@@ -256,7 +256,7 @@ public:
   Vector evaluateError(const Pose3& pose3, const Point3& point, const CALIBRATION &calib,
       boost::optional<Matrix&> H1=boost::none,
       boost::optional<Matrix&> H2=boost::none,
-      boost::optional<Matrix&> H3=boost::none) const
+      boost::optional<Matrix&> H3=boost::none) const override
   {
     try {
       Camera camera(pose3,calib);
--- gtsam-4.0.3.orig/gtsam/slam/OrientedPlane3Factor.h
+++ gtsam-4.0.3/gtsam/slam/OrientedPlane3Factor.h
@@ -41,13 +41,13 @@ public:
   }
 
   /// print
-  virtual void print(const std::string& s = "OrientedPlane3Factor",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s = "OrientedPlane3Factor",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /// evaluateError
-  virtual Vector evaluateError(const Pose3& pose, const OrientedPlane3& plane,
+  Vector evaluateError(const Pose3& pose, const OrientedPlane3& plane,
       boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 =
-          boost::none) const {
+          boost::none) const override {
     OrientedPlane3 predicted_plane = OrientedPlane3::Transform(plane, pose, H1,
         H2);
     Vector err(3);
@@ -78,14 +78,14 @@ public:
   }
 
   /// print
-  virtual void print(const std::string& s = "OrientedPlane3DirectionPrior",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s = "OrientedPlane3DirectionPrior",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /// equals
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
 
-  virtual Vector evaluateError(const OrientedPlane3& plane,
-      boost::optional<Matrix&> H = boost::none) const;
+  Vector evaluateError(const OrientedPlane3& plane,
+      boost::optional<Matrix&> H = boost::none) const override;
 };
 
 } // gtsam
--- gtsam-4.0.3.orig/gtsam/slam/PoseRotationPrior.h
+++ gtsam-4.0.3/gtsam/slam/PoseRotationPrior.h
@@ -50,7 +50,7 @@ public:
   virtual ~PoseRotationPrior() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -60,19 +60,19 @@ public:
   // testable
 
   /** equals specialized to this factor */
-  virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+  bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
     const This *e = dynamic_cast<const This*> (&expected);
     return e != nullptr && Base::equals(*e, tol) && measured_.equals(e->measured_, tol);
   }
 
   /** print contents */
-  void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s + "PoseRotationPrior", keyFormatter);
     measured_.print("Measured Rotation");
   }
 
   /** h(x)-z */
-  Vector evaluateError(const Pose& pose, boost::optional<Matrix&> H = boost::none) const {
+  Vector evaluateError(const Pose& pose, boost::optional<Matrix&> H = boost::none) const override {
     const Rotation& newR = pose.rotation();
     if (H) {
       *H = Matrix::Zero(rDim, xDim);
--- gtsam-4.0.3.orig/gtsam/slam/PoseTranslationPrior.h
+++ gtsam-4.0.3/gtsam/slam/PoseTranslationPrior.h
@@ -54,12 +54,12 @@ public:
   const Translation& measured() const { return measured_; }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
   /** h(x)-z */
-  Vector evaluateError(const Pose& pose, boost::optional<Matrix&> H = boost::none) const {
+  Vector evaluateError(const Pose& pose, boost::optional<Matrix&> H = boost::none) const override {
     const Translation& newTrans = pose.translation();
     const Rotation& R = pose.rotation();
     const int tDim = traits<Translation>::GetDimension(newTrans);
@@ -74,13 +74,13 @@ public:
   }
 
   /** equals specialized to this factor */
-  virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+  bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
     const This *e = dynamic_cast<const This*> (&expected);
     return e != nullptr && Base::equals(*e, tol) && traits<Translation>::Equals(measured_, e->measured_, tol);
   }
 
   /** print contents */
-  void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s + "PoseTranslationPrior", keyFormatter);
     traits<Translation>::Print(measured_, "Measured Translation");
   }
--- gtsam-4.0.3.orig/gtsam/slam/ProjectionFactor.h
+++ gtsam-4.0.3/gtsam/slam/ProjectionFactor.h
@@ -100,7 +100,7 @@ namespace gtsam {
     virtual ~GenericProjectionFactor() {}
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -109,7 +109,7 @@ namespace gtsam {
      * @param s optional string naming the factor
      * @param keyFormatter optional formatter useful for printing Symbols
      */
-    void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "GenericProjectionFactor, z = ";
       traits<Point2>::Print(measured_);
       if(this->body_P_sensor_)
@@ -118,7 +118,7 @@ namespace gtsam {
     }
 
     /// equals
-    virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+    bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
       const This *e = dynamic_cast<const This*>(&p);
       return e
           && Base::equals(p, tol)
@@ -129,7 +129,7 @@ namespace gtsam {
 
     /// Evaluate error h(x)-z and optionally derivatives
     Vector evaluateError(const Pose3& pose, const Point3& point,
-        boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 = boost::none) const {
+        boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 = boost::none) const override {
       try {
         if(body_P_sensor_) {
           if(H1) {
--- gtsam-4.0.3.orig/gtsam/slam/ReferenceFrameFactor.h
+++ gtsam-4.0.3/gtsam/slam/ReferenceFrameFactor.h
@@ -89,23 +89,23 @@ public:
 
   virtual ~ReferenceFrameFactor(){}
 
-  virtual NonlinearFactor::shared_ptr clone() const {
+  NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<NonlinearFactor>(
         NonlinearFactor::shared_ptr(new This(*this))); }
 
   /** Combined cost and derivative function using boost::optional */
-  virtual Vector evaluateError(const Point& global, const Transform& trans, const Point& local,
+  Vector evaluateError(const Point& global, const Transform& trans, const Point& local,
         boost::optional<Matrix&> Dforeign = boost::none,
         boost::optional<Matrix&> Dtrans = boost::none,
-        boost::optional<Matrix&> Dlocal = boost::none) const  {
+        boost::optional<Matrix&> Dlocal = boost::none) const override {
     Point newlocal = transform_point<Transform,Point>(trans, global, Dtrans, Dforeign);
     if (Dlocal)
       *Dlocal = -1* Matrix::Identity(traits<Point>::dimension, traits<Point>::dimension);
     return traits<Point>::Local(local,newlocal);
   }
 
-  virtual void print(const std::string& s="",
-      const gtsam::KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s="",
+      const gtsam::KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << ": ReferenceFrameFactor("
         << "Global: " << keyFormatter(this->key1()) << ","
         << " Transform: " << keyFormatter(this->key2()) << ","
--- gtsam-4.0.3.orig/gtsam/slam/RotateFactor.h
+++ gtsam-4.0.3/gtsam/slam/RotateFactor.h
@@ -36,13 +36,13 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
   /// print
-  virtual void print(const std::string& s = "",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s);
     std::cout << "RotateFactor:]\n";
     std::cout << "p: " << p_.transpose() << std::endl;
@@ -51,7 +51,7 @@ public:
 
   /// vector of errors returns 2D vector
   Vector evaluateError(const Rot3& R,
-      boost::optional<Matrix&> H = boost::none) const {
+      boost::optional<Matrix&> H = boost::none) const override {
     // predict p_ as q = R*z_, derivative H will be filled if not none
     Point3 q = R.rotate(z_,H);
     // error is just difference, and note derivative of that wrpt q is I3
@@ -88,13 +88,13 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
   /// print
-  virtual void print(const std::string& s = "",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s);
     std::cout << "RotateDirectionsFactor:" << std::endl;
     i_p_.print("p");
@@ -102,7 +102,7 @@ public:
   }
 
   /// vector of errors returns 2D vector
-  Vector evaluateError(const Rot3& iRc, boost::optional<Matrix&> H = boost::none) const {
+  Vector evaluateError(const Rot3& iRc, boost::optional<Matrix&> H = boost::none) const override {
     Unit3 i_q = iRc * c_z_;
     Vector error = i_p_.error(i_q, H);
     if (H) {
--- gtsam-4.0.3.orig/gtsam/slam/SmartFactorBase.h
+++ gtsam-4.0.3/gtsam/slam/SmartFactorBase.h
@@ -150,7 +150,7 @@ protected:
   }
 
   /// get the dimension (number of rows!) of the factor
-  virtual size_t dim() const {
+  size_t dim() const override {
     return ZDim * this->measured_.size();
   }
 
@@ -173,7 +173,7 @@ protected:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "", const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const {
+      DefaultKeyFormatter) const override {
     std::cout << s << "SmartFactorBase, z = \n";
     for (size_t k = 0; k < measured_.size(); ++k) {
       std::cout << "measurement, p = " << measured_[k] << "\t";
@@ -185,7 +185,7 @@ protected:
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*>(&p);
 
     bool areMeasurementsEqual = true;
--- gtsam-4.0.3.orig/gtsam/slam/SmartProjectionFactor.h
+++ gtsam-4.0.3/gtsam/slam/SmartProjectionFactor.h
@@ -99,7 +99,7 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "", const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const {
+      DefaultKeyFormatter) const override {
     std::cout << s << "SmartProjectionFactor\n";
     std::cout << "linearizationMode:\n" << params_.linearizationMode
         << std::endl;
@@ -110,7 +110,7 @@ public:
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*>(&p);
     return e && params_.linearizationMode == e->params_.linearizationMode
         && Base::equals(p, tol);
@@ -305,8 +305,8 @@ public:
   }
 
   /// linearize
-  virtual boost::shared_ptr<GaussianFactor> linearize(
-      const Values& values) const {
+  boost::shared_ptr<GaussianFactor> linearize(
+      const Values& values) const override {
     return linearizeDamped(values);
   }
 
@@ -409,7 +409,7 @@ public:
   }
 
   /// Calculate total reprojection error
-  virtual double error(const Values& values) const {
+  double error(const Values& values) const override {
     if (this->active(values)) {
       return totalReprojectionError(Base::cameras(values));
     } else { // else of active flag
@@ -443,25 +443,6 @@ public:
   /** return the farPoint state */
   bool isFarPoint() const { return result_.farPoint(); }
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  /// @name Deprecated
-  /// @{
-  // It does not make sense to optimize for a camera where the pose would not be
-  // the actual pose of the camera. An unfortunate consequence of deprecating
-  // this constructor means that we cannot optimize for calibration when the
-  // camera is offset from the body pose. That would need a new factor with
-  // (body) pose and calibration as variables. However, that use case is
-  // unlikely: when a global offset is know, calibration is typically known.
-  SmartProjectionFactor(
-      const SharedNoiseModel& sharedNoiseModel,
-      const boost::optional<Pose3> body_P_sensor,
-      const SmartProjectionParams& params = SmartProjectionParams())
-      : Base(sharedNoiseModel, body_P_sensor),
-        params_(params),
-        result_(TriangulationResult::Degenerate()) {}
-  /// @}
-#endif
-
  private:
 
   /// Serialization function
--- gtsam-4.0.3.orig/gtsam/slam/SmartProjectionPoseFactor.h
+++ gtsam-4.0.3/gtsam/slam/SmartProjectionPoseFactor.h
@@ -103,13 +103,13 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "", const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const {
+      DefaultKeyFormatter) const override {
     std::cout << s << "SmartProjectionPoseFactor, z = \n ";
     Base::print("", keyFormatter);
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*>(&p);
     return e && Base::equals(p, tol);
   }
@@ -117,7 +117,7 @@ public:
   /**
    * error calculates the error of the factor.
    */
-  virtual double error(const Values& values) const {
+  double error(const Values& values) const override {
     if (this->active(values)) {
       return this->totalReprojectionError(cameras(values));
     } else { // else of active flag
@@ -136,7 +136,7 @@ public:
    * to keys involved in this factor
    * @return vector of Values
    */
-  typename Base::Cameras cameras(const Values& values) const {
+  typename Base::Cameras cameras(const Values& values) const override {
     typename Base::Cameras cameras;
     for (const Key& k : this->keys_) {
       const Pose3 world_P_sensor_k =
--- gtsam-4.0.3.orig/gtsam/slam/StereoFactor.h
+++ gtsam-4.0.3/gtsam/slam/StereoFactor.h
@@ -91,7 +91,7 @@ public:
   virtual ~GenericStereoFactor() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -100,7 +100,7 @@ public:
    * @param s optional string naming the factor
    * @param keyFormatter optional formatter useful for printing Symbols
    */
-  void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s, keyFormatter);
     measured_.print(s + ".z");
     if(this->body_P_sensor_)
@@ -110,7 +110,7 @@ public:
   /**
    * equals
    */
-  virtual bool equals(const NonlinearFactor& f, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& f, double tol = 1e-9) const override {
     const GenericStereoFactor* e = dynamic_cast<const GenericStereoFactor*> (&f);
     return e
         && Base::equals(f)
@@ -120,7 +120,7 @@ public:
 
   /** h(x)-z */
   Vector evaluateError(const Pose3& pose, const Point3& point,
-      boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 = boost::none) const {
+      boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 = boost::none) const override {
     try {
       if(body_P_sensor_) {
         if(H1) {
--- gtsam-4.0.3.orig/gtsam/slam/TriangulationFactor.h
+++ gtsam-4.0.3/gtsam/slam/TriangulationFactor.h
@@ -90,7 +90,7 @@ public:
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
@@ -101,7 +101,7 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "", const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const {
+      DefaultKeyFormatter) const override {
     std::cout << s << "TriangulationFactor,";
     camera_.print("camera");
     traits<Measurement>::Print(measured_, "z");
@@ -109,7 +109,7 @@ public:
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*>(&p);
     return e && Base::equals(p, tol) && this->camera_.equals(e->camera_, tol)
         && traits<Measurement>::Equals(this->measured_, e->measured_, tol);
@@ -117,7 +117,7 @@ public:
 
   /// Evaluate error h(x)-z and optionally derivatives
   Vector evaluateError(const Point3& point, boost::optional<Matrix&> H2 =
-      boost::none) const {
+      boost::none) const override {
     try {
       return traits<Measurement>::Local(measured_, camera_.project2(point, boost::none, H2));
     } catch (CheiralityException& e) {
@@ -143,7 +143,7 @@ public:
    * \f$ Ax-b \approx h(x+\delta x)-z = h(x) + A \delta x - z \f$
    * Hence \f$ b = z - h(x) = - \mathtt{error\_vector}(x) \f$
    */
-  boost::shared_ptr<GaussianFactor> linearize(const Values& x) const {
+  boost::shared_ptr<GaussianFactor> linearize(const Values& x) const override {
     // Only linearize if the factor is active
     if (!this->active(x))
       return boost::shared_ptr<JacobianFactor>();
--- gtsam-4.0.3.orig/gtsam/slam/dataset.cpp
+++ gtsam-4.0.3/gtsam/slam/dataset.cpp
@@ -11,7 +11,10 @@
 /**
  * @file dataset.cpp
  * @date Jan 22, 2010
- * @author Kai Ni, Luca Carlone, Frank Dellaert
+ * @author Kai Ni
+ * @author Luca Carlone
+ * @author Frank Dellaert
+ * @author Varun Agrawal
  * @brief utility functions for loading datasets
  */
 
@@ -70,8 +73,8 @@ string findExampleDataFile(const string&
   namesToSearch.push_back(name + ".xml");
 
   // Find first name that exists
-  for(const fs::path& root: rootsToSearch) {
-    for(const fs::path& name: namesToSearch) {
+  for(const fs::path root: rootsToSearch) {
+    for(const fs::path name: namesToSearch) {
       if (fs::is_regular_file(root / name))
         return (root / name).string();
     }
@@ -192,8 +195,15 @@ static SharedNoiseModel readNoiseModel(i
   }
 }
 
+#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V41
 /* ************************************************************************* */
 boost::optional<IndexedPose> parseVertex(istream& is, const string& tag) {
+  return parseVertexPose(is, tag);
+}
+#endif
+
+/* ************************************************************************* */
+boost::optional<IndexedPose> parseVertexPose(istream& is, const string& tag) {
   if ((tag == "VERTEX2") || (tag == "VERTEX_SE2") || (tag == "VERTEX")) {
     Key id;
     double x, y, yaw;
@@ -205,6 +215,18 @@ boost::optional<IndexedPose> parseVertex
 }
 
 /* ************************************************************************* */
+boost::optional<IndexedLandmark> parseVertexLandmark(istream& is, const string& tag) {
+  if (tag == "VERTEX_XY") {
+    Key id;
+    double x, y;
+    is >> id >> x >> y;
+    return IndexedLandmark(id, Point2(x, y));
+  } else {
+    return boost::none;
+  }
+}
+
+/* ************************************************************************* */
 boost::optional<IndexedEdge> parseEdge(istream& is, const string& tag) {
   if ((tag == "EDGE2") || (tag == "EDGE") || (tag == "EDGE_SE2")
       || (tag == "ODOMETRY")) {
@@ -232,12 +254,12 @@ GraphAndValues load2D(const string& file
 
   string tag;
 
-  // load the poses
+  // load the poses and landmarks
   while (!is.eof()) {
     if (!(is >> tag))
       break;
 
-    const auto indexed_pose = parseVertex(is, tag);
+    const auto indexed_pose = parseVertexPose(is, tag);
     if (indexed_pose) {
       Key id = indexed_pose->first;
 
@@ -247,6 +269,16 @@ GraphAndValues load2D(const string& file
 
       initial->insert(id, indexed_pose->second);
     }
+    const auto indexed_landmark = parseVertexLandmark(is, tag);
+    if (indexed_landmark) {
+      Key id = indexed_landmark->first;
+
+      // optional filter
+      if (maxID && id >= maxID)
+        continue;
+
+      initial->insert(id, indexed_landmark->second);
+    }
     is.ignore(LINESIZE, '\n');
   }
   is.clear(); /* clears the end-of-file and error flags */
@@ -429,7 +461,7 @@ void writeG2o(const NonlinearFactorGraph
     const string& filename) {
   fstream stream(filename.c_str(), fstream::out);
 
-  // save 2D & 3D poses
+  // save 2D poses
   for (const auto& key_value : estimate) {
     auto p = dynamic_cast<const GenericValue<Pose2>*>(&key_value.value);
     if (!p) continue;
@@ -438,15 +470,34 @@ void writeG2o(const NonlinearFactorGraph
         << pose.y() << " " << pose.theta() << endl;
   }
 
+  // save 3D poses
+  for(const auto& key_value: estimate) {
+    auto p = dynamic_cast<const GenericValue<Pose3>*>(&key_value.value);
+    if (!p) continue;
+    const Pose3& pose = p->value();
+    const Point3 t = pose.translation();
+    const auto q = pose.rotation().toQuaternion();
+    stream << "VERTEX_SE3:QUAT " << key_value.key << " " << t.x() << " "
+            << t.y() << " " << t.z() << " " << q.x() << " " << q.y() << " "
+            << q.z() << " " << q.w() << endl;
+  }
+
+  // save 2D landmarks
+  for(const auto& key_value: estimate) {
+    auto p = dynamic_cast<const GenericValue<Point2>*>(&key_value.value);
+    if (!p) continue;
+    const Point2& point = p->value();
+    stream << "VERTEX_XY " << key_value.key << " " << point.x() << " "
+        << point.y() << endl;
+  }
+
+  // save 3D landmarks
   for(const auto& key_value: estimate) {
-      auto p = dynamic_cast<const GenericValue<Pose3>*>(&key_value.value);
-      if (!p) continue;
-      const Pose3& pose = p->value();
-      const Point3 t = pose.translation();
-      const auto q = pose.rotation().toQuaternion();
-      stream << "VERTEX_SE3:QUAT " << key_value.key << " " << t.x() << " "
-             << t.y() << " " << t.z() << " " << q.x() << " " << q.y() << " "
-             << q.z() << " " << q.w() << endl;
+    auto p = dynamic_cast<const GenericValue<Point3>*>(&key_value.value);
+    if (!p) continue;
+    const Point3& point = p->value();
+    stream << "VERTEX_TRACKXYZ " << key_value.key << " " << point.x() << " "
+        << point.y() << " " << point.z() << endl;
   }
 
   // save edges (2D or 3D)
@@ -515,6 +566,7 @@ static Rot3 NormalizedRot3(double w, dou
   const double norm = sqrt(w * w + x * x + y * y + z * z), f = 1.0 / norm;
   return Rot3::Quaternion(f * w, f * x, f * y, f * z);
 }
+
 /* ************************************************************************* */
 std::map<Key, Pose3> parse3DPoses(const string& filename) {
   ifstream is(filename.c_str());
@@ -546,6 +598,30 @@ std::map<Key, Pose3> parse3DPoses(const
 }
 
 /* ************************************************************************* */
+std::map<Key, Point3> parse3DLandmarks(const string& filename) {
+  ifstream is(filename.c_str());
+  if (!is)
+    throw invalid_argument("parse3DLandmarks: can not find file " + filename);
+
+  std::map<Key, Point3> landmarks;
+  while (!is.eof()) {
+    char buf[LINESIZE];
+    is.getline(buf, LINESIZE);
+    istringstream ls(buf);
+    string tag;
+    ls >> tag;
+
+    if (tag == "VERTEX_TRACKXYZ") {
+      Key id;
+      double x, y, z;
+      ls >> id >> x >> y >> z;
+      landmarks.emplace(id, Point3(x, y, z));
+    }
+  }
+  return landmarks;
+}
+
+/* ************************************************************************* */
 BetweenFactorPose3s parse3DFactors(
     const string& filename,
     const noiseModel::Diagonal::shared_ptr& corruptingNoise) {
@@ -617,11 +693,16 @@ GraphAndValues load3D(const string& file
     graph->push_back(factor);
   }
 
-  const auto poses = parse3DPoses(filename);
   Values::shared_ptr initial(new Values);
+
+  const auto poses = parse3DPoses(filename);
   for (const auto& key_pose : poses) {
     initial->insert(key_pose.first, key_pose.second);
   }
+  const auto landmarks = parse3DLandmarks(filename);
+  for (const auto& key_landmark : landmarks) {
+    initial->insert(key_landmark.first, key_landmark.second);
+  }
 
   return make_pair(graph, initial);
 }
--- gtsam-4.0.3.orig/gtsam/slam/dataset.h
+++ gtsam-4.0.3/gtsam/slam/dataset.h
@@ -76,8 +76,10 @@ enum KernelFunctionType {
 
 /// Return type for auxiliary functions
 typedef std::pair<Key, Pose2> IndexedPose;
+typedef std::pair<Key, Point2> IndexedLandmark;
 typedef std::pair<std::pair<Key, Key>, Pose2> IndexedEdge;
 
+#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V41
 /**
  * Parse TORO/G2O vertex "id x y yaw"
  * @param is input stream
@@ -85,6 +87,24 @@ typedef std::pair<std::pair<Key, Key>, P
  */
 GTSAM_EXPORT boost::optional<IndexedPose> parseVertex(std::istream& is,
     const std::string& tag);
+#endif
+
+/**
+ * Parse TORO/G2O vertex "id x y yaw"
+ * @param is input stream
+ * @param tag string parsed from input stream, will only parse if vertex type
+ */
+GTSAM_EXPORT boost::optional<IndexedPose> parseVertexPose(std::istream& is,
+    const std::string& tag);
+
+/**
+ * Parse G2O landmark vertex "id x y"
+ * @param is input stream
+ * @param tag string parsed from input stream, will only parse if vertex type
+ */
+
+GTSAM_EXPORT boost::optional<IndexedLandmark> parseVertexLandmark(std::istream& is,
+    const std::string& tag);
 
 /**
  * Parse TORO/G2O edge "id1 id2 x y yaw"
@@ -162,9 +182,12 @@ using BetweenFactorPose3s = std::vector<
 GTSAM_EXPORT BetweenFactorPose3s parse3DFactors(const std::string& filename, 
     const noiseModel::Diagonal::shared_ptr& corruptingNoise=nullptr);
 
-/// Parse vertices in 3D TORO graph file into a map of Pose3s.
+/// Parse vertices in 3D TORO/g2o graph file into a map of Pose3s.
 GTSAM_EXPORT std::map<Key, Pose3> parse3DPoses(const std::string& filename);
 
+/// Parse landmarks in 3D g2o graph file into a map of Point3s.
+GTSAM_EXPORT std::map<Key, Point3> parse3DLandmarks(const string& filename);
+
 /// Load TORO 3D Graph
 GTSAM_EXPORT GraphAndValues load3D(const std::string& filename);
 
@@ -301,13 +324,4 @@ GTSAM_EXPORT Values initialCamerasEstima
  */
 GTSAM_EXPORT Values initialCamerasAndPointsEstimate(const SfmData& db);
 
-/// Aliases for backwards compatibility
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-typedef SfmMeasurement SfM_Measurement;
-typedef SiftIndex SIFT_Index;
-typedef SfmTrack SfM_Track;
-typedef SfmCamera SfM_Camera;
-typedef SfmData SfM_data;
-#endif
-
-} // namespace gtsam
+}  // namespace gtsam
--- gtsam-4.0.3.orig/gtsam/slam/tests/testDataset.cpp
+++ gtsam-4.0.3/gtsam/slam/tests/testDataset.cpp
@@ -43,13 +43,13 @@ TEST(dataSet, findExampleDataFile) {
 }
 
 /* ************************************************************************* */
-TEST( dataSet, parseVertex)
+TEST( dataSet, parseVertexPose)
 {
   const string str = "VERTEX2 1 2.000000 3.000000 4.000000";
   istringstream is(str);
   string tag;
   EXPECT(is >> tag);
-  const auto actual = parseVertex(is, tag);
+  const auto actual = parseVertexPose(is, tag);
   EXPECT(actual);
   if (actual) {
     EXPECT_LONGS_EQUAL(1, actual->first);
@@ -58,6 +58,21 @@ TEST( dataSet, parseVertex)
 }
 
 /* ************************************************************************* */
+TEST( dataSet, parseVertexLandmark)
+{
+  const string str = "VERTEX_XY 1 2.000000 3.000000";
+  istringstream is(str);
+  string tag;
+  EXPECT(is >> tag);
+  const auto actual = parseVertexLandmark(is, tag);
+  EXPECT(actual);
+  if (actual) {
+    EXPECT_LONGS_EQUAL(1, actual->first);
+    EXPECT(assert_equal(Point2(2, 3), actual->second));
+  }
+}
+
+/* ************************************************************************* */
 TEST( dataSet, parseEdge)
 {
   const string str = "EDGE2 0 1 2.000000 3.000000 4.000000";
@@ -182,6 +197,12 @@ TEST(dataSet, readG2o3D) {
     EXPECT(assert_equal(poses[j], actualPoses.at(j), 1e-5));
   }
 
+  // Check landmark parsing
+  const auto actualLandmarks = parse3DLandmarks(g2oFile);
+  for (size_t j : {0, 1, 2, 3, 4}) {
+    EXPECT(assert_equal(poses[j], actualPoses.at(j), 1e-5));
+  }
+
   // Check graph version
   NonlinearFactorGraph::shared_ptr actualGraph;
   Values::shared_ptr actualValues;
@@ -252,6 +273,19 @@ TEST(dataSet, readG2oCheckDeterminants)
     const Rot3 R = key_value.second.rotation();
     EXPECT_DOUBLES_EQUAL(1.0, R.matrix().determinant(), 1e-9);
   }
+  const map<Key, Point3> landmarks = parse3DLandmarks(g2oFile);
+  EXPECT_LONGS_EQUAL(0, landmarks.size());
+}
+
+/* ************************************************************************* */
+TEST(dataSet, readG2oLandmarks) {
+  const string g2oFile = findExampleDataFile("example_with_vertices.g2o");
+
+  // Check number of poses and landmarks. Should be 8 each.
+  const map<Key, Pose3> poses = parse3DPoses(g2oFile);
+  EXPECT_LONGS_EQUAL(8, poses.size());
+  const map<Key, Point3> landmarks = parse3DLandmarks(g2oFile);
+  EXPECT_LONGS_EQUAL(8, landmarks.size());
 }
 
 /* ************************************************************************* */
--- gtsam-4.0.3.orig/gtsam/slam/tests/testSmartFactorBase.cpp
+++ gtsam-4.0.3/gtsam/slam/tests/testSmartFactorBase.cpp
@@ -41,9 +41,9 @@ public:
                 boost::optional<Pose3> body_P_sensor = boost::none,
                 size_t expectedNumberCameras = 10)
       : Base(sharedNoiseModel, body_P_sensor, expectedNumberCameras) {}
-  virtual double error(const Values& values) const { return 0.0; }
-  virtual boost::shared_ptr<GaussianFactor> linearize(
-      const Values& values) const {
+  double error(const Values& values) const override { return 0.0; }
+  boost::shared_ptr<GaussianFactor> linearize(
+      const Values& values) const override {
     return boost::shared_ptr<GaussianFactor>(new JacobianFactor());
   }
 };
@@ -105,11 +105,11 @@ public:
   StereoFactor() {}
   StereoFactor(const SharedNoiseModel& sharedNoiseModel): Base(sharedNoiseModel) {
   }
-  virtual double error(const Values& values) const {
+  double error(const Values& values) const override {
     return 0.0;
   }
-  virtual boost::shared_ptr<GaussianFactor> linearize(
-      const Values& values) const {
+  boost::shared_ptr<GaussianFactor> linearize(
+      const Values& values) const override {
     return boost::shared_ptr<GaussianFactor>(new JacobianFactor());
   }
 };
--- gtsam-4.0.3.orig/gtsam/symbolic/SymbolicBayesTree.h
+++ gtsam-4.0.3/gtsam/symbolic/SymbolicBayesTree.h
@@ -39,6 +39,7 @@ namespace gtsam {
     typedef boost::shared_ptr<This> shared_ptr;
     typedef boost::weak_ptr<This> weak_ptr;
     SymbolicBayesTreeClique() {}
+    virtual ~SymbolicBayesTreeClique() {}
     SymbolicBayesTreeClique(const boost::shared_ptr<SymbolicConditional>& conditional) : Base(conditional) {}
   };
 
--- gtsam-4.0.3.orig/gtsam/symbolic/SymbolicConditional.h
+++ gtsam-4.0.3/gtsam/symbolic/SymbolicConditional.h
@@ -105,7 +105,7 @@ namespace gtsam {
     /// @name Testable
 
     /** Print with optional formatter */
-    void print(const std::string& str = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+    virtual void print(const std::string& str = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
 
     /** Check equality */
     bool equals(const This& c, double tol = 1e-9) const;
--- gtsam-4.0.3.orig/gtsam_unstable/discrete/AllDiff.h
+++ gtsam-4.0.3/gtsam_unstable/discrete/AllDiff.h
@@ -34,11 +34,11 @@ namespace gtsam {
     AllDiff(const DiscreteKeys& dkeys);
 
     // print
-    virtual void print(const std::string& s = "",
-        const KeyFormatter& formatter = DefaultKeyFormatter) const;
+    void print(const std::string& s = "",
+        const KeyFormatter& formatter = DefaultKeyFormatter) const override;
 
     /// equals
-    bool equals(const DiscreteFactor& other, double tol) const {
+    bool equals(const DiscreteFactor& other, double tol) const override {
       if(!dynamic_cast<const AllDiff*>(&other))
         return false;
       else {
@@ -50,13 +50,13 @@ namespace gtsam {
     }
 
     /// Calculate value = expensive !
-    virtual double operator()(const Values& values) const;
+    double operator()(const Values& values) const override;
 
     /// Convert into a decisiontree, can be *very* expensive !
-    virtual DecisionTreeFactor toDecisionTreeFactor() const;
+    DecisionTreeFactor toDecisionTreeFactor() const override;
 
     /// Multiply into a decisiontree
-    virtual DecisionTreeFactor operator*(const DecisionTreeFactor& f) const;
+    DecisionTreeFactor operator*(const DecisionTreeFactor& f) const override;
 
     /*
      * Ensure Arc-consistency
@@ -65,13 +65,13 @@ namespace gtsam {
      * @param j domain to be checked
      * @param domains all other domains
      */
-    bool ensureArcConsistency(size_t j, std::vector<Domain>& domains) const;
+    bool ensureArcConsistency(size_t j, std::vector<Domain>& domains) const override;
 
     /// Partially apply known values
-    virtual Constraint::shared_ptr partiallyApply(const Values&) const;
+    Constraint::shared_ptr partiallyApply(const Values&) const override;
 
     /// Partially apply known values, domain version
-    virtual Constraint::shared_ptr partiallyApply(const std::vector<Domain>&) const;
+    Constraint::shared_ptr partiallyApply(const std::vector<Domain>&) const override;
   };
 
 } // namespace gtsam
--- gtsam-4.0.3.orig/gtsam_unstable/discrete/BinaryAllDiff.h
+++ gtsam-4.0.3/gtsam_unstable/discrete/BinaryAllDiff.h
@@ -33,14 +33,14 @@ namespace gtsam {
     }
 
     // print
-    virtual void print(const std::string& s = "",
-        const KeyFormatter& formatter = DefaultKeyFormatter) const {
+    void print(const std::string& s = "",
+        const KeyFormatter& formatter = DefaultKeyFormatter) const override {
       std::cout << s << "BinaryAllDiff on " << formatter(keys_[0]) << " and "
           << formatter(keys_[1]) << std::endl;
     }
 
     /// equals
-    bool equals(const DiscreteFactor& other, double tol) const {
+    bool equals(const DiscreteFactor& other, double tol) const override {
       if(!dynamic_cast<const BinaryAllDiff*>(&other))
         return false;
       else {
@@ -50,12 +50,12 @@ namespace gtsam {
     }
 
     /// Calculate value
-    virtual double operator()(const Values& values) const {
+    double operator()(const Values& values) const override {
       return (double) (values.at(keys_[0]) != values.at(keys_[1]));
     }
 
     /// Convert into a decisiontree
-    virtual DecisionTreeFactor toDecisionTreeFactor() const {
+    DecisionTreeFactor toDecisionTreeFactor() const override {
       DiscreteKeys keys;
       keys.push_back(DiscreteKey(keys_[0],cardinality0_));
       keys.push_back(DiscreteKey(keys_[1],cardinality1_));
@@ -68,7 +68,7 @@ namespace gtsam {
     }
 
     /// Multiply into a decisiontree
-    virtual DecisionTreeFactor operator*(const DecisionTreeFactor& f) const {
+    DecisionTreeFactor operator*(const DecisionTreeFactor& f) const override {
       // TODO: can we do this more efficiently?
       return toDecisionTreeFactor() * f;
     }
@@ -79,20 +79,20 @@ namespace gtsam {
      * @param domains all other domains
      */
     ///
-    bool ensureArcConsistency(size_t j, std::vector<Domain>& domains) const {
+    bool ensureArcConsistency(size_t j, std::vector<Domain>& domains) const override {
 //      throw std::runtime_error(
 //          "BinaryAllDiff::ensureArcConsistency not implemented");
       return false;
     }
 
     /// Partially apply known values
-    virtual Constraint::shared_ptr partiallyApply(const Values&) const {
+    Constraint::shared_ptr partiallyApply(const Values&) const override {
       throw std::runtime_error("BinaryAllDiff::partiallyApply not implemented");
     }
 
     /// Partially apply known values, domain version
-    virtual Constraint::shared_ptr partiallyApply(
-        const std::vector<Domain>&) const {
+    Constraint::shared_ptr partiallyApply(
+        const std::vector<Domain>&) const override {
       throw std::runtime_error("BinaryAllDiff::partiallyApply not implemented");
     }
   };
--- gtsam-4.0.3.orig/gtsam_unstable/discrete/Domain.h
+++ gtsam-4.0.3/gtsam_unstable/discrete/Domain.h
@@ -66,11 +66,11 @@ namespace gtsam {
     }
 
     // print
-    virtual void print(const std::string& s = "",
-        const KeyFormatter& formatter = DefaultKeyFormatter) const;
+    void print(const std::string& s = "",
+        const KeyFormatter& formatter = DefaultKeyFormatter) const override;
 
     /// equals
-    bool equals(const DiscreteFactor& other, double tol) const {
+    bool equals(const DiscreteFactor& other, double tol) const override {
       if(!dynamic_cast<const Domain*>(&other))
         return false;
       else {
@@ -84,20 +84,20 @@ namespace gtsam {
     }
 
     /// Calculate value
-    virtual double operator()(const Values& values) const;
+    double operator()(const Values& values) const override;
 
     /// Convert into a decisiontree
-    virtual DecisionTreeFactor toDecisionTreeFactor() const;
+    DecisionTreeFactor toDecisionTreeFactor() const override;
 
     /// Multiply into a decisiontree
-    virtual DecisionTreeFactor operator*(const DecisionTreeFactor& f) const;
+    DecisionTreeFactor operator*(const DecisionTreeFactor& f) const override;
 
     /*
      * Ensure Arc-consistency
      * @param j domain to be checked
      * @param domains all other domains
      */
-    bool ensureArcConsistency(size_t j, std::vector<Domain>& domains) const;
+    bool ensureArcConsistency(size_t j, std::vector<Domain>& domains) const override;
 
     /**
      *  Check for a value in domain that does not occur in any other connected domain.
@@ -107,12 +107,11 @@ namespace gtsam {
     bool checkAllDiff(const KeyVector keys, std::vector<Domain>& domains);
 
     /// Partially apply known values
-    virtual Constraint::shared_ptr partiallyApply(
-        const Values& values) const;
+    Constraint::shared_ptr partiallyApply(const Values& values) const override;
 
     /// Partially apply known values, domain version
-    virtual Constraint::shared_ptr partiallyApply(
-        const std::vector<Domain>& domains) const;
+    Constraint::shared_ptr partiallyApply(
+        const std::vector<Domain>& domains) const override;
   };
 
 } // namespace gtsam
--- gtsam-4.0.3.orig/gtsam_unstable/discrete/SingleValue.h
+++ gtsam-4.0.3/gtsam_unstable/discrete/SingleValue.h
@@ -42,11 +42,11 @@ namespace gtsam {
     }
 
     // print
-    virtual void print(const std::string& s = "",
-        const KeyFormatter& formatter = DefaultKeyFormatter) const;
+    void print(const std::string& s = "",
+        const KeyFormatter& formatter = DefaultKeyFormatter) const override;
 
     /// equals
-    bool equals(const DiscreteFactor& other, double tol) const {
+    bool equals(const DiscreteFactor& other, double tol) const override {
       if(!dynamic_cast<const SingleValue*>(&other))
         return false;
       else {
@@ -56,28 +56,27 @@ namespace gtsam {
     }
 
     /// Calculate value
-    virtual double operator()(const Values& values) const;
+    double operator()(const Values& values) const override;
 
     /// Convert into a decisiontree
-    virtual DecisionTreeFactor toDecisionTreeFactor() const;
+    DecisionTreeFactor toDecisionTreeFactor() const override;
 
     /// Multiply into a decisiontree
-    virtual DecisionTreeFactor operator*(const DecisionTreeFactor& f) const;
+    DecisionTreeFactor operator*(const DecisionTreeFactor& f) const override;
 
     /*
      * Ensure Arc-consistency
      * @param j domain to be checked
      * @param domains all other domains
      */
-    bool ensureArcConsistency(size_t j, std::vector<Domain>& domains) const;
+    bool ensureArcConsistency(size_t j, std::vector<Domain>& domains) const override;
 
     /// Partially apply known values
-    virtual Constraint::shared_ptr partiallyApply(
-        const Values& values) const;
+    Constraint::shared_ptr partiallyApply(const Values& values) const override;
 
     /// Partially apply known values, domain version
-    virtual Constraint::shared_ptr partiallyApply(
-        const std::vector<Domain>& domains) const;
+    Constraint::shared_ptr partiallyApply(
+        const std::vector<Domain>& domains) const override;
   };
 
 } // namespace gtsam
--- gtsam-4.0.3.orig/gtsam_unstable/discrete/tests/testScheduler.cpp
+++ gtsam-4.0.3/gtsam_unstable/discrete/tests/testScheduler.cpp
@@ -75,7 +75,7 @@ DiscreteFactorGraph createExpected() {
   // Mutual exclusion for students
   expected.addAllDiff(A, J);
 
-  return expected;
+  return std::move(expected);
 }
 
 /* ************************************************************************* */
--- gtsam-4.0.3.orig/gtsam_unstable/dynamics/FullIMUFactor.h
+++ gtsam-4.0.3/gtsam_unstable/dynamics/FullIMUFactor.h
@@ -51,12 +51,12 @@ public:
   virtual ~FullIMUFactor() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
   /** Check if two factors are equal */
-  virtual bool equals(const NonlinearFactor& e, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& e, double tol = 1e-9) const override {
     const This* const f = dynamic_cast<const This*>(&e);
     return f && Base::equals(e) &&
         equal_with_abs_tol(accel_, f->accel_, tol) &&
@@ -64,7 +64,7 @@ public:
         std::abs(dt_ - f->dt_) < tol;
   }
 
-  void print(const std::string& s="", const gtsam::KeyFormatter& formatter = gtsam::DefaultKeyFormatter) const {
+  void print(const std::string& s="", const gtsam::KeyFormatter& formatter = gtsam::DefaultKeyFormatter) const override {
     std::string a = "FullIMUFactor: " + s;
     Base::print(a, formatter);
     gtsam::print((Vector)accel_, "accel");
@@ -81,9 +81,9 @@ public:
    * Error evaluation with optional derivatives - calculates
    *  z - h(x1,x2)
    */
-  virtual Vector evaluateError(const PoseRTV& x1, const PoseRTV& x2,
+  Vector evaluateError(const PoseRTV& x1, const PoseRTV& x2,
       boost::optional<Matrix&> H1 = boost::none,
-      boost::optional<Matrix&> H2 = boost::none) const {
+      boost::optional<Matrix&> H2 = boost::none) const override {
     Vector9 z;
     z.head(3).operator=(accel_); // Strange syntax to work around ambiguous operator error with clang
     z.segment(3, 3).operator=(gyro_); // Strange syntax to work around ambiguous operator error with clang
--- gtsam-4.0.3.orig/gtsam_unstable/dynamics/IMUFactor.h
+++ gtsam-4.0.3/gtsam_unstable/dynamics/IMUFactor.h
@@ -44,12 +44,12 @@ public:
   virtual ~IMUFactor() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
   /** Check if two factors are equal */
-  virtual bool equals(const NonlinearFactor& e, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& e, double tol = 1e-9) const override {
     const This* const f = dynamic_cast<const This*>(&e);
     return f && Base::equals(e) &&
         equal_with_abs_tol(accel_, f->accel_, tol) &&
@@ -57,7 +57,7 @@ public:
         std::abs(dt_ - f->dt_) < tol;
   }
 
-  void print(const std::string& s="", const gtsam::KeyFormatter& formatter = gtsam::DefaultKeyFormatter) const {
+  void print(const std::string& s="", const gtsam::KeyFormatter& formatter = gtsam::DefaultKeyFormatter) const override {
     std::string a = "IMUFactor: " + s;
     Base::print(a, formatter);
     gtsam::print((Vector)accel_, "accel");
@@ -74,9 +74,9 @@ public:
    * Error evaluation with optional derivatives - calculates
    *  z - h(x1,x2)
    */
-  virtual Vector evaluateError(const PoseRTV& x1, const PoseRTV& x2,
+  Vector evaluateError(const PoseRTV& x1, const PoseRTV& x2,
       boost::optional<Matrix&> H1 = boost::none,
-      boost::optional<Matrix&> H2 = boost::none) const {
+      boost::optional<Matrix&> H2 = boost::none) const override {
     const Vector6 meas = z();
     if (H1) *H1 = numericalDerivative21<Vector6, PoseRTV, PoseRTV>(
         boost::bind(This::predict_proxy, _1, _2, dt_, meas), x1, x2, 1e-5);
--- gtsam-4.0.3.orig/gtsam_unstable/dynamics/Pendulum.h
+++ gtsam-4.0.3/gtsam_unstable/dynamics/Pendulum.h
@@ -40,7 +40,7 @@ public:
   : Base(noiseModel::Constrained::All(1, std::abs(mu)), k1, k, velKey), h_(h) {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new PendulumFactor1(*this))); }
 
@@ -48,7 +48,7 @@ public:
   Vector evaluateError(const double& qk1, const double& qk, const double& v,
       boost::optional<Matrix&> H1 = boost::none,
       boost::optional<Matrix&> H2 = boost::none,
-      boost::optional<Matrix&> H3 = boost::none) const {
+      boost::optional<Matrix&> H3 = boost::none) const override {
     const size_t p = 1;
     if (H1) *H1 = -Matrix::Identity(p,p);
     if (H2) *H2 = Matrix::Identity(p,p);
@@ -88,7 +88,7 @@ public:
   : Base(noiseModel::Constrained::All(1, std::abs(mu)), vk1, vk, qkey), h_(h), g_(g), r_(r) {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new PendulumFactor2(*this))); }
 
@@ -96,7 +96,7 @@ public:
   Vector evaluateError(const double & vk1, const double & vk, const double & q,
       boost::optional<Matrix&> H1 = boost::none,
       boost::optional<Matrix&> H2 = boost::none,
-      boost::optional<Matrix&> H3 = boost::none) const {
+      boost::optional<Matrix&> H3 = boost::none) const override {
     const size_t p = 1;
     if (H1) *H1 = -Matrix::Identity(p,p);
     if (H2) *H2 = Matrix::Identity(p,p);
@@ -139,7 +139,7 @@ public:
     h_(h), m_(m), r_(r), g_(g), alpha_(alpha) {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new PendulumFactorPk(*this))); }
 
@@ -147,7 +147,7 @@ public:
   Vector evaluateError(const double & pk, const double & qk, const double & qk1,
       boost::optional<Matrix&> H1 = boost::none,
       boost::optional<Matrix&> H2 = boost::none,
-      boost::optional<Matrix&> H3 = boost::none) const {
+      boost::optional<Matrix&> H3 = boost::none) const override {
     const size_t p = 1;
 
     double qmid = (1-alpha_)*qk + alpha_*qk1;
@@ -195,7 +195,7 @@ public:
     h_(h), m_(m), r_(r), g_(g), alpha_(alpha) {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new PendulumFactorPk1(*this))); }
 
@@ -203,7 +203,7 @@ public:
   Vector evaluateError(const double & pk1, const double & qk, const double & qk1,
       boost::optional<Matrix&> H1 = boost::none,
       boost::optional<Matrix&> H2 = boost::none,
-      boost::optional<Matrix&> H3 = boost::none) const {
+      boost::optional<Matrix&> H3 = boost::none) const override {
     const size_t p = 1;
 
     double qmid = (1-alpha_)*qk + alpha_*qk1;
--- gtsam-4.0.3.orig/gtsam_unstable/dynamics/SimpleHelicopter.h
+++ gtsam-4.0.3/gtsam_unstable/dynamics/SimpleHelicopter.h
@@ -36,7 +36,7 @@ public:
   virtual ~Reconstruction() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new Reconstruction(*this))); }
 
@@ -44,7 +44,7 @@ public:
   Vector evaluateError(const Pose3& gk1, const Pose3& gk, const Vector6& xik,
       boost::optional<Matrix&> H1 = boost::none,
       boost::optional<Matrix&> H2 = boost::none,
-      boost::optional<Matrix&> H3 = boost::none) const {
+      boost::optional<Matrix&> H3 = boost::none) const override {
 
     Matrix6 D_exphxi_xi;
     Pose3 exphxi = Pose3::Expmap(h_ * xik, H3 ? &D_exphxi_xi : 0);
@@ -98,7 +98,7 @@ public:
   virtual ~DiscreteEulerPoincareHelicopter() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new DiscreteEulerPoincareHelicopter(*this))); }
 
@@ -110,7 +110,7 @@ public:
   Vector evaluateError(const Vector6& xik, const Vector6& xik_1, const Pose3& gk,
       boost::optional<Matrix&> H1 = boost::none,
       boost::optional<Matrix&> H2 = boost::none,
-      boost::optional<Matrix&> H3 = boost::none) const {
+      boost::optional<Matrix&> H3 = boost::none) const override {
 
     Vector muk = Inertia_*xik;
     Vector muk_1 = Inertia_*xik_1;
--- gtsam-4.0.3.orig/gtsam_unstable/dynamics/VelocityConstraint.h
+++ gtsam-4.0.3/gtsam_unstable/dynamics/VelocityConstraint.h
@@ -73,16 +73,16 @@ public:
   virtual ~VelocityConstraint() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new VelocityConstraint(*this))); }
 
   /**
    * Calculates the error for trapezoidal model given
    */
-  virtual gtsam::Vector evaluateError(const PoseRTV& x1, const PoseRTV& x2,
+  gtsam::Vector evaluateError(const PoseRTV& x1, const PoseRTV& x2,
       boost::optional<gtsam::Matrix&> H1=boost::none,
-      boost::optional<gtsam::Matrix&> H2=boost::none) const {
+      boost::optional<gtsam::Matrix&> H2=boost::none) const override {
     if (H1) *H1 = gtsam::numericalDerivative21<gtsam::Vector,PoseRTV,PoseRTV>(
         boost::bind(VelocityConstraint::evaluateError_, _1, _2, dt_, integration_mode_), x1, x2, 1e-5);
     if (H2) *H2 = gtsam::numericalDerivative22<gtsam::Vector,PoseRTV,PoseRTV>(
@@ -90,7 +90,7 @@ public:
     return evaluateError_(x1, x2, dt_, integration_mode_);
   }
 
-  virtual void print(const std::string& s = "", const gtsam::KeyFormatter& formatter = gtsam::DefaultKeyFormatter) const {
+  void print(const std::string& s = "", const gtsam::KeyFormatter& formatter = gtsam::DefaultKeyFormatter) const override {
     std::string a = "VelocityConstraint: " + s;
     Base::print(a, formatter);
     switch(integration_mode_) {
--- gtsam-4.0.3.orig/gtsam_unstable/dynamics/VelocityConstraint3.h
+++ gtsam-4.0.3/gtsam_unstable/dynamics/VelocityConstraint3.h
@@ -31,7 +31,7 @@ public:
   virtual ~VelocityConstraint3() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new VelocityConstraint3(*this))); }
 
@@ -39,7 +39,7 @@ public:
   Vector evaluateError(const double& x1, const double& x2, const double& v,
       boost::optional<Matrix&> H1 = boost::none,
       boost::optional<Matrix&> H2 = boost::none,
-      boost::optional<Matrix&> H3 = boost::none) const {
+      boost::optional<Matrix&> H3 = boost::none) const override {
     const size_t p = 1;
     if (H1) *H1 = Matrix::Identity(p,p);
     if (H2) *H2 = -Matrix::Identity(p,p);
--- gtsam-4.0.3.orig/gtsam_unstable/geometry/tests/testSimilarity3.cpp
+++ gtsam-4.0.3/gtsam_unstable/geometry/tests/testSimilarity3.cpp
@@ -244,7 +244,7 @@ TEST(Similarity3, GroupAction) {
       &Similarity3::transformFrom, _1, _2, boost::none, boost::none);
 
   Point3 q(1, 2, 3);
-  for (const auto T : { T1, T2, T3, T4, T5, T6 }) {
+  for (const auto& T : { T1, T2, T3, T4, T5, T6 }) {
     Point3 q(1, 0, 0);
     Matrix H1 = numericalDerivative21<Point3, Similarity3, Point3>(f, T, q);
     Matrix H2 = numericalDerivative22<Point3, Similarity3, Point3>(f, T, q);
--- gtsam-4.0.3.orig/gtsam_unstable/linear/InfeasibleInitialValues.h
+++ gtsam-4.0.3/gtsam_unstable/linear/InfeasibleInitialValues.h
@@ -29,10 +29,10 @@ public:
   InfeasibleInitialValues() {
   }
 
-  virtual ~InfeasibleInitialValues() throw () {
+  virtual ~InfeasibleInitialValues() noexcept {
   }
 
-  virtual const char *what() const throw () {
+  const char *what() const noexcept override {
     if (description_.empty())
       description_ =
           "An infeasible initial value was provided for the solver.\n";
--- gtsam-4.0.3.orig/gtsam_unstable/linear/InfeasibleOrUnboundedProblem.h
+++ gtsam-4.0.3/gtsam_unstable/linear/InfeasibleOrUnboundedProblem.h
@@ -25,10 +25,10 @@ class InfeasibleOrUnboundedProblem: publ
 public:
   InfeasibleOrUnboundedProblem() {
   }
-  virtual ~InfeasibleOrUnboundedProblem() throw () {
+  virtual ~InfeasibleOrUnboundedProblem() noexcept {
   }
 
-  virtual const char* what() const throw () {
+  const char* what() const noexcept override {
     if (description_.empty())
       description_ = "The problem is either infeasible or unbounded.\n";
     return description_.c_str();
--- gtsam-4.0.3.orig/gtsam_unstable/linear/LinearCost.h
+++ gtsam-4.0.3/gtsam_unstable/linear/LinearCost.h
@@ -88,18 +88,18 @@ public:
   }
 
   /** equals */
-  virtual bool equals(const GaussianFactor& lf, double tol = 1e-9) const {
+  bool equals(const GaussianFactor& lf, double tol = 1e-9) const override {
     return Base::equals(lf, tol);
   }
 
   /** print */
-  virtual void print(const std::string& s = "", const KeyFormatter& formatter =
-      DefaultKeyFormatter) const {
+  void print(const std::string& s = "", const KeyFormatter& formatter =
+      DefaultKeyFormatter) const override {
     Base::print(s + " LinearCost: ", formatter);
   }
 
   /** Clone this LinearCost */
-  virtual GaussianFactor::shared_ptr clone() const {
+  GaussianFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast < GaussianFactor
         > (boost::make_shared < LinearCost > (*this));
   }
@@ -110,7 +110,7 @@ public:
   }
 
   /** Special error for single-valued inequality constraints. */
-  virtual double error(const VectorValues& c) const {
+  double error(const VectorValues& c) const override {
     return error_vector(c)[0];
   }
 };
--- gtsam-4.0.3.orig/gtsam_unstable/linear/LinearEquality.h
+++ gtsam-4.0.3/gtsam_unstable/linear/LinearEquality.h
@@ -89,18 +89,18 @@ public:
   }
 
   /** equals */
-  virtual bool equals(const GaussianFactor& lf, double tol = 1e-9) const {
+  bool equals(const GaussianFactor& lf, double tol = 1e-9) const override {
     return Base::equals(lf, tol);
   }
 
   /** print */
-  virtual void print(const std::string& s = "", const KeyFormatter& formatter =
-      DefaultKeyFormatter) const {
+  void print(const std::string& s = "", const KeyFormatter& formatter =
+      DefaultKeyFormatter) const override {
     Base::print(s, formatter);
   }
 
   /** Clone this LinearEquality */
-  virtual GaussianFactor::shared_ptr clone() const {
+  GaussianFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast < GaussianFactor
         > (boost::make_shared < LinearEquality > (*this));
   }
@@ -124,7 +124,7 @@ public:
    * I think it should be zero, as this function is meant for objective cost.
    * But the name "error" can be misleading.
    * TODO: confirm with Frank!! */
-  virtual double error(const VectorValues& c) const {
+  double error(const VectorValues& c) const override {
     return 0.0;
   }
 
--- gtsam-4.0.3.orig/gtsam_unstable/linear/LinearInequality.h
+++ gtsam-4.0.3/gtsam_unstable/linear/LinearInequality.h
@@ -100,13 +100,13 @@ public:
   }
 
   /** equals */
-  virtual bool equals(const GaussianFactor& lf, double tol = 1e-9) const {
+  bool equals(const GaussianFactor& lf, double tol = 1e-9) const override {
     return Base::equals(lf, tol);
   }
 
   /** print */
-  virtual void print(const std::string& s = "", const KeyFormatter& formatter =
-      DefaultKeyFormatter) const {
+  void print(const std::string& s = "", const KeyFormatter& formatter =
+      DefaultKeyFormatter) const override {
     if (active())
       Base::print(s + "  Active", formatter);
     else
@@ -114,7 +114,7 @@ public:
   }
 
   /** Clone this LinearInequality */
-  virtual GaussianFactor::shared_ptr clone() const {
+  GaussianFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast < GaussianFactor
         > (boost::make_shared < LinearInequality > (*this));
   }
@@ -145,7 +145,7 @@ public:
   }
 
   /** Special error for single-valued inequality constraints. */
-  virtual double error(const VectorValues& c) const {
+  double error(const VectorValues& c) const override {
     return error_vector(c)[0];
   }
 
--- gtsam-4.0.3.orig/gtsam_unstable/linear/QPSParserException.h
+++ gtsam-4.0.3/gtsam_unstable/linear/QPSParserException.h
@@ -25,10 +25,10 @@ public:
   QPSParserException() {
   }
 
-  virtual ~QPSParserException() throw () {
+  virtual ~QPSParserException() noexcept {
   }
 
-  virtual const char *what() const throw () {
+  const char *what() const noexcept override {
     if (description_.empty())
       description_ = "There is a problem parsing the QPS file.\n";
     return description_.c_str();
--- gtsam-4.0.3.orig/gtsam_unstable/nonlinear/BatchFixedLagSmoother.h
+++ gtsam-4.0.3/gtsam_unstable/nonlinear/BatchFixedLagSmoother.h
@@ -41,10 +41,10 @@ public:
   virtual ~BatchFixedLagSmoother() { };
 
   /** Print the factor for debugging and testing (implementing Testable) */
-  virtual void print(const std::string& s = "BatchFixedLagSmoother:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
+  void print(const std::string& s = "BatchFixedLagSmoother:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** Check if two IncrementalFixedLagSmoother Objects are equal */
-  virtual bool equals(const FixedLagSmoother& rhs, double tol = 1e-9) const override;
+  bool equals(const FixedLagSmoother& rhs, double tol = 1e-9) const override;
 
   /** Add new factors, updating the solution and relinearizing as needed. */
   Result update(const NonlinearFactorGraph& newFactors = NonlinearFactorGraph(),
@@ -117,15 +117,6 @@ public:
       const NonlinearFactorGraph& graph, const Values& theta, const KeyVector& keys,
       const GaussianFactorGraph::Eliminate& eliminateFunction = EliminatePreferCholesky);
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-  static NonlinearFactorGraph calculateMarginalFactors(
-      const NonlinearFactorGraph& graph, const Values& theta, const std::set<Key>& keys,
-      const GaussianFactorGraph::Eliminate& eliminateFunction = EliminatePreferCholesky) {
-    KeyVector keyVector(keys.begin(), keys.end());
-    return CalculateMarginalFactors(graph, theta, keyVector, eliminateFunction);
-  }
-#endif
-
 protected:
 
   /** A typedef defining an Key-Factor mapping **/
--- gtsam-4.0.3.orig/gtsam_unstable/nonlinear/ConcurrentBatchFilter.h
+++ gtsam-4.0.3/gtsam_unstable/nonlinear/ConcurrentBatchFilter.h
@@ -67,10 +67,10 @@ public:
   virtual ~ConcurrentBatchFilter() {};
 
   /** Implement a GTSAM standard 'print' function */
-  virtual void print(const std::string& s = "Concurrent Batch Filter:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s = "Concurrent Batch Filter:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** Check if two Concurrent Filters are equal */
-  virtual bool equals(const ConcurrentFilter& rhs, double tol = 1e-9) const;
+  bool equals(const ConcurrentFilter& rhs, double tol = 1e-9) const override;
 
   /** Access the current set of factors */
   const NonlinearFactorGraph& getFactors() const {
@@ -130,7 +130,7 @@ public:
    * Perform any required operations before the synchronization process starts.
    * Called by 'synchronize'
    */
-  virtual void presync();
+  virtual void presync() override;
 
   /**
    * Populate the provided containers with factors that constitute the filter branch summarization
@@ -139,7 +139,7 @@ public:
    * @param summarizedFactors The summarized factors for the filter branch
    * @param rootValues The linearization points of the root clique variables
    */
-  virtual void getSummarizedFactors(NonlinearFactorGraph& filterSummarization, Values& filterSummarizationValues);
+  void getSummarizedFactors(NonlinearFactorGraph& filterSummarization, Values& filterSummarizationValues) override;
 
   /**
    * Populate the provided containers with factors being sent to the smoother from the filter. These
@@ -149,20 +149,20 @@ public:
    * @param smootherFactors The new factors to be added to the smoother
    * @param smootherValues The linearization points of any new variables
    */
-  virtual void getSmootherFactors(NonlinearFactorGraph& smootherFactors, Values& smootherValues);
+  void getSmootherFactors(NonlinearFactorGraph& smootherFactors, Values& smootherValues) override;
 
   /**
    * Apply the updated version of the smoother branch summarized factors.
    *
    * @param summarizedFactors An updated version of the smoother branch summarized factors
    */
-  virtual void synchronize(const NonlinearFactorGraph& smootherSummarization, const Values& smootherSummarizationValues);
+  void synchronize(const NonlinearFactorGraph& smootherSummarization, const Values& smootherSummarizationValues) override;
 
   /**
    * Perform any required operations after the synchronization process finishes.
    * Called by 'synchronize'
    */
-  virtual void postsync();
+  virtual void postsync() override;
 
 protected:
 
--- gtsam-4.0.3.orig/gtsam_unstable/nonlinear/ConcurrentBatchSmoother.h
+++ gtsam-4.0.3/gtsam_unstable/nonlinear/ConcurrentBatchSmoother.h
@@ -60,10 +60,10 @@ public:
   virtual ~ConcurrentBatchSmoother() {};
 
   /** Implement a GTSAM standard 'print' function */
-  virtual void print(const std::string& s = "Concurrent Batch Smoother:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s = "Concurrent Batch Smoother:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** Check if two Concurrent Smoothers are equal */
-  virtual bool equals(const ConcurrentSmoother& rhs, double tol = 1e-9) const;
+  bool equals(const ConcurrentSmoother& rhs, double tol = 1e-9) const override;
 
   /** Access the current set of factors */
   const NonlinearFactorGraph& getFactors() const {
@@ -124,7 +124,7 @@ public:
    * Perform any required operations before the synchronization process starts.
    * Called by 'synchronize'
    */
-  virtual void presync();
+  virtual void presync() override;
 
   /**
    * Populate the provided containers with factors that constitute the smoother branch summarization
@@ -132,7 +132,7 @@ public:
    *
    * @param summarizedFactors The summarized factors for the filter branch
    */
-  virtual void getSummarizedFactors(NonlinearFactorGraph& summarizedFactors, Values& separatorValues);
+  void getSummarizedFactors(NonlinearFactorGraph& summarizedFactors, Values& separatorValues) override;
 
   /**
    * Apply the new smoother factors sent by the filter, and the updated version of the filter
@@ -143,14 +143,14 @@ public:
    * @param summarizedFactors An updated version of the filter branch summarized factors
    * @param rootValues The linearization point of the root variables
    */
-  virtual void synchronize(const NonlinearFactorGraph& smootherFactors, const Values& smootherValues,
-      const NonlinearFactorGraph& summarizedFactors, const Values& separatorValues);
+  void synchronize(const NonlinearFactorGraph& smootherFactors, const Values& smootherValues,
+      const NonlinearFactorGraph& summarizedFactors, const Values& separatorValues) override;
 
   /**
    * Perform any required operations after the synchronization process finishes.
    * Called by 'synchronize'
    */
-  virtual void postsync();
+  virtual void postsync() override;
 
 protected:
 
--- gtsam-4.0.3.orig/gtsam_unstable/nonlinear/ConcurrentIncrementalFilter.h
+++ gtsam-4.0.3/gtsam_unstable/nonlinear/ConcurrentIncrementalFilter.h
@@ -67,10 +67,10 @@ public:
   virtual ~ConcurrentIncrementalFilter() {};
 
   /** Implement a GTSAM standard 'print' function */
-  virtual void print(const std::string& s = "Concurrent Incremental Filter:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s = "Concurrent Incremental Filter:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** Check if two Concurrent Filters are equal */
-  virtual bool equals(const ConcurrentFilter& rhs, double tol = 1e-9) const;
+  bool equals(const ConcurrentFilter& rhs, double tol = 1e-9) const override;
 
   /** Access the current set of factors */
   const NonlinearFactorGraph& getFactors() const {
@@ -130,7 +130,7 @@ public:
    * Perform any required operations before the synchronization process starts.
    * Called by 'synchronize'
    */
-  virtual void presync();
+  void presync() override;
 
   /**
    * Populate the provided containers with factors that constitute the filter branch summarization
@@ -139,7 +139,7 @@ public:
    * @param summarizedFactors The summarized factors for the filter branch
    * @param rootValues The linearization points of the root clique variables
    */
-  virtual void getSummarizedFactors(NonlinearFactorGraph& filterSummarization, Values& filterSummarizationValues);
+  void getSummarizedFactors(NonlinearFactorGraph& filterSummarization, Values& filterSummarizationValues) override;
 
   /**
    * Populate the provided containers with factors being sent to the smoother from the filter. These
@@ -149,20 +149,20 @@ public:
    * @param smootherFactors The new factors to be added to the smoother
    * @param smootherValues The linearization points of any new variables
    */
-  virtual void getSmootherFactors(NonlinearFactorGraph& smootherFactors, Values& smootherValues);
+  void getSmootherFactors(NonlinearFactorGraph& smootherFactors, Values& smootherValues) override;
 
   /**
    * Apply the updated version of the smoother branch summarized factors.
    *
    * @param summarizedFactors An updated version of the smoother branch summarized factors
    */
-  virtual void synchronize(const NonlinearFactorGraph& smootherSummarization, const Values& smootherSummarizationValues);
+  void synchronize(const NonlinearFactorGraph& smootherSummarization, const Values& smootherSummarizationValues) override;
 
   /**
    * Perform any required operations after the synchronization process finishes.
    * Called by 'synchronize'
    */
-  virtual void postsync();
+  void postsync() override;
 
 protected:
 
--- gtsam-4.0.3.orig/gtsam_unstable/nonlinear/ConcurrentIncrementalSmoother.h
+++ gtsam-4.0.3/gtsam_unstable/nonlinear/ConcurrentIncrementalSmoother.h
@@ -57,10 +57,10 @@ public:
   virtual ~ConcurrentIncrementalSmoother() {};
 
   /** Implement a GTSAM standard 'print' function */
-  virtual void print(const std::string& s = "Concurrent Incremental Smoother:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s = "Concurrent Incremental Smoother:\n", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** Check if two Concurrent Smoothers are equal */
-  virtual bool equals(const ConcurrentSmoother& rhs, double tol = 1e-9) const;
+  bool equals(const ConcurrentSmoother& rhs, double tol = 1e-9) const override;
 
   /** Access the current set of factors */
   const NonlinearFactorGraph& getFactors() const {
@@ -115,7 +115,7 @@ public:
    * Perform any required operations before the synchronization process starts.
    * Called by 'synchronize'
    */
-  virtual void presync();
+  void presync() override;
 
   /**
    * Populate the provided containers with factors that constitute the smoother branch summarization
@@ -123,7 +123,7 @@ public:
    *
    * @param summarizedFactors The summarized factors for the filter branch
    */
-  virtual void getSummarizedFactors(NonlinearFactorGraph& summarizedFactors, Values& separatorValues);
+  void getSummarizedFactors(NonlinearFactorGraph& summarizedFactors, Values& separatorValues) override;
 
   /**
    * Apply the new smoother factors sent by the filter, and the updated version of the filter
@@ -134,14 +134,14 @@ public:
    * @param summarizedFactors An updated version of the filter branch summarized factors
    * @param rootValues The linearization point of the root variables
    */
-  virtual void synchronize(const NonlinearFactorGraph& smootherFactors, const Values& smootherValues,
-      const NonlinearFactorGraph& summarizedFactors, const Values& separatorValues);
+  void synchronize(const NonlinearFactorGraph& smootherFactors, const Values& smootherValues,
+      const NonlinearFactorGraph& summarizedFactors, const Values& separatorValues) override;
 
   /**
    * Perform any required operations after the synchronization process finishes.
    * Called by 'synchronize'
    */
-  virtual void postsync();
+  void postsync() override;
 
 protected:
 
--- gtsam-4.0.3.orig/gtsam_unstable/nonlinear/LinearizedFactor.h
+++ gtsam-4.0.3/gtsam_unstable/nonlinear/LinearizedFactor.h
@@ -112,17 +112,17 @@ public:
   virtual ~LinearizedJacobianFactor() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
   // Testable
 
   /** print function */
-  virtual void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** equals function with optional tolerance */
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
 
   // access functions
   const constBVector b() const { return Ab_(size()).col(0); }
@@ -130,17 +130,17 @@ public:
   const constABlock A(Key key) const { return Ab_(std::find(begin(), end(), key) - begin()); }
 
   /** get the dimension of the factor (number of rows on linearization) */
-  size_t dim() const { return Ab_.rows(); };
+  size_t dim() const override { return Ab_.rows(); };
 
   /** Calculate the error of the factor */
-  double error(const Values& c) const;
+  double error(const Values& c) const override;
 
   /**
    * linearize to a GaussianFactor
    * Reimplemented from NoiseModelFactor to directly copy out the
    * matrices and only update the RHS b with an updated residual
    */
-  boost::shared_ptr<GaussianFactor> linearize(const Values& c) const;
+  boost::shared_ptr<GaussianFactor> linearize(const Values& c) const override;
 
   /** (A*x-b) */
   Vector error_vector(const Values& c) const;
@@ -202,17 +202,17 @@ public:
   virtual ~LinearizedHessianFactor() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
   // Testable
 
   /** print function */
-  virtual void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** equals function with optional tolerance */
-  virtual bool equals(const NonlinearFactor& expected, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol = 1e-9) const override;
 
   /** Return the constant term \f$ f \f$ as described above
    * @return The constant term \f$ f \f$
@@ -261,17 +261,17 @@ public:
   }
 
   /** get the dimension of the factor (number of rows on linearization) */
-  size_t dim() const { return info_.rows() - 1; }
+  size_t dim() const override { return info_.rows() - 1; }
 
   /** Calculate the error of the factor */
-  double error(const Values& c) const;
+  double error(const Values& c) const override;
 
   /**
    * linearize to a GaussianFactor
    * Reimplemented from NoiseModelFactor to directly copy out the
    * matrices and only update the RHS b with an updated residual
    */
-  boost::shared_ptr<GaussianFactor> linearize(const Values& c) const;
+  boost::shared_ptr<GaussianFactor> linearize(const Values& c) const override;
 
 private:
   /** Serialization function */
--- gtsam-4.0.3.orig/gtsam_unstable/slam/BetweenFactorEM.h
+++ gtsam-4.0.3/gtsam_unstable/slam/BetweenFactorEM.h
@@ -84,8 +84,8 @@ public:
   /** implement functions needed for Testable */
 
   /** print */
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const {
+  void print(const std::string& s, const KeyFormatter& keyFormatter =
+      DefaultKeyFormatter) const override {
     std::cout << s << "BetweenFactorEM(" << keyFormatter(key1_) << ","
         << keyFormatter(key2_) << ")\n";
     measured_.print("  measured: ");
@@ -97,7 +97,7 @@ public:
   }
 
   /** equals */
-  virtual bool equals(const NonlinearFactor& f, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& f, double tol = 1e-9) const override {
     const This *t = dynamic_cast<const This*>(&f);
 
     if (t && Base::equals(f))
@@ -403,12 +403,7 @@ public:
     return measured_;
   }
 
-  /** number of variables attached to this factor */
-  std::size_t size() const {
-    return 2;
-  }
-
-  virtual size_t dim() const {
+  size_t dim() const override {
     return model_inlier_->R().rows() + model_inlier_->R().cols();
   }
 
--- gtsam-4.0.3.orig/gtsam_unstable/slam/BiasedGPSFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/BiasedGPSFactor.h
@@ -55,7 +55,7 @@ namespace gtsam {
     /** implement functions needed for Testable */
 
     /** print */
-    virtual void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "BiasedGPSFactor("
           << keyFormatter(this->key1()) << ","
           << keyFormatter(this->key2()) << ")\n"
@@ -64,7 +64,7 @@ namespace gtsam {
     }
 
     /** equals */
-    virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+    bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
       const This *e =  dynamic_cast<const This*> (&expected);
       return e != nullptr && Base::equals(*e, tol) && traits<Point3>::Equals(this->measured_, e->measured_, tol);
     }
@@ -74,7 +74,7 @@ namespace gtsam {
     /** vector of errors */
     Vector evaluateError(const Pose3& pose, const Point3& bias,
         boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 =
-            boost::none) const {
+            boost::none) const override {
 
       if (H1 || H2){
         H1->resize(3,6); // jacobian wrt pose
--- gtsam-4.0.3.orig/gtsam_unstable/slam/DummyFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/DummyFactor.h
@@ -34,10 +34,10 @@ public:
   // testable
 
   /** print */
-  virtual void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
   /** Check if two factors are equal */
-  virtual bool equals(const NonlinearFactor& f, double tol = 1e-9) const;
+  bool equals(const NonlinearFactor& f, double tol = 1e-9) const override;
 
   // access
 
@@ -48,13 +48,13 @@ public:
   /**
    * Calculate the error of the factor - zero for dummy factors
    */
-  virtual double error(const Values& c) const { return 0.0; }
+  double error(const Values& c) const override { return 0.0; }
 
   /** get the dimension of the factor (number of rows on linearization) */
-  virtual size_t dim() const { return rowDim_; }
+  size_t dim() const override { return rowDim_; }
 
   /** linearize to a GaussianFactor */
-  virtual boost::shared_ptr<GaussianFactor> linearize(const Values& c) const;
+  boost::shared_ptr<GaussianFactor> linearize(const Values& c) const override;
 
   /**
    * Creates a shared_ptr clone of the factor - needs to be specialized to allow
@@ -62,7 +62,7 @@ public:
    *
    * By default, throws exception if subclass does not implement the function.
    */
-  virtual NonlinearFactor::shared_ptr clone() const {
+  NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<NonlinearFactor>(
         NonlinearFactor::shared_ptr(new DummyFactor(*this)));
   }
--- gtsam-4.0.3.orig/gtsam_unstable/slam/EquivInertialNavFactor_GlobalVel.h
+++ gtsam-4.0.3/gtsam_unstable/slam/EquivInertialNavFactor_GlobalVel.h
@@ -133,7 +133,7 @@ public:
   /** implement functions needed for Testable */
 
   /** print */
-  virtual void print(const std::string& s = "EquivInertialNavFactor_GlobalVel", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "EquivInertialNavFactor_GlobalVel", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << "("
         << keyFormatter(this->key1()) << ","
         << keyFormatter(this->key2()) << ","
@@ -153,7 +153,7 @@ public:
   }
 
   /** equals */
-  virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+  bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
     const This *e =  dynamic_cast<const This*> (&expected);
     return e != nullptr && Base::equals(*e, tol)
     && (delta_pos_in_t0_ - e->delta_pos_in_t0_).norm() < tol
@@ -302,7 +302,7 @@ public:
       boost::optional<Matrix&> H2 = boost::none,
       boost::optional<Matrix&> H3 = boost::none,
       boost::optional<Matrix&> H4 = boost::none,
-      boost::optional<Matrix&> H5 = boost::none) const {
+      boost::optional<Matrix&> H5 = boost::none) const override {
 
     // TODO: Write analytical derivative calculations
     // Jacobian w.r.t. Pose1
--- gtsam-4.0.3.orig/gtsam_unstable/slam/EquivInertialNavFactor_GlobalVel_NoBias.h
+++ gtsam-4.0.3/gtsam_unstable/slam/EquivInertialNavFactor_GlobalVel_NoBias.h
@@ -151,7 +151,7 @@ public:
   }
 
   /** equals */
-  virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+  bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
     const This *e =  dynamic_cast<const This*> (&expected);
     return e != nullptr && Base::equals(*e, tol)
     && (delta_pos_in_t0_ - e->delta_pos_in_t0_).norm() < tol
--- gtsam-4.0.3.orig/gtsam_unstable/slam/GaussMarkov1stOrderFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/GaussMarkov1stOrderFactor.h
@@ -71,7 +71,7 @@ public:
   /** implement functions needed for Testable */
 
   /** print */
-  virtual void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << "GaussMarkov1stOrderFactor("
         << keyFormatter(this->key1()) << ","
         << keyFormatter(this->key2()) << ")\n";
@@ -79,7 +79,7 @@ public:
   }
 
   /** equals */
-  virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+  bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
     const This *e =  dynamic_cast<const This*> (&expected);
     return e != nullptr && Base::equals(*e, tol);
   }
@@ -89,7 +89,7 @@ public:
   /** vector of errors */
   Vector evaluateError(const VALUE& p1, const VALUE& p2,
       boost::optional<Matrix&> H1 = boost::none,
-      boost::optional<Matrix&> H2 = boost::none) const {
+      boost::optional<Matrix&> H2 = boost::none) const override {
 
     Vector v1( traits<VALUE>::Logmap(p1) );
     Vector v2( traits<VALUE>::Logmap(p2) );
--- gtsam-4.0.3.orig/gtsam_unstable/slam/InertialNavFactor_GlobalVelocity.h
+++ gtsam-4.0.3/gtsam_unstable/slam/InertialNavFactor_GlobalVelocity.h
@@ -114,7 +114,7 @@ public:
   /** implement functions needed for Testable */
 
   /** print */
-  virtual void print(const std::string& s = "InertialNavFactor_GlobalVelocity", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "InertialNavFactor_GlobalVelocity", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << "("
         << keyFormatter(this->key1()) << ","
         << keyFormatter(this->key2()) << ","
@@ -133,7 +133,7 @@ public:
   }
 
   /** equals */
-  virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+  bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
     const This *e =  dynamic_cast<const This*> (&expected);
     return e != nullptr && Base::equals(*e, tol)
       && (measurement_acc_ - e->measurement_acc_).norm() < tol
@@ -229,7 +229,7 @@ public:
       boost::optional<Matrix&> H2 = boost::none,
       boost::optional<Matrix&> H3 = boost::none,
       boost::optional<Matrix&> H4 = boost::none,
-      boost::optional<Matrix&> H5 = boost::none) const {
+      boost::optional<Matrix&> H5 = boost::none) const override {
 
     // TODO: Write analytical derivative calculations
     // Jacobian w.r.t. Pose1
--- gtsam-4.0.3.orig/gtsam_unstable/slam/InvDepthFactor3.h
+++ gtsam-4.0.3/gtsam_unstable/slam/InvDepthFactor3.h
@@ -70,13 +70,13 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "InvDepthFactor3",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s, keyFormatter);
     traits<Point2>::Print(measured_, s + ".z");
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*>(&p);
     return e && Base::equals(p, tol) && traits<Point2>::Equals(this->measured_, e->measured_, tol) && this->K_->equals(*e->K_, tol);
   }
@@ -85,7 +85,7 @@ public:
   Vector evaluateError(const POSE& pose, const Vector5& point, const INVDEPTH& invDepth,
       boost::optional<Matrix&> H1=boost::none,
       boost::optional<Matrix&> H2=boost::none,
-      boost::optional<Matrix&> H3=boost::none) const {
+      boost::optional<Matrix&> H3=boost::none) const override {
     try {
       InvDepthCamera3<Cal3_S2> camera(pose, K_);
       return camera.project(point, invDepth, H1, H2, H3) - measured_;
--- gtsam-4.0.3.orig/gtsam_unstable/slam/InvDepthFactorVariant1.h
+++ gtsam-4.0.3/gtsam_unstable/slam/InvDepthFactorVariant1.h
@@ -66,13 +66,13 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "InvDepthFactorVariant1",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s, keyFormatter);
     traits<Point2>::Print(measured_, s + ".z");
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*>(&p);
     return e
         && Base::equals(p, tol)
@@ -102,7 +102,7 @@ public:
   /// Evaluate error h(x)-z and optionally derivatives
   Vector evaluateError(const Pose3& pose, const Vector6& landmark,
       boost::optional<Matrix&> H1=boost::none,
-      boost::optional<Matrix&> H2=boost::none) const {
+      boost::optional<Matrix&> H2=boost::none) const override {
 
     if (H1) {
       (*H1) = numericalDerivative11<Vector, Pose3>(
--- gtsam-4.0.3.orig/gtsam_unstable/slam/InvDepthFactorVariant2.h
+++ gtsam-4.0.3/gtsam_unstable/slam/InvDepthFactorVariant2.h
@@ -69,13 +69,13 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "InvDepthFactorVariant2",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s, keyFormatter);
     traits<Point2>::Print(measured_, s + ".z");
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*>(&p);
     return e
         && Base::equals(p, tol)
@@ -105,7 +105,7 @@ public:
   /// Evaluate error h(x)-z and optionally derivatives
   Vector evaluateError(const Pose3& pose, const Vector3& landmark,
       boost::optional<Matrix&> H1=boost::none,
-      boost::optional<Matrix&> H2=boost::none) const {
+      boost::optional<Matrix&> H2=boost::none) const override {
 
     if (H1) {
       (*H1) = numericalDerivative11<Vector, Pose3>(
--- gtsam-4.0.3.orig/gtsam_unstable/slam/InvDepthFactorVariant3.h
+++ gtsam-4.0.3/gtsam_unstable/slam/InvDepthFactorVariant3.h
@@ -68,13 +68,13 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "InvDepthFactorVariant3a",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s, keyFormatter);
     traits<Point2>::Print(measured_, s + ".z");
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*>(&p);
     return e
         && Base::equals(p, tol)
@@ -105,7 +105,7 @@ public:
   /// Evaluate error h(x)-z and optionally derivatives
   Vector evaluateError(const Pose3& pose, const Vector3& landmark,
       boost::optional<Matrix&> H1=boost::none,
-      boost::optional<Matrix&> H2=boost::none) const {
+      boost::optional<Matrix&> H2=boost::none) const override {
 
     if(H1) {
       (*H1) = numericalDerivative11<Vector,Pose3>(boost::bind(&InvDepthFactorVariant3a::inverseDepthError, this, _1, landmark), pose);
@@ -188,13 +188,13 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "InvDepthFactorVariant3",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     Base::print(s, keyFormatter);
     traits<Point2>::Print(measured_, s + ".z");
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*>(&p);
     return e
         && Base::equals(p, tol)
@@ -226,7 +226,7 @@ public:
   Vector evaluateError(const Pose3& pose1, const Pose3& pose2, const Vector3& landmark,
       boost::optional<Matrix&> H1=boost::none,
       boost::optional<Matrix&> H2=boost::none,
-      boost::optional<Matrix&> H3=boost::none) const {
+      boost::optional<Matrix&> H3=boost::none) const override {
 
     if(H1)
       (*H1) = numericalDerivative11<Vector,Pose3>(boost::bind(&InvDepthFactorVariant3b::inverseDepthError, this, _1, pose2, landmark), pose1);
--- gtsam-4.0.3.orig/gtsam_unstable/slam/MultiProjectionFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/MultiProjectionFactor.h
@@ -101,7 +101,7 @@ namespace gtsam {
     virtual ~MultiProjectionFactor() {}
 
     /// @return a deep copy of this factor
-    virtual NonlinearFactor::shared_ptr clone() const {
+    NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<NonlinearFactor>(
           NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -110,7 +110,7 @@ namespace gtsam {
      * @param s optional string naming the factor
      * @param keyFormatter optional formatter useful for printing Symbols
      */
-    void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "MultiProjectionFactor, z = ";
       std::cout << measured_ << "measurements, z = ";
       if(this->body_P_sensor_)
@@ -119,7 +119,7 @@ namespace gtsam {
     }
 
     /// equals
-    virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+    bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
       const This *e = dynamic_cast<const This*>(&p);
       return e
           && Base::equals(p, tol)
@@ -129,7 +129,7 @@ namespace gtsam {
     }
 
     /// Evaluate error h(x)-z and optionally derivatives
-    Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const{
+    Vector unwhitenedError(const Values& x, boost::optional<std::vector<Matrix>&> H = boost::none) const override {
 
       Vector a;
       return a;
--- gtsam-4.0.3.orig/gtsam_unstable/slam/PartialPriorFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/PartialPriorFactor.h
@@ -85,20 +85,20 @@ namespace gtsam {
     }
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
     /** implement functions needed for Testable */
 
     /** print */
-    virtual void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       Base::print(s, keyFormatter);
       gtsam::print(prior_, "prior");
     }
 
     /** equals */
-    virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+    bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
       const This *e = dynamic_cast<const This*> (&expected);
       return e != nullptr && Base::equals(*e, tol) &&
           gtsam::equal_with_abs_tol(this->prior_, e->prior_, tol) &&
@@ -108,7 +108,7 @@ namespace gtsam {
     /** implement functions needed to derive from Factor */
 
     /** vector of errors */
-    Vector evaluateError(const T& p, boost::optional<Matrix&> H = boost::none) const {
+    Vector evaluateError(const T& p, boost::optional<Matrix&> H = boost::none) const override {
       if (H) (*H) = H_;
       // FIXME: this was originally the generic retraction - may not produce same results
       Vector full_logmap = T::Logmap(p);
--- gtsam-4.0.3.orig/gtsam_unstable/slam/PoseBetweenFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/PoseBetweenFactor.h
@@ -59,14 +59,14 @@ namespace gtsam {
     virtual ~PoseBetweenFactor() {}
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
     /** implement functions needed for Testable */
 
     /** print */
-    virtual void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "BetweenFactor("
           << keyFormatter(this->key1()) << ","
           << keyFormatter(this->key2()) << ")\n";
@@ -77,7 +77,7 @@ namespace gtsam {
     }
 
     /** equals */
-    virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+    bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
       const This *e =  dynamic_cast<const This*> (&expected);
       return e != nullptr
           && Base::equals(*e, tol)
@@ -90,7 +90,7 @@ namespace gtsam {
     /** vector of errors */
     Vector evaluateError(const POSE& p1, const POSE& p2,
         boost::optional<Matrix&> H1 = boost::none,
-        boost::optional<Matrix&> H2 = boost::none) const {
+        boost::optional<Matrix&> H2 = boost::none) const override {
       if(body_P_sensor_) {
         POSE hx;
         if(H1 || H2) {
--- gtsam-4.0.3.orig/gtsam_unstable/slam/PosePriorFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/PosePriorFactor.h
@@ -56,14 +56,14 @@ namespace gtsam {
     }
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
     /** implement functions needed for Testable */
 
     /** print */
-    virtual void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "PriorFactor on " << keyFormatter(this->key()) << "\n";
       prior_.print("  prior mean: ");
       if(this->body_P_sensor_)
@@ -72,7 +72,7 @@ namespace gtsam {
     }
 
     /** equals */
-    virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const {
+    bool equals(const NonlinearFactor& expected, double tol=1e-9) const override {
       const This* e = dynamic_cast<const This*> (&expected);
       return e != nullptr
           && Base::equals(*e, tol)
@@ -83,7 +83,7 @@ namespace gtsam {
     /** implement functions needed to derive from Factor */
 
     /** vector of errors */
-    Vector evaluateError(const POSE& p, boost::optional<Matrix&> H = boost::none) const {
+    Vector evaluateError(const POSE& p, boost::optional<Matrix&> H = boost::none) const override {
       if(body_P_sensor_) {
         // manifold equivalent of h(x)-z -> log(z,h(x))
         return prior_.localCoordinates(p.compose(*body_P_sensor_, H));
--- gtsam-4.0.3.orig/gtsam_unstable/slam/ProjectionFactorPPP.h
+++ gtsam-4.0.3/gtsam_unstable/slam/ProjectionFactorPPP.h
@@ -96,7 +96,7 @@ namespace gtsam {
     virtual ~ProjectionFactorPPP() {}
 
     /// @return a deep copy of this factor
-    virtual NonlinearFactor::shared_ptr clone() const {
+    NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<NonlinearFactor>(
           NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -105,14 +105,14 @@ namespace gtsam {
      * @param s optional string naming the factor
      * @param keyFormatter optional formatter useful for printing Symbols
      */
-    void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "ProjectionFactorPPP, z = ";
       traits<Point2>::Print(measured_);
       Base::print("", keyFormatter);
     }
 
     /// equals
-    virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+    bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
       const This *e = dynamic_cast<const This*>(&p);
       return e
           && Base::equals(p, tol)
@@ -124,7 +124,7 @@ namespace gtsam {
     Vector evaluateError(const Pose3& pose, const Pose3& transform, const Point3& point,
         boost::optional<Matrix&> H1 = boost::none,
         boost::optional<Matrix&> H2 = boost::none,
-        boost::optional<Matrix&> H3 = boost::none) const {
+        boost::optional<Matrix&> H3 = boost::none) const override {
       try {
           if(H1 || H2 || H3) {
             Matrix H0, H02;
--- gtsam-4.0.3.orig/gtsam_unstable/slam/ProjectionFactorPPPC.h
+++ gtsam-4.0.3/gtsam_unstable/slam/ProjectionFactorPPPC.h
@@ -91,7 +91,7 @@ namespace gtsam {
     virtual ~ProjectionFactorPPPC() {}
 
     /// @return a deep copy of this factor
-    virtual NonlinearFactor::shared_ptr clone() const {
+    NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<NonlinearFactor>(
           NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -100,14 +100,14 @@ namespace gtsam {
      * @param s optional string naming the factor
      * @param keyFormatter optional formatter useful for printing Symbols
      */
-    void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "ProjectionFactorPPPC, z = ";
       traits<Point2>::Print(measured_);
       Base::print("", keyFormatter);
     }
 
     /// equals
-    virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+    bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
       const This *e = dynamic_cast<const This*>(&p);
       return e
           && Base::equals(p, tol)
@@ -119,7 +119,7 @@ namespace gtsam {
         boost::optional<Matrix&> H1 = boost::none,
         boost::optional<Matrix&> H2 = boost::none,
         boost::optional<Matrix&> H3 = boost::none,
-        boost::optional<Matrix&> H4 = boost::none) const {
+        boost::optional<Matrix&> H4 = boost::none) const override {
       try {
           if(H1 || H2 || H3 || H4) {
             Matrix H0, H02;
--- gtsam-4.0.3.orig/gtsam_unstable/slam/RelativeElevationFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/RelativeElevationFactor.h
@@ -43,22 +43,22 @@ public:
   virtual ~RelativeElevationFactor() {}
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
   /** h(x)-z */
   Vector evaluateError(const Pose3& pose, const Point3& point,
-      boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 = boost::none) const;
+      boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 = boost::none) const override;
 
   /** return the measured */
   inline double measured() const { return measured_; }
 
   /** equals specialized to this factor */
-  virtual bool equals(const NonlinearFactor& expected, double tol=1e-9) const;
+  bool equals(const NonlinearFactor& expected, double tol=1e-9) const override;
 
   /** print contents */
-  void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const;
+  void print(const std::string& s="", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override;
 
 private:
 
--- gtsam-4.0.3.orig/gtsam_unstable/slam/SmartRangeFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/SmartRangeFactor.h
@@ -73,14 +73,14 @@ class SmartRangeFactor: public NoiseMode
   // Testable
 
   /** print */
-  virtual void print(const std::string& s = "",
-      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "",
+      const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << "SmartRangeFactor with " << size() << " measurements\n";
     NoiseModelFactor::print(s);
   }
 
   /** Check if two factors are equal */
-  virtual bool equals(const NonlinearFactor& f, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& f, double tol = 1e-9) const override {
     return false;
   }
 
@@ -143,8 +143,8 @@ class SmartRangeFactor: public NoiseMode
   /**
    * Error function *without* the NoiseModel, \f$ z-h(x) \f$.
    */
-  virtual Vector unwhitenedError(const Values& x,
-      boost::optional<std::vector<Matrix>&> H = boost::none) const {
+  Vector unwhitenedError(const Values& x,
+      boost::optional<std::vector<Matrix>&> H = boost::none) const override {
     size_t n = size();
     if (n < 3) {
       if (H) {
@@ -175,7 +175,7 @@ class SmartRangeFactor: public NoiseMode
   }
 
   /// @return a deep copy of this factor
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new This(*this)));
   }
--- gtsam-4.0.3.orig/gtsam_unstable/slam/SmartStereoProjectionFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/SmartStereoProjectionFactor.h
@@ -102,7 +102,7 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "", const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const {
+      DefaultKeyFormatter) const override {
     std::cout << s << "SmartStereoProjectionFactor\n";
     std::cout << "linearizationMode:\n" << params_.linearizationMode << std::endl;
     std::cout << "triangulationParameters:\n" << params_.triangulation << std::endl;
@@ -111,7 +111,7 @@ public:
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const SmartStereoProjectionFactor *e =
         dynamic_cast<const SmartStereoProjectionFactor*>(&p);
     return e && params_.linearizationMode == e->params_.linearizationMode
@@ -327,8 +327,8 @@ public:
   }
 
   /// linearize
-  virtual boost::shared_ptr<GaussianFactor> linearize(
-      const Values& values) const {
+  boost::shared_ptr<GaussianFactor> linearize(
+      const Values& values) const override {
     return linearizeDamped(values);
   }
 
@@ -438,7 +438,7 @@ public:
   }
 
   /// Calculate total reprojection error
-  virtual double error(const Values& values) const {
+  double error(const Values& values) const override {
     if (this->active(values)) {
       return totalReprojectionError(Base::cameras(values));
     } else { // else of active flag
@@ -449,9 +449,9 @@ public:
   /**
    * This corrects the Jacobians and error vector for the case in which the right pixel in the monocular camera is missing (nan)
    */
-  virtual void correctForMissingMeasurements(const Cameras& cameras, Vector& ue,
+  void correctForMissingMeasurements(const Cameras& cameras, Vector& ue,
       boost::optional<typename Cameras::FBlocks&> Fs = boost::none,
-      boost::optional<Matrix&> E = boost::none) const
+      boost::optional<Matrix&> E = boost::none) const override
   {
     // when using stereo cameras, some of the measurements might be missing:
     for(size_t i=0; i < cameras.size(); i++){
--- gtsam-4.0.3.orig/gtsam_unstable/slam/SmartStereoProjectionPoseFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/SmartStereoProjectionPoseFactor.h
@@ -120,7 +120,7 @@ public:
    * @param keyFormatter optional formatter useful for printing Symbols
    */
   void print(const std::string& s = "", const KeyFormatter& keyFormatter =
-      DefaultKeyFormatter) const {
+      DefaultKeyFormatter) const override {
     std::cout << s << "SmartStereoProjectionPoseFactor, z = \n ";
     for(const boost::shared_ptr<Cal3_S2Stereo>& K: K_all_)
     K->print("calibration = ");
@@ -128,7 +128,7 @@ public:
   }
 
   /// equals
-  virtual bool equals(const NonlinearFactor& p, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& p, double tol = 1e-9) const override {
     const SmartStereoProjectionPoseFactor *e =
         dynamic_cast<const SmartStereoProjectionPoseFactor*>(&p);
 
@@ -138,7 +138,7 @@ public:
   /**
    * error calculates the error of the factor.
    */
-  virtual double error(const Values& values) const {
+  double error(const Values& values) const override {
     if (this->active(values)) {
       return this->totalReprojectionError(cameras(values));
     } else { // else of active flag
@@ -157,7 +157,7 @@ public:
    * to keys involved in this factor
    * @return vector of Values
    */
-   Base::Cameras cameras(const Values& values) const {
+   Base::Cameras cameras(const Values& values) const override {
     Base::Cameras cameras;
     size_t i=0;
     for(const Key& k: this->keys_) {
--- gtsam-4.0.3.orig/gtsam_unstable/slam/TSAMFactors.h
+++ gtsam-4.0.3/gtsam_unstable/slam/TSAMFactors.h
@@ -47,7 +47,7 @@ public:
   /// Evaluate measurement error h(x)-z
   Vector evaluateError(const Pose2& pose, const Point2& point,
       boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 =
-          boost::none) const {
+          boost::none) const override {
     return pose.transformTo(point, H1, H2) - measured_;
   }
 };
@@ -79,7 +79,7 @@ public:
       boost::optional<Matrix&> H1 = boost::none, //
       boost::optional<Matrix&> H2 = boost::none, //
       boost::optional<Matrix&> H3 = boost::none, //
-      boost::optional<Matrix&> H4 = boost::none) const {
+      boost::optional<Matrix&> H4 = boost::none) const override {
     if (H1 || H2 || H3 || H4) {
       // TODO use fixed-size matrices
       Matrix D_pose_g_base1, D_pose_g_pose;
@@ -134,7 +134,7 @@ public:
       boost::optional<Matrix&> H1 = boost::none, //
       boost::optional<Matrix&> H2 = boost::none, //
       boost::optional<Matrix&> H3 = boost::none, //
-      boost::optional<Matrix&> H4 = boost::none) const {
+      boost::optional<Matrix&> H4 = boost::none) const override {
     if (H1 || H2 || H3 || H4) {
       // TODO use fixed-size matrices
       Matrix D_pose1_g_base1, D_pose1_g_pose1;
--- gtsam-4.0.3.orig/gtsam_unstable/slam/TransformBtwRobotsUnaryFactor.h
+++ gtsam-4.0.3/gtsam_unstable/slam/TransformBtwRobotsUnaryFactor.h
@@ -81,13 +81,13 @@ namespace gtsam {
 
 
     /** Clone */
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const { return boost::make_shared<This>(*this); }
+    gtsam::NonlinearFactor::shared_ptr clone() const override { return boost::make_shared<This>(*this); }
 
 
     /** implement functions needed for Testable */
 
     /** print */
-    virtual void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "TransformBtwRobotsUnaryFactor("
           << keyFormatter(key_) << ")\n";
       std::cout << "MR between factor keys: "
@@ -99,7 +99,7 @@ namespace gtsam {
     }
 
     /** equals */
-    virtual bool equals(const NonlinearFactor& f, double tol=1e-9) const {
+    bool equals(const NonlinearFactor& f, double tol=1e-9) const override {
       const This *t =  dynamic_cast<const This*> (&f);
 
       if(t && Base::equals(f))
@@ -128,7 +128,7 @@ namespace gtsam {
     }
 
     /* ************************************************************************* */
-    virtual double error(const gtsam::Values& x) const {
+    double error(const gtsam::Values& x) const override {
       return whitenedError(x).squaredNorm();
     }
 
@@ -139,7 +139,7 @@ namespace gtsam {
      * Hence \f$ b = z - h(x) = - \mathtt{error\_vector}(x) \f$
      */
     /* This version of linearize recalculates the noise model each time */
-    virtual boost::shared_ptr<gtsam::GaussianFactor> linearize(const gtsam::Values& x) const {
+    boost::shared_ptr<gtsam::GaussianFactor> linearize(const gtsam::Values& x) const override {
       // Only linearize if the factor is active
       if (!this->active(x))
         return boost::shared_ptr<gtsam::JacobianFactor>();
@@ -203,12 +203,7 @@ namespace gtsam {
 
     /* ************************************************************************* */
 
-    /** number of variables attached to this factor */
-    std::size_t size() const {
-      return 1;
-    }
-
-    virtual size_t dim() const {
+    size_t dim() const override {
       return model_->R().rows() + model_->R().cols();
     }
 
--- gtsam-4.0.3.orig/gtsam_unstable/slam/TransformBtwRobotsUnaryFactorEM.h
+++ gtsam-4.0.3/gtsam_unstable/slam/TransformBtwRobotsUnaryFactorEM.h
@@ -97,13 +97,13 @@ namespace gtsam {
 
 
     /** Clone */
-    virtual NonlinearFactor::shared_ptr clone() const { return boost::make_shared<This>(*this); }
+    NonlinearFactor::shared_ptr clone() const override { return boost::make_shared<This>(*this); }
 
 
     /** implement functions needed for Testable */
 
     /** print */
-    virtual void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+    void print(const std::string& s, const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
       std::cout << s << "TransformBtwRobotsUnaryFactorEM("
           << keyFormatter(key_) << ")\n";
       std::cout << "MR between factor keys: "
@@ -119,7 +119,7 @@ namespace gtsam {
     }
 
     /** equals */
-    virtual bool equals(const NonlinearFactor& f, double tol=1e-9) const {
+    bool equals(const NonlinearFactor& f, double tol=1e-9) const override {
       const This *t =  dynamic_cast<const This*> (&f);
 
       if(t && Base::equals(f))
@@ -151,7 +151,7 @@ namespace gtsam {
     }
 
     /* ************************************************************************* */
-    virtual double error(const Values& x) const {
+    double error(const Values& x) const override {
       return whitenedError(x).squaredNorm();
     }
 
@@ -162,7 +162,7 @@ namespace gtsam {
      * Hence \f$ b = z - h(x) = - \mathtt{error\_vector}(x) \f$
      */
     /* This version of linearize recalculates the noise model each time */
-    virtual boost::shared_ptr<GaussianFactor> linearize(const Values& x) const {
+    boost::shared_ptr<GaussianFactor> linearize(const Values& x) const override {
       // Only linearize if the factor is active
       if (!this->active(x))
         return boost::shared_ptr<JacobianFactor>();
@@ -401,12 +401,7 @@ namespace gtsam {
 
     /* ************************************************************************* */
 
-    /** number of variables attached to this factor */
-    std::size_t size() const {
-      return 1;
-    }
-
-    virtual size_t dim() const {
+    size_t dim() const override {
       return model_inlier_->R().rows() + model_inlier_->R().cols();
     }
 
--- gtsam-4.0.3.orig/tests/simulated2D.h
+++ gtsam-4.0.3/tests/simulated2D.h
@@ -139,14 +139,14 @@ namespace simulated2D {
     }
 
     /// Return error and optional derivative
-    Vector evaluateError(const Pose& x, boost::optional<Matrix&> H = boost::none) const {
+    Vector evaluateError(const Pose& x, boost::optional<Matrix&> H = boost::none) const override {
       return (prior(x, H) - measured_);
     }
 
     virtual ~GenericPrior() {}
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -185,14 +185,14 @@ namespace simulated2D {
     /// Evaluate error and optionally return derivatives
     Vector evaluateError(const Pose& x1, const Pose& x2,
         boost::optional<Matrix&> H1 = boost::none,
-        boost::optional<Matrix&> H2 = boost::none) const {
+        boost::optional<Matrix&> H2 = boost::none) const override {
       return (odo(x1, x2, H1, H2) - measured_);
     }
 
     virtual ~GenericOdometry() {}
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -232,14 +232,14 @@ namespace simulated2D {
     /// Evaluate error and optionally return derivatives
     Vector evaluateError(const Pose& x1, const Landmark& x2,
         boost::optional<Matrix&> H1 = boost::none,
-        boost::optional<Matrix&> H2 = boost::none) const {
+        boost::optional<Matrix&> H2 = boost::none) const override {
       return (mea(x1, x2, H1, H2) - measured_);
     }
 
     virtual ~GenericMeasurement() {}
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
--- gtsam-4.0.3.orig/tests/simulated2DConstraints.h
+++ gtsam-4.0.3/tests/simulated2DConstraints.h
@@ -60,7 +60,7 @@ namespace simulated2D {
       virtual ~ScalarCoordConstraint1() {}
 
       /// @return a deep copy of this factor
-      virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+      gtsam::NonlinearFactor::shared_ptr clone() const override {
         return boost::static_pointer_cast<gtsam::NonlinearFactor>(
             gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -87,8 +87,8 @@ namespace simulated2D {
        * @param x is the estimate of the constrained variable being evaluated
        * @param H is an optional Jacobian, linearized at x
        */
-      virtual double value(const Point& x, boost::optional<Matrix&> H =
-          boost::none) const {
+      double value(const Point& x, boost::optional<Matrix&> H =
+          boost::none) const override {
         if (H) {
           Matrix D = Matrix::Zero(1, traits<Point>::GetDimension(x));
           D(0, IDX) = 1.0;
@@ -128,7 +128,7 @@ namespace simulated2D {
       virtual ~MaxDistanceConstraint() {}
 
       /// @return a deep copy of this factor
-      virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+      gtsam::NonlinearFactor::shared_ptr clone() const override {
         return boost::static_pointer_cast<gtsam::NonlinearFactor>(
             gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -150,9 +150,9 @@ namespace simulated2D {
        * @param H2 is an optional Jacobian in x2
        * @return the distance between the variables
        */
-      virtual double value(const Point& x1, const Point& x2,
+      double value(const Point& x1, const Point& x2,
           boost::optional<Matrix&> H1 = boost::none,
-          boost::optional<Matrix&> H2 = boost::none) const {
+          boost::optional<Matrix&> H2 = boost::none) const override {
         if (H1) *H1 = numericalDerivative21(range_trait<Point,Point>, x1, x2, 1e-5);
         if (H1) *H2 = numericalDerivative22(range_trait<Point,Point>, x1, x2, 1e-5);
         return range_trait(x1, x2);
@@ -177,7 +177,7 @@ namespace simulated2D {
       virtual ~MinDistanceConstraint() {}
 
       /// @return a deep copy of this factor
-      virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+      gtsam::NonlinearFactor::shared_ptr clone() const override {
         return boost::static_pointer_cast<gtsam::NonlinearFactor>(
             gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
@@ -200,9 +200,9 @@ namespace simulated2D {
        * @param H2 is an optional Jacobian in x2
        * @return the distance between the variables
        */
-      virtual double value(const Pose& x1, const Point& x2,
+      double value(const Pose& x1, const Point& x2,
           boost::optional<Matrix&> H1 = boost::none,
-          boost::optional<Matrix&> H2 = boost::none) const {
+          boost::optional<Matrix&> H2 = boost::none) const override {
         if (H1) *H1 = numericalDerivative21(range_trait<Pose,Point>, x1, x2, 1e-5);
         if (H1) *H2 = numericalDerivative22(range_trait<Pose,Point>, x1, x2, 1e-5);
         return range_trait(x1, x2);
--- gtsam-4.0.3.orig/tests/simulated2DOriented.h
+++ gtsam-4.0.3/tests/simulated2DOriented.h
@@ -119,12 +119,12 @@ namespace simulated2DOriented {
     /// Evaluate error and optionally derivative
     Vector evaluateError(const VALUE& x1, const VALUE& x2,
         boost::optional<Matrix&> H1 = boost::none,
-        boost::optional<Matrix&> H2 = boost::none) const {
+        boost::optional<Matrix&> H2 = boost::none) const override {
       return measured_.localCoordinates(odo(x1, x2, H1, H2));
     }
 
     /// @return a deep copy of this factor
-    virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+    gtsam::NonlinearFactor::shared_ptr clone() const override {
       return boost::static_pointer_cast<gtsam::NonlinearFactor>(
           gtsam::NonlinearFactor::shared_ptr(new This(*this))); }
 
--- gtsam-4.0.3.orig/tests/simulated3D.h
+++ gtsam-4.0.3/tests/simulated3D.h
@@ -90,7 +90,7 @@ struct PointPrior3D: public NoiseModelFa
    * @return Vector error between prior value and x (Dimension: 3)
    */
   Vector evaluateError(const Point3& x, boost::optional<Matrix&> H =
-      boost::none) const {
+      boost::none) const override {
     return prior(x, H) - measured_;
   }
 };
@@ -121,7 +121,7 @@ struct Simulated3DMeasurement: public No
    * @return vector error between measurement and prediction (Dimension: 3)
    */
   Vector evaluateError(const Point3& x1, const Point3& x2,
-      boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 = boost::none) const {
+      boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 = boost::none) const override {
     return mea(x1, x2, H1, H2) - measured_;
   }
 };
--- gtsam-4.0.3.orig/tests/smallExample.h
+++ gtsam-4.0.3/tests/smallExample.h
@@ -337,7 +337,7 @@ struct UnaryFactor: public gtsam::NoiseM
     gtsam::NoiseModelFactor1<Point2>(model, key), z_(z) {
   }
 
-  Vector evaluateError(const Point2& x, boost::optional<Matrix&> A = boost::none) const {
+  Vector evaluateError(const Point2& x, boost::optional<Matrix&> A = boost::none) const override {
     if (A) *A = H(x);
     return (h(x) - z_);
   }
--- gtsam-4.0.3.orig/tests/testExpressionFactor.cpp
+++ gtsam-4.0.3/tests/testExpressionFactor.cpp
@@ -630,6 +630,103 @@ TEST(ExpressionFactor, MultiplyWithInver
   EXPECT_CORRECT_FACTOR_JACOBIANS(factor, values, 1e-5, 1e-5);
 }
 
+
+/* ************************************************************************* */
+// Test N-ary variadic template
+class TestNaryFactor
+    : public gtsam::ExpressionFactorN<gtsam::Point3 /*return type*/,
+                                      gtsam::Rot3, gtsam::Point3, 
+                                      gtsam::Rot3,gtsam::Point3> {
+private:
+  using This = TestNaryFactor;
+  using Base =
+      gtsam::ExpressionFactorN<gtsam::Point3 /*return type*/,
+        gtsam::Rot3, gtsam::Point3, gtsam::Rot3, gtsam::Point3>;
+
+public:
+  /// default constructor
+  TestNaryFactor() = default;
+  ~TestNaryFactor() override = default;
+
+  TestNaryFactor(gtsam::Key kR1, gtsam::Key kV1,  gtsam::Key kR2, gtsam::Key kV2,
+    const gtsam::SharedNoiseModel &model, const gtsam::Point3& measured)
+      : Base({kR1, kV1, kR2, kV2}, model, measured) {
+    this->initialize(expression({kR1, kV1, kR2, kV2}));
+  }
+
+  /// @return a deep copy of this factor
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
+    return boost::static_pointer_cast<gtsam::NonlinearFactor>(
+        gtsam::NonlinearFactor::shared_ptr(new This(*this)));
+  }
+
+  // Return measurement expression
+  gtsam::Expression<gtsam::Point3> expression(
+      const std::array<gtsam::Key, NARY_EXPRESSION_SIZE> &keys) const override {
+    gtsam::Expression<gtsam::Rot3>   R1_(keys[0]);
+    gtsam::Expression<gtsam::Point3> V1_(keys[1]);
+    gtsam::Expression<gtsam::Rot3>   R2_(keys[2]);
+    gtsam::Expression<gtsam::Point3> V2_(keys[3]);
+    return {gtsam::rotate(R1_, V1_) - gtsam::rotate(R2_, V2_)};
+  }
+
+  /** print */
+  void print(const std::string &s,
+             const gtsam::KeyFormatter &keyFormatter =
+                 gtsam::DefaultKeyFormatter) const override {
+    std::cout << s << "TestNaryFactor("
+              << keyFormatter(Factor::keys_[0]) << ","
+              << keyFormatter(Factor::keys_[1]) << ","
+              << keyFormatter(Factor::keys_[2]) << ","
+              << keyFormatter(Factor::keys_[3]) << ")\n";
+    gtsam::traits<gtsam::Point3>::Print(measured_, "  measured: ");
+    this->noiseModel_->print("  noise model: ");
+  }
+
+  /** equals */
+  bool equals(const gtsam::NonlinearFactor &expected,
+              double tol = 1e-9) const override {
+    const This *e = dynamic_cast<const This *>(&expected);
+    return e != nullptr && Base::equals(*e, tol) && 
+      gtsam::traits<gtsam::Point3>::Equals(measured_,e->measured_, tol);
+  }
+
+private:
+  /** Serialization function */
+  friend class boost::serialization::access;
+  template <class ARCHIVE>
+  void serialize(ARCHIVE &ar, const unsigned int /*version*/) {
+    ar &boost::serialization::make_nvp(
+        "TestNaryFactor",
+        boost::serialization::base_object<Base>(*this));
+    ar &BOOST_SERIALIZATION_NVP(measured_);
+  }
+};
+
+TEST(ExpressionFactor, variadicTemplate) {
+  using gtsam::symbol_shorthand::R;
+  using gtsam::symbol_shorthand::V;
+
+  // Create factor
+  TestNaryFactor f(R(0),V(0), R(1), V(1), noiseModel::Unit::Create(3), Point3(0,0,0));
+  
+  // Create some values
+  Values values;
+  values.insert(R(0), Rot3::Ypr(0.1, 0.2, 0.3));
+  values.insert(V(0), Point3(1, 2, 3));
+  values.insert(R(1), Rot3::Ypr(0.2, 0.5, 0.2));
+  values.insert(V(1), Point3(5, 6, 7));
+
+  // Check unwhitenedError
+  std::vector<Matrix> H(4);
+  Vector actual = f.unwhitenedError(values, H);
+  EXPECT_LONGS_EQUAL(4, H.size());
+  EXPECT(assert_equal(Eigen::Vector3d(-5.63578115, -4.85353243, -1.4801204), actual, 1e-5));
+  
+  EXPECT_CORRECT_FACTOR_JACOBIANS(f, values, 1e-8, 1e-5);
+}
+
+
 /* ************************************************************************* */
 int main() {
   TestResult tr;
--- gtsam-4.0.3.orig/tests/testExtendedKalmanFilter.cpp
+++ gtsam-4.0.3/tests/testExtendedKalmanFilter.cpp
@@ -153,14 +153,14 @@ public:
   }
 
   /* print */
-  virtual void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << ": NonlinearMotionModel\n";
     std::cout << "  TestKey1: " << keyFormatter(key1()) << std::endl;
     std::cout << "  TestKey2: " << keyFormatter(key2()) << std::endl;
   }
 
   /** Check if two factors are equal. Note type is IndexFactor and needs cast. */
-  virtual bool equals(const NonlinearFactor& f, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& f, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*> (&f);
     return (e != nullptr) && (key1() == e->key1()) && (key2() == e->key2());
   }
@@ -169,13 +169,13 @@ public:
    * calculate the error of the factor
    * Override for systems with unusual noise models
    */
-  virtual double error(const Values& c) const {
+  double error(const Values& c) const override {
     Vector w = whitenedError(c);
     return 0.5 * w.dot(w);
   }
 
   /** get the dimension of the factor (number of rows on linearization) */
-  size_t dim() const {
+  size_t dim() const override {
     return 2;
   }
 
@@ -189,7 +189,7 @@ public:
    * Ax-b \approx h(x1+dx1,x2+dx2)-z = h(x1,x2) + A2*dx1 + A2*dx2 - z
    * Hence b = z - h(x1,x2) = - error_vector(x)
    */
-  boost::shared_ptr<GaussianFactor> linearize(const Values& c) const {
+  boost::shared_ptr<GaussianFactor> linearize(const Values& c) const override {
     const X1& x1 = c.at<X1>(key1());
     const X2& x2 = c.at<X2>(key2());
     Matrix A1, A2;
@@ -212,7 +212,7 @@ public:
   /** vector of errors */
   Vector evaluateError(const Point2& p1, const Point2& p2,
       boost::optional<Matrix&> H1 = boost::none, boost::optional<Matrix&> H2 =
-          boost::none) const {
+          boost::none) const override {
 
     // error = p2 - f(p1)
     // H1 = d error / d p1 = -d f/ d p1 = -F
@@ -284,13 +284,13 @@ public:
   }
 
   /* print */
-  virtual void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const {
+  void print(const std::string& s = "", const KeyFormatter& keyFormatter = DefaultKeyFormatter) const override {
     std::cout << s << ": NonlinearMeasurementModel\n";
     std::cout << "  TestKey: " << keyFormatter(key()) << std::endl;
   }
 
   /** Check if two factors are equal. Note type is IndexFactor and needs cast. */
-  virtual bool equals(const NonlinearFactor& f, double tol = 1e-9) const {
+  bool equals(const NonlinearFactor& f, double tol = 1e-9) const override {
     const This *e = dynamic_cast<const This*> (&f);
     return (e != nullptr) && Base::equals(f);
   }
@@ -299,13 +299,13 @@ public:
    * calculate the error of the factor
    * Override for systems with unusual noise models
    */
-  virtual double error(const Values& c) const {
+  double error(const Values& c) const override {
     Vector w = whitenedError(c);
     return 0.5 * w.dot(w);
   }
 
   /** get the dimension of the factor (number of rows on linearization) */
-  size_t dim() const {
+  size_t dim() const override {
     return 1;
   }
 
@@ -319,7 +319,7 @@ public:
    * Ax-b \approx h(x1+dx1)-z = h(x1) + A1*dx1 - z
    * Hence b = z - h(x1) = - error_vector(x)
    */
-  boost::shared_ptr<GaussianFactor> linearize(const Values& c) const {
+  boost::shared_ptr<GaussianFactor> linearize(const Values& c) const override {
     const X& x1 = c.at<X>(key());
     Matrix A1;
     Vector b = -evaluateError(x1, A1);
@@ -336,7 +336,7 @@ public:
   }
 
   /** vector of errors */
-  Vector evaluateError(const Point2& p, boost::optional<Matrix&> H1 = boost::none) const {
+  Vector evaluateError(const Point2& p, boost::optional<Matrix&> H1 = boost::none) const override {
     // error = z - h(p)
     // H = d error / d p = -d h/ d p = -H
     Vector z_hat = h(p);
--- gtsam-4.0.3.orig/tests/testManifold.cpp
+++ gtsam-4.0.3/tests/testManifold.cpp
@@ -149,34 +149,6 @@ TEST(Manifold, DefaultChart) {
   EXPECT(assert_equal((Vector) Z_3x1, traits<Rot3>::Local(R, R)));
 }
 
-#ifdef GTSAM_ALLOW_DEPRECATED_SINCE_V4
-//******************************************************************************
-typedef ProductManifold<Point2,Point2> MyPoint2Pair;
-
-// Define any direct product group to be a model of the multiplicative Group concept
-namespace gtsam {
-template<> struct traits<MyPoint2Pair> : internal::ManifoldTraits<MyPoint2Pair> {
-  static void Print(const MyPoint2Pair& m, const string& s = "") {
-    cout << s << "(" << m.first << "," << m.second << ")" << endl;
-  }
-  static bool Equals(const MyPoint2Pair& m1, const MyPoint2Pair& m2, double tol = 1e-8) {
-    return m1 == m2;
-  }
-};
-}
-
-TEST(Manifold, ProductManifold) {
-  BOOST_CONCEPT_ASSERT((IsManifold<MyPoint2Pair>));
-  MyPoint2Pair pair1(Point2(0,0),Point2(0,0));
-  Vector4 d;
-  d << 1,2,3,4;
-  MyPoint2Pair expected(Point2(1,2),Point2(3,4));
-  MyPoint2Pair pair2 = pair1.retract(d);
-  EXPECT(assert_equal(expected,pair2,1e-9));
-  EXPECT(assert_equal(d, pair1.localCoordinates(pair2),1e-9));
-}
-#endif
-
 //******************************************************************************
 int main() {
   TestResult tr;
--- gtsam-4.0.3.orig/tests/testNonlinearFactor.cpp
+++ gtsam-4.0.3/tests/testNonlinearFactor.cpp
@@ -239,12 +239,12 @@ public:
   typedef NoiseModelFactor4<double, double, double, double> Base;
   TestFactor4() : Base(noiseModel::Diagonal::Sigmas((Vector(1) << 2.0).finished()), X(1), X(2), X(3), X(4)) {}
 
-  virtual Vector
+  Vector
     evaluateError(const double& x1, const double& x2, const double& x3, const double& x4,
         boost::optional<Matrix&> H1 = boost::none,
         boost::optional<Matrix&> H2 = boost::none,
         boost::optional<Matrix&> H3 = boost::none,
-        boost::optional<Matrix&> H4 = boost::none) const {
+        boost::optional<Matrix&> H4 = boost::none) const override {
     if(H1) {
       *H1 = (Matrix(1, 1) << 1.0).finished();
       *H2 = (Matrix(1, 1) << 2.0).finished();
@@ -254,7 +254,7 @@ public:
     return (Vector(1) << x1 + x2 + x3 + x4).finished();
   }
 
-  virtual gtsam::NonlinearFactor::shared_ptr clone() const {
+  gtsam::NonlinearFactor::shared_ptr clone() const override {
     return boost::static_pointer_cast<gtsam::NonlinearFactor>(
         gtsam::NonlinearFactor::shared_ptr(new TestFactor4(*this))); }
 };
@@ -287,13 +287,13 @@ public:
   typedef NoiseModelFactor5<double, double, double, double, double> Base;
   TestFactor5() : Base(noiseModel::Diagonal::Sigmas((Vector(1) << 2.0).finished()), X(1), X(2), X(3), X(4), X(5)) {}
 
-  virtual Vector
+  Vector
     evaluateError(const X1& x1, const X2& x2, const X3& x3, const X4& x4, const X5& x5,
         boost::optional<Matrix&> H1 = boost::none,
         boost::optional<Matrix&> H2 = boost::none,
         boost::optional<Matrix&> H3 = boost::none,
         boost::optional<Matrix&> H4 = boost::none,
-        boost::optional<Matrix&> H5 = boost::none) const {
+        boost::optional<Matrix&> H5 = boost::none) const override {
     if(H1) {
       *H1 = (Matrix(1, 1) << 1.0).finished();
       *H2 = (Matrix(1, 1) << 2.0).finished();
@@ -336,14 +336,14 @@ public:
   typedef NoiseModelFactor6<double, double, double, double, double, double> Base;
   TestFactor6() : Base(noiseModel::Diagonal::Sigmas((Vector(1) << 2.0).finished()), X(1), X(2), X(3), X(4), X(5), X(6)) {}
 
-  virtual Vector
+  Vector
     evaluateError(const X1& x1, const X2& x2, const X3& x3, const X4& x4, const X5& x5, const X6& x6,
         boost::optional<Matrix&> H1 = boost::none,
         boost::optional<Matrix&> H2 = boost::none,
         boost::optional<Matrix&> H3 = boost::none,
         boost::optional<Matrix&> H4 = boost::none,
         boost::optional<Matrix&> H5 = boost::none,
-        boost::optional<Matrix&> H6 = boost::none) const {
+        boost::optional<Matrix&> H6 = boost::none) const override {
     if(H1) {
       *H1 = (Matrix(1, 1) << 1.0).finished();
       *H2 = (Matrix(1, 1) << 2.0).finished();
--- gtsam-4.0.3.orig/tests/testNonlinearISAM.cpp
+++ gtsam-4.0.3/tests/testNonlinearISAM.cpp
@@ -288,7 +288,7 @@ TEST(testNonlinearISAM, loop_closures )
       break;
 
     // Check if vertex
-    const auto indexedPose = parseVertex(is, tag);
+    const auto indexedPose = parseVertexPose(is, tag);
     if (indexedPose) {
       Key id = indexedPose->first;
       initialEstimate.insert(Symbol('x', id), indexedPose->second);
--- gtsam-4.0.3.orig/tests/testNonlinearOptimizer.cpp
+++ gtsam-4.0.3/tests/testNonlinearOptimizer.cpp
@@ -510,8 +510,8 @@ class IterativeLM : public LevenbergMarq
         initial_(initialValues) {}
 
   /// Solve that uses conjugate gradient
-  virtual VectorValues solve(const GaussianFactorGraph& gfg,
-                             const NonlinearOptimizerParams& params) const {
+  VectorValues solve(const GaussianFactorGraph& gfg,
+                             const NonlinearOptimizerParams& params) const override {
     VectorValues zeros = initial_.zeroVectors();
     return conjugateGradientDescent(gfg, zeros, cgParams_);
   }
--- gtsam-4.0.3.orig/tests/testSerializationSLAM.cpp
+++ gtsam-4.0.3/tests/testSerializationSLAM.cpp
@@ -18,15 +18,10 @@
 
 #include <CppUnitLite/TestHarness.h>
 
-#if 0
-
 #include <tests/smallExample.h>
-//#include <gtsam/slam/AntiFactor.h>
 #include <gtsam/sam/BearingRangeFactor.h>
 #include <gtsam/slam/BetweenFactor.h>
-//#include <gtsam/slam/BoundingConstraint.h>
 #include <gtsam/slam/GeneralSFMFactor.h>
-//#include <gtsam/slam/PartialPriorFactor.h>
 #include <gtsam/nonlinear/PriorFactor.h>
 #include <gtsam/slam/ProjectionFactor.h>
 #include <gtsam/sam/RangeFactor.h>
@@ -34,8 +29,6 @@
 #include <gtsam/nonlinear/NonlinearEquality.h>
 #include <gtsam/inference/Symbol.h>
 #include <gtsam/linear/GaussianISAM.h>
-#include <gtsam/base/LieVector.h>
-#include <gtsam/base/LieMatrix.h>
 #include <gtsam/geometry/Point2.h>
 #include <gtsam/geometry/StereoPoint2.h>
 #include <gtsam/geometry/Point3.h>
@@ -49,6 +42,7 @@
 #include <gtsam/geometry/CalibratedCamera.h>
 #include <gtsam/geometry/PinholeCamera.h>
 #include <gtsam/geometry/StereoCamera.h>
+#include <gtsam/geometry/SimpleCamera.h>
 
 #include <gtsam/base/serializationTestHelpers.h>
 
@@ -57,8 +51,6 @@ using namespace gtsam;
 using namespace gtsam::serializationTestHelpers;
 
 // Creating as many permutations of factors as possible
-typedef PriorFactor<LieVector>              PriorFactorLieVector;
-typedef PriorFactor<LieMatrix>              PriorFactorLieMatrix;
 typedef PriorFactor<Point2>                 PriorFactorPoint2;
 typedef PriorFactor<StereoPoint2>           PriorFactorStereoPoint2;
 typedef PriorFactor<Point3>                 PriorFactorPoint3;
@@ -69,12 +61,9 @@ typedef PriorFactor<Pose3>
 typedef PriorFactor<Cal3_S2>                PriorFactorCal3_S2;
 typedef PriorFactor<Cal3DS2>                PriorFactorCal3DS2;
 typedef PriorFactor<CalibratedCamera>       PriorFactorCalibratedCamera;
-typedef PriorFactor<SimpleCamera>           PriorFactorSimpleCamera;
 typedef PriorFactor<PinholeCameraCal3_S2>   PriorFactorPinholeCameraCal3_S2;
 typedef PriorFactor<StereoCamera>           PriorFactorStereoCamera;
 
-typedef BetweenFactor<LieVector>       BetweenFactorLieVector;
-typedef BetweenFactor<LieMatrix>       BetweenFactorLieMatrix;
 typedef BetweenFactor<Point2>          BetweenFactorPoint2;
 typedef BetweenFactor<Point3>          BetweenFactorPoint3;
 typedef BetweenFactor<Rot2>            BetweenFactorRot2;
@@ -82,8 +71,6 @@ typedef BetweenFactor<Rot3>            B
 typedef BetweenFactor<Pose2>           BetweenFactorPose2;
 typedef BetweenFactor<Pose3>           BetweenFactorPose3;
 
-typedef NonlinearEquality<LieVector>              NonlinearEqualityLieVector;
-typedef NonlinearEquality<LieMatrix>              NonlinearEqualityLieMatrix;
 typedef NonlinearEquality<Point2>                 NonlinearEqualityPoint2;
 typedef NonlinearEquality<StereoPoint2>           NonlinearEqualityStereoPoint2;
 typedef NonlinearEquality<Point3>                 NonlinearEqualityPoint3;
@@ -94,7 +81,6 @@ typedef NonlinearEquality<Pose3>
 typedef NonlinearEquality<Cal3_S2>                NonlinearEqualityCal3_S2;
 typedef NonlinearEquality<Cal3DS2>                NonlinearEqualityCal3DS2;
 typedef NonlinearEquality<CalibratedCamera>       NonlinearEqualityCalibratedCamera;
-typedef NonlinearEquality<SimpleCamera>           NonlinearEqualitySimpleCamera;
 typedef NonlinearEquality<PinholeCameraCal3_S2>   NonlinearEqualityPinholeCameraCal3_S2;
 typedef NonlinearEquality<StereoCamera>           NonlinearEqualityStereoCamera;
 
@@ -148,8 +134,6 @@ BOOST_CLASS_EXPORT_GUID(gtsam::SharedDia
 
 /* Create GUIDs for geometry */
 /* ************************************************************************* */
-GTSAM_VALUE_EXPORT(gtsam::LieVector);
-GTSAM_VALUE_EXPORT(gtsam::LieMatrix);
 GTSAM_VALUE_EXPORT(gtsam::Point2);
 GTSAM_VALUE_EXPORT(gtsam::StereoPoint2);
 GTSAM_VALUE_EXPORT(gtsam::Point3);
@@ -170,8 +154,6 @@ GTSAM_VALUE_EXPORT(gtsam::StereoCamera);
 BOOST_CLASS_EXPORT_GUID(gtsam::JacobianFactor, "gtsam::JacobianFactor");
 BOOST_CLASS_EXPORT_GUID(gtsam::HessianFactor , "gtsam::HessianFactor");
 
-BOOST_CLASS_EXPORT_GUID(PriorFactorLieVector, "gtsam::PriorFactorLieVector");
-BOOST_CLASS_EXPORT_GUID(PriorFactorLieMatrix, "gtsam::PriorFactorLieMatrix");
 BOOST_CLASS_EXPORT_GUID(PriorFactorPoint2, "gtsam::PriorFactorPoint2");
 BOOST_CLASS_EXPORT_GUID(PriorFactorStereoPoint2, "gtsam::PriorFactorStereoPoint2");
 BOOST_CLASS_EXPORT_GUID(PriorFactorPoint3, "gtsam::PriorFactorPoint3");
@@ -182,11 +164,8 @@ BOOST_CLASS_EXPORT_GUID(PriorFactorPose3
 BOOST_CLASS_EXPORT_GUID(PriorFactorCal3_S2, "gtsam::PriorFactorCal3_S2");
 BOOST_CLASS_EXPORT_GUID(PriorFactorCal3DS2, "gtsam::PriorFactorCal3DS2");
 BOOST_CLASS_EXPORT_GUID(PriorFactorCalibratedCamera, "gtsam::PriorFactorCalibratedCamera");
-BOOST_CLASS_EXPORT_GUID(PriorFactorSimpleCamera, "gtsam::PriorFactorSimpleCamera");
 BOOST_CLASS_EXPORT_GUID(PriorFactorStereoCamera, "gtsam::PriorFactorStereoCamera");
 
-BOOST_CLASS_EXPORT_GUID(BetweenFactorLieVector, "gtsam::BetweenFactorLieVector");
-BOOST_CLASS_EXPORT_GUID(BetweenFactorLieMatrix, "gtsam::BetweenFactorLieMatrix");
 BOOST_CLASS_EXPORT_GUID(BetweenFactorPoint2, "gtsam::BetweenFactorPoint2");
 BOOST_CLASS_EXPORT_GUID(BetweenFactorPoint3, "gtsam::BetweenFactorPoint3");
 BOOST_CLASS_EXPORT_GUID(BetweenFactorRot2, "gtsam::BetweenFactorRot2");
@@ -194,8 +173,6 @@ BOOST_CLASS_EXPORT_GUID(BetweenFactorRot
 BOOST_CLASS_EXPORT_GUID(BetweenFactorPose2, "gtsam::BetweenFactorPose2");
 BOOST_CLASS_EXPORT_GUID(BetweenFactorPose3, "gtsam::BetweenFactorPose3");
 
-BOOST_CLASS_EXPORT_GUID(NonlinearEqualityLieVector, "gtsam::NonlinearEqualityLieVector");
-BOOST_CLASS_EXPORT_GUID(NonlinearEqualityLieMatrix, "gtsam::NonlinearEqualityLieMatrix");
 BOOST_CLASS_EXPORT_GUID(NonlinearEqualityPoint2, "gtsam::NonlinearEqualityPoint2");
 BOOST_CLASS_EXPORT_GUID(NonlinearEqualityStereoPoint2, "gtsam::NonlinearEqualityStereoPoint2");
 BOOST_CLASS_EXPORT_GUID(NonlinearEqualityPoint3, "gtsam::NonlinearEqualityPoint3");
@@ -206,7 +183,6 @@ BOOST_CLASS_EXPORT_GUID(NonlinearEqualit
 BOOST_CLASS_EXPORT_GUID(NonlinearEqualityCal3_S2, "gtsam::NonlinearEqualityCal3_S2");
 BOOST_CLASS_EXPORT_GUID(NonlinearEqualityCal3DS2, "gtsam::NonlinearEqualityCal3DS2");
 BOOST_CLASS_EXPORT_GUID(NonlinearEqualityCalibratedCamera, "gtsam::NonlinearEqualityCalibratedCamera");
-BOOST_CLASS_EXPORT_GUID(NonlinearEqualitySimpleCamera, "gtsam::NonlinearEqualitySimpleCamera");
 BOOST_CLASS_EXPORT_GUID(NonlinearEqualityStereoCamera, "gtsam::NonlinearEqualityStereoCamera");
 
 BOOST_CLASS_EXPORT_GUID(RangeFactor2D, "gtsam::RangeFactor2D");
@@ -286,8 +262,6 @@ TEST (testSerializationSLAM, smallExampl
 /* ************************************************************************* */
 TEST (testSerializationSLAM, factors) {
 
-  LieVector lieVector((Vector(4) << 1.0, 2.0, 3.0, 4.0).finished());
-  LieMatrix lieMatrix((Matrix(2, 3) << 1.0, 2.0, 3.0, 4.0, 5.0 ,6.0).finished());
   Point2 point2(1.0, 2.0);
   StereoPoint2 stereoPoint2(1.0, 2.0, 3.0);
   Point3 point3(1.0, 2.0, 3.0);
@@ -311,8 +285,6 @@ TEST (testSerializationSLAM, factors) {
           b11('b',11), b12('b',12), b13('b',13), b14('b',14), b15('b',15);
 
   Values values;
-  values.insert(a01, lieVector);
-  values.insert(a02, lieMatrix);
   values.insert(a03, point2);
   values.insert(a04, stereoPoint2);
   values.insert(a05, point3);
@@ -344,8 +316,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsDereferencedXML(robust1));
   EXPECT(equalsDereferencedBinary(robust1));
 
-  PriorFactorLieVector priorFactorLieVector(a01, lieVector, model4);
-  PriorFactorLieMatrix priorFactorLieMatrix(a02, lieMatrix, model6);
   PriorFactorPoint2 priorFactorPoint2(a03, point2, model2);
   PriorFactorStereoPoint2 priorFactorStereoPoint2(a04, stereoPoint2, model3);
   PriorFactorPoint3 priorFactorPoint3(a05, point3, model3);
@@ -356,11 +326,8 @@ TEST (testSerializationSLAM, factors) {
   PriorFactorCal3_S2 priorFactorCal3_S2(a10, cal3_s2, model5);
   PriorFactorCal3DS2 priorFactorCal3DS2(a11, cal3ds2, model9);
   PriorFactorCalibratedCamera priorFactorCalibratedCamera(a12, calibratedCamera, model6);
-  PriorFactorSimpleCamera priorFactorSimpleCamera(a13, simpleCamera, model11);
   PriorFactorStereoCamera priorFactorStereoCamera(a14, stereoCamera, model11);
 
-  BetweenFactorLieVector betweenFactorLieVector(a01, b01, lieVector, model4);
-  BetweenFactorLieMatrix betweenFactorLieMatrix(a02, b02, lieMatrix, model6);
   BetweenFactorPoint2 betweenFactorPoint2(a03, b03, point2, model2);
   BetweenFactorPoint3 betweenFactorPoint3(a05, b05, point3, model3);
   BetweenFactorRot2 betweenFactorRot2(a06, b06, rot2, model1);
@@ -368,8 +335,6 @@ TEST (testSerializationSLAM, factors) {
   BetweenFactorPose2 betweenFactorPose2(a08, b08, pose2, model3);
   BetweenFactorPose3 betweenFactorPose3(a09, b09, pose3, model6);
 
-  NonlinearEqualityLieVector nonlinearEqualityLieVector(a01, lieVector);
-  NonlinearEqualityLieMatrix nonlinearEqualityLieMatrix(a02, lieMatrix);
   NonlinearEqualityPoint2 nonlinearEqualityPoint2(a03, point2);
   NonlinearEqualityStereoPoint2 nonlinearEqualityStereoPoint2(a04, stereoPoint2);
   NonlinearEqualityPoint3 nonlinearEqualityPoint3(a05, point3);
@@ -380,7 +345,6 @@ TEST (testSerializationSLAM, factors) {
   NonlinearEqualityCal3_S2 nonlinearEqualityCal3_S2(a10, cal3_s2);
   NonlinearEqualityCal3DS2 nonlinearEqualityCal3DS2(a11, cal3ds2);
   NonlinearEqualityCalibratedCamera nonlinearEqualityCalibratedCamera(a12, calibratedCamera);
-  NonlinearEqualitySimpleCamera nonlinearEqualitySimpleCamera(a13, simpleCamera);
   NonlinearEqualityStereoCamera nonlinearEqualityStereoCamera(a14, stereoCamera);
 
   RangeFactor2D rangeFactor2D(a08, a03, 2.0, model1);
@@ -405,8 +369,6 @@ TEST (testSerializationSLAM, factors) {
 
 
   NonlinearFactorGraph graph;
-  graph += priorFactorLieVector;
-  graph += priorFactorLieMatrix;
   graph += priorFactorPoint2;
   graph += priorFactorStereoPoint2;
   graph += priorFactorPoint3;
@@ -417,11 +379,8 @@ TEST (testSerializationSLAM, factors) {
   graph += priorFactorCal3_S2;
   graph += priorFactorCal3DS2;
   graph += priorFactorCalibratedCamera;
-  graph += priorFactorSimpleCamera;
   graph += priorFactorStereoCamera;
 
-  graph += betweenFactorLieVector;
-  graph += betweenFactorLieMatrix;
   graph += betweenFactorPoint2;
   graph += betweenFactorPoint3;
   graph += betweenFactorRot2;
@@ -429,8 +388,6 @@ TEST (testSerializationSLAM, factors) {
   graph += betweenFactorPose2;
   graph += betweenFactorPose3;
 
-  graph += nonlinearEqualityLieVector;
-  graph += nonlinearEqualityLieMatrix;
   graph += nonlinearEqualityPoint2;
   graph += nonlinearEqualityStereoPoint2;
   graph += nonlinearEqualityPoint3;
@@ -441,7 +398,6 @@ TEST (testSerializationSLAM, factors) {
   graph += nonlinearEqualityCal3_S2;
   graph += nonlinearEqualityCal3DS2;
   graph += nonlinearEqualityCalibratedCamera;
-  graph += nonlinearEqualitySimpleCamera;
   graph += nonlinearEqualityStereoCamera;
 
   graph += rangeFactor2D;
@@ -471,8 +427,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsObj<Values>(values));
   EXPECT(equalsObj<NonlinearFactorGraph>(graph));
 
-  EXPECT(equalsObj<PriorFactorLieVector>(priorFactorLieVector));
-  EXPECT(equalsObj<PriorFactorLieMatrix>(priorFactorLieMatrix));
   EXPECT(equalsObj<PriorFactorPoint2>(priorFactorPoint2));
   EXPECT(equalsObj<PriorFactorStereoPoint2>(priorFactorStereoPoint2));
   EXPECT(equalsObj<PriorFactorPoint3>(priorFactorPoint3));
@@ -483,11 +437,8 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsObj<PriorFactorCal3_S2>(priorFactorCal3_S2));
   EXPECT(equalsObj<PriorFactorCal3DS2>(priorFactorCal3DS2));
   EXPECT(equalsObj<PriorFactorCalibratedCamera>(priorFactorCalibratedCamera));
-  EXPECT(equalsObj<PriorFactorSimpleCamera>(priorFactorSimpleCamera));
   EXPECT(equalsObj<PriorFactorStereoCamera>(priorFactorStereoCamera));
 
-  EXPECT(equalsObj<BetweenFactorLieVector>(betweenFactorLieVector));
-  EXPECT(equalsObj<BetweenFactorLieMatrix>(betweenFactorLieMatrix));
   EXPECT(equalsObj<BetweenFactorPoint2>(betweenFactorPoint2));
   EXPECT(equalsObj<BetweenFactorPoint3>(betweenFactorPoint3));
   EXPECT(equalsObj<BetweenFactorRot2>(betweenFactorRot2));
@@ -495,8 +446,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsObj<BetweenFactorPose2>(betweenFactorPose2));
   EXPECT(equalsObj<BetweenFactorPose3>(betweenFactorPose3));
 
-  EXPECT(equalsObj<NonlinearEqualityLieVector>(nonlinearEqualityLieVector));
-  EXPECT(equalsObj<NonlinearEqualityLieMatrix>(nonlinearEqualityLieMatrix));
   EXPECT(equalsObj<NonlinearEqualityPoint2>(nonlinearEqualityPoint2));
   EXPECT(equalsObj<NonlinearEqualityStereoPoint2>(nonlinearEqualityStereoPoint2));
   EXPECT(equalsObj<NonlinearEqualityPoint3>(nonlinearEqualityPoint3));
@@ -507,7 +456,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsObj<NonlinearEqualityCal3_S2>(nonlinearEqualityCal3_S2));
   EXPECT(equalsObj<NonlinearEqualityCal3DS2>(nonlinearEqualityCal3DS2));
   EXPECT(equalsObj<NonlinearEqualityCalibratedCamera>(nonlinearEqualityCalibratedCamera));
-  EXPECT(equalsObj<NonlinearEqualitySimpleCamera>(nonlinearEqualitySimpleCamera));
   EXPECT(equalsObj<NonlinearEqualityStereoCamera>(nonlinearEqualityStereoCamera));
 
   EXPECT(equalsObj<RangeFactor2D>(rangeFactor2D));
@@ -537,8 +485,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsXML<Values>(values));
   EXPECT(equalsXML<NonlinearFactorGraph>(graph));
 
-  EXPECT(equalsXML<PriorFactorLieVector>(priorFactorLieVector));
-  EXPECT(equalsXML<PriorFactorLieMatrix>(priorFactorLieMatrix));
   EXPECT(equalsXML<PriorFactorPoint2>(priorFactorPoint2));
   EXPECT(equalsXML<PriorFactorStereoPoint2>(priorFactorStereoPoint2));
   EXPECT(equalsXML<PriorFactorPoint3>(priorFactorPoint3));
@@ -549,11 +495,8 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsXML<PriorFactorCal3_S2>(priorFactorCal3_S2));
   EXPECT(equalsXML<PriorFactorCal3DS2>(priorFactorCal3DS2));
   EXPECT(equalsXML<PriorFactorCalibratedCamera>(priorFactorCalibratedCamera));
-  EXPECT(equalsXML<PriorFactorSimpleCamera>(priorFactorSimpleCamera));
   EXPECT(equalsXML<PriorFactorStereoCamera>(priorFactorStereoCamera));
 
-  EXPECT(equalsXML<BetweenFactorLieVector>(betweenFactorLieVector));
-  EXPECT(equalsXML<BetweenFactorLieMatrix>(betweenFactorLieMatrix));
   EXPECT(equalsXML<BetweenFactorPoint2>(betweenFactorPoint2));
   EXPECT(equalsXML<BetweenFactorPoint3>(betweenFactorPoint3));
   EXPECT(equalsXML<BetweenFactorRot2>(betweenFactorRot2));
@@ -561,8 +504,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsXML<BetweenFactorPose2>(betweenFactorPose2));
   EXPECT(equalsXML<BetweenFactorPose3>(betweenFactorPose3));
 
-  EXPECT(equalsXML<NonlinearEqualityLieVector>(nonlinearEqualityLieVector));
-  EXPECT(equalsXML<NonlinearEqualityLieMatrix>(nonlinearEqualityLieMatrix));
   EXPECT(equalsXML<NonlinearEqualityPoint2>(nonlinearEqualityPoint2));
   EXPECT(equalsXML<NonlinearEqualityStereoPoint2>(nonlinearEqualityStereoPoint2));
   EXPECT(equalsXML<NonlinearEqualityPoint3>(nonlinearEqualityPoint3));
@@ -573,7 +514,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsXML<NonlinearEqualityCal3_S2>(nonlinearEqualityCal3_S2));
   EXPECT(equalsXML<NonlinearEqualityCal3DS2>(nonlinearEqualityCal3DS2));
   EXPECT(equalsXML<NonlinearEqualityCalibratedCamera>(nonlinearEqualityCalibratedCamera));
-  EXPECT(equalsXML<NonlinearEqualitySimpleCamera>(nonlinearEqualitySimpleCamera));
   EXPECT(equalsXML<NonlinearEqualityStereoCamera>(nonlinearEqualityStereoCamera));
 
   EXPECT(equalsXML<RangeFactor2D>(rangeFactor2D));
@@ -603,8 +543,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsBinary<Values>(values));
   EXPECT(equalsBinary<NonlinearFactorGraph>(graph));
 
-  EXPECT(equalsBinary<PriorFactorLieVector>(priorFactorLieVector));
-  EXPECT(equalsBinary<PriorFactorLieMatrix>(priorFactorLieMatrix));
   EXPECT(equalsBinary<PriorFactorPoint2>(priorFactorPoint2));
   EXPECT(equalsBinary<PriorFactorStereoPoint2>(priorFactorStereoPoint2));
   EXPECT(equalsBinary<PriorFactorPoint3>(priorFactorPoint3));
@@ -615,11 +553,8 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsBinary<PriorFactorCal3_S2>(priorFactorCal3_S2));
   EXPECT(equalsBinary<PriorFactorCal3DS2>(priorFactorCal3DS2));
   EXPECT(equalsBinary<PriorFactorCalibratedCamera>(priorFactorCalibratedCamera));
-  EXPECT(equalsBinary<PriorFactorSimpleCamera>(priorFactorSimpleCamera));
   EXPECT(equalsBinary<PriorFactorStereoCamera>(priorFactorStereoCamera));
 
-  EXPECT(equalsBinary<BetweenFactorLieVector>(betweenFactorLieVector));
-  EXPECT(equalsBinary<BetweenFactorLieMatrix>(betweenFactorLieMatrix));
   EXPECT(equalsBinary<BetweenFactorPoint2>(betweenFactorPoint2));
   EXPECT(equalsBinary<BetweenFactorPoint3>(betweenFactorPoint3));
   EXPECT(equalsBinary<BetweenFactorRot2>(betweenFactorRot2));
@@ -627,8 +562,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsBinary<BetweenFactorPose2>(betweenFactorPose2));
   EXPECT(equalsBinary<BetweenFactorPose3>(betweenFactorPose3));
 
-  EXPECT(equalsBinary<NonlinearEqualityLieVector>(nonlinearEqualityLieVector));
-  EXPECT(equalsBinary<NonlinearEqualityLieMatrix>(nonlinearEqualityLieMatrix));
   EXPECT(equalsBinary<NonlinearEqualityPoint2>(nonlinearEqualityPoint2));
   EXPECT(equalsBinary<NonlinearEqualityStereoPoint2>(nonlinearEqualityStereoPoint2));
   EXPECT(equalsBinary<NonlinearEqualityPoint3>(nonlinearEqualityPoint3));
@@ -639,7 +572,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsBinary<NonlinearEqualityCal3_S2>(nonlinearEqualityCal3_S2));
   EXPECT(equalsBinary<NonlinearEqualityCal3DS2>(nonlinearEqualityCal3DS2));
   EXPECT(equalsBinary<NonlinearEqualityCalibratedCamera>(nonlinearEqualityCalibratedCamera));
-  EXPECT(equalsBinary<NonlinearEqualitySimpleCamera>(nonlinearEqualitySimpleCamera));
   EXPECT(equalsBinary<NonlinearEqualityStereoCamera>(nonlinearEqualityStereoCamera));
 
   EXPECT(equalsBinary<RangeFactor2D>(rangeFactor2D));
@@ -663,7 +595,6 @@ TEST (testSerializationSLAM, factors) {
   EXPECT(equalsBinary<GenericStereoFactor3D>(genericStereoFactor3D));
 }
 
-#endif
 
 /* ************************************************************************* */
 int main() { TestResult tr; return TestRegistry::runAllTests(tr); }
--- gtsam-4.0.3.orig/timing/timeFactorOverhead.cpp
+++ gtsam-4.0.3/timing/timeFactorOverhead.cpp
@@ -22,13 +22,14 @@
 #include <gtsam/linear/NoiseModel.h>
 #include <gtsam/linear/VectorValues.h>
 
-#include <boost/random.hpp>
+#include <random>
 #include <vector>
 
 using namespace gtsam;
 using namespace std;
 
-static boost::variate_generator<boost::mt19937, boost::uniform_real<> > rg(boost::mt19937(), boost::uniform_real<>(0.0, 1.0));
+static std::mt19937 rng;
+static std::uniform_real_distribution<> uniform(0.0, 1.0);
 
 int main(int argc, char *argv[]) {
 
@@ -64,10 +65,10 @@ int main(int argc, char *argv[]) {
         Matrix A(blockdim, vardim);
         for(size_t j=0; j<blockdim; ++j)
           for(size_t k=0; k<vardim; ++k)
-            A(j,k) = rg();
+            A(j,k) = uniform(rng);
         Vector b(blockdim);
         for(size_t j=0; j<blockdim; ++j)
-          b(j) = rg();
+          b(j) = uniform(rng);
         blockGfgs[trial].push_back(boost::make_shared<JacobianFactor>(key, A, b, noise));
       }
     }
@@ -111,10 +112,10 @@ int main(int argc, char *argv[]) {
         // Generate a random Gaussian factor
         for(size_t j=0; j<blockdim; ++j)
           for(size_t k=0; k<vardim; ++k)
-            Acomb(blockdim*i+j, k) = rg();
+            Acomb(blockdim*i+j, k) = uniform(rng);
         Vector b(blockdim);
         for(size_t j=0; j<blockdim; ++j)
-          bcomb(blockdim*i+j) = rg();
+          bcomb(blockdim*i+j) = uniform(rng);
       }
       combGfgs[trial].push_back(boost::make_shared<JacobianFactor>(key, Acomb, bcomb,
           noiseModel::Isotropic::Sigma(blockdim*nBlocks, 1.0)));
--- gtsam-4.0.3.orig/timing/timeFrobeniusFactor.cpp
+++ gtsam-4.0.3/timing/timeFrobeniusFactor.cpp
@@ -13,12 +13,11 @@
  * @file    timeFrobeniusFactor.cpp
  * @brief   time FrobeniusFactor with BAL file
  * @author  Frank Dellaert
- * @date    June 6, 2015
+ * @date    2019
  */
 
 #include <gtsam/base/timing.h>
 #include <gtsam/geometry/Pose3.h>
-#include <gtsam/geometry/SO4.h>
 #include <gtsam/linear/NoiseModel.h>
 #include <gtsam/linear/PCGSolver.h>
 #include <gtsam/linear/SubgraphPreconditioner.h>
@@ -31,6 +30,7 @@
 #include <gtsam/slam/FrobeniusFactor.h>
 
 #include <iostream>
+#include <random>
 #include <string>
 #include <vector>
 
@@ -50,10 +50,7 @@ int main(int argc, char* argv[]) {
     if (argc > 1)
       g2oFile = argv[argc - 1];
     else
-      g2oFile =
-          "/Users/dellaert/git/2019c-notes-shonanrotationaveraging/matlabCode/"
-          "datasets/randomTorus3D.g2o";
-    // g2oFile = findExampleDataFile("sphere_smallnoise.graph");
+      g2oFile = findExampleDataFile("sphere_smallnoise.graph");
   } catch (const exception& e) {
     cerr << e.what() << '\n';
     exit(1);
@@ -65,18 +62,19 @@ int main(int argc, char* argv[]) {
 
   // Build graph
   NonlinearFactorGraph graph;
-  // graph.add(NonlinearEquality<SO4>(0, SO4()));
+  // graph.add(NonlinearEquality<SOn>(0, SOn::identity(4)));
   auto priorModel = noiseModel::Isotropic::Sigma(6, 10000);
-  graph.add(PriorFactor<SO4>(0, SO4(), priorModel));
+  graph.add(PriorFactor<SOn>(0, SOn::identity(4), priorModel));
+  auto G = boost::make_shared<Matrix>(SOn::VectorizedGenerators(4));
   for (const auto& factor : factors) {
     const auto& keys = factor->keys();
     const auto& Tij = factor->measured();
     const auto& model = factor->noiseModel();
     graph.emplace_shared<FrobeniusWormholeFactor>(
-        keys[0], keys[1], SO3(Tij.rotation().matrix()), model);
+        keys[0], keys[1], Rot3(Tij.rotation().matrix()), 4, model, G);
   }
 
-  boost::mt19937 rng(42);
+  std::mt19937 rng(42);
 
   // Set parameters to be similar to ceres
   LevenbergMarquardtParams params;
@@ -94,9 +92,9 @@ int main(int argc, char* argv[]) {
   for (size_t i = 0; i < 100; i++) {
     gttic_(optimize);
     Values initial;
-    initial.insert(0, SO4());
+    initial.insert(0, SOn::identity(4));
     for (size_t j = 1; j < poses.size(); j++) {
-      initial.insert(j, SO4::Random(rng));
+      initial.insert(j, SOn::Random(rng, 4));
     }
     LevenbergMarquardtOptimizer lm(graph, initial, params);
     Values result = lm.optimize();
--- gtsam-4.0.3.orig/timing/timeMatrixOps.cpp
+++ gtsam-4.0.3/timing/timeMatrixOps.cpp
@@ -16,7 +16,6 @@
  * @date    Sep 18, 2010
  */
 
-#include <boost/random.hpp>
 #include <boost/format.hpp>
 #include <boost/lambda/lambda.hpp>
 
@@ -24,6 +23,7 @@
 #include <gtsam/base/Matrix.h>
 
 #include <iostream>
+#include <random>
 #include <vector>
 #include <utility>
 
@@ -33,7 +33,8 @@ using namespace std;
 using boost::format;
 using namespace boost::lambda;
 
-static boost::variate_generator<boost::mt19937, boost::uniform_real<> > rng(boost::mt19937(), boost::uniform_real<>(-1.0, 0.0));
+static std::mt19937 rng;
+static std::uniform_real_distribution<> uniform(-1.0, 0.0);
 //typedef ublas::matrix<double> matrix;
 //typedef ublas::matrix_range<matrix> matrix_range;
 //typedef Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> matrix;
@@ -53,8 +54,8 @@ int main(int argc, char* argv[]) {
     volatile size_t n=300;
     volatile size_t nReps = 1000;
     assert(m > n);
-    boost::variate_generator<boost::mt19937, boost::uniform_int<size_t> > rni(boost::mt19937(), boost::uniform_int<size_t>(0,m-1));
-    boost::variate_generator<boost::mt19937, boost::uniform_int<size_t> > rnj(boost::mt19937(), boost::uniform_int<size_t>(0,n-1));
+    std::uniform_int_distribution<size_t> uniform_i(0,m-1);
+    std::uniform_int_distribution<size_t> uniform_j(0,n-1);
     gtsam::Matrix mat((int)m,(int)n);
     gtsam::SubMatrix full = mat.block(0, 0, m, n);
     gtsam::SubMatrix top = mat.block(0, 0, n, n);
@@ -75,13 +76,13 @@ int main(int argc, char* argv[]) {
       for(size_t rep=0; rep<1000; ++rep)
         for(size_t i=0; i<(size_t)mat.rows(); ++i)
           for(size_t j=0; j<(size_t)mat.cols(); ++j)
-            mat(i,j) = rng();
+            mat(i,j) = uniform(rng);
 
       gttic_(basicTime);
       for(size_t rep=0; rep<nReps; ++rep)
         for(size_t i=0; i<(size_t)mat.rows(); ++i)
           for(size_t j=0; j<(size_t)mat.cols(); ++j)
-            mat(i,j) = rng();
+            mat(i,j) = uniform(rng);
       gttoc_(basicTime);
       tictoc_getNode(basicTimeNode, basicTime);
       basicTime = basicTimeNode->secs();
@@ -92,7 +93,7 @@ int main(int argc, char* argv[]) {
       for(size_t rep=0; rep<nReps; ++rep)
         for(size_t i=0; i<(size_t)full.rows(); ++i)
           for(size_t j=0; j<(size_t)full.cols(); ++j)
-            full(i,j) = rng();
+            full(i,j) = uniform(rng);
       gttoc_(fullTime);
       tictoc_getNode(fullTimeNode, fullTime);
       fullTime = fullTimeNode->secs();
@@ -103,7 +104,7 @@ int main(int argc, char* argv[]) {
       for(size_t rep=0; rep<nReps; ++rep)
         for(size_t i=0; i<(size_t)top.rows(); ++i)
           for(size_t j=0; j<(size_t)top.cols(); ++j)
-            top(i,j) = rng();
+            top(i,j) = uniform(rng);
       gttoc_(topTime);
       tictoc_getNode(topTimeNode, topTime);
       topTime = topTimeNode->secs();
@@ -114,7 +115,7 @@ int main(int argc, char* argv[]) {
       for(size_t rep=0; rep<nReps; ++rep)
         for(size_t i=0; i<(size_t)block.rows(); ++i)
           for(size_t j=0; j<(size_t)block.cols(); ++j)
-            block(i,j) = rng();
+            block(i,j) = uniform(rng);
       gttoc_(blockTime);
       tictoc_getNode(blockTimeNode, blockTime);
       blockTime = blockTimeNode->secs();
@@ -133,13 +134,13 @@ int main(int argc, char* argv[]) {
       for(size_t rep=0; rep<1000; ++rep)
         for(size_t j=0; j<(size_t)mat.cols(); ++j)
           for(size_t i=0; i<(size_t)mat.rows(); ++i)
-            mat(i,j) = rng();
+            mat(i,j) = uniform(rng);
 
       gttic_(basicTime);
       for(size_t rep=0; rep<nReps; ++rep)
         for(size_t j=0; j<(size_t)mat.cols(); ++j)
           for(size_t i=0; i<(size_t)mat.rows(); ++i)
-            mat(i,j) = rng();
+            mat(i,j) = uniform(rng);
       gttoc_(basicTime);
       tictoc_getNode(basicTimeNode, basicTime);
       basicTime = basicTimeNode->secs();
@@ -150,7 +151,7 @@ int main(int argc, char* argv[]) {
       for(size_t rep=0; rep<nReps; ++rep)
         for(size_t j=0; j<(size_t)full.cols(); ++j)
           for(size_t i=0; i<(size_t)full.rows(); ++i)
-            full(i,j) = rng();
+            full(i,j) = uniform(rng);
       gttoc_(fullTime);
       tictoc_getNode(fullTimeNode, fullTime);
       fullTime = fullTimeNode->secs();
@@ -161,7 +162,7 @@ int main(int argc, char* argv[]) {
       for(size_t rep=0; rep<nReps; ++rep)
         for(size_t j=0; j<(size_t)top.cols(); ++j)
           for(size_t i=0; i<(size_t)top.rows(); ++i)
-            top(i,j) = rng();
+            top(i,j) = uniform(rng);
       gttoc_(topTime);
       tictoc_getNode(topTimeNode, topTime);
       topTime = topTimeNode->secs();
@@ -172,7 +173,7 @@ int main(int argc, char* argv[]) {
       for(size_t rep=0; rep<nReps; ++rep)
         for(size_t j=0; j<(size_t)block.cols(); ++j)
           for(size_t i=0; i<(size_t)block.rows(); ++i)
-            block(i,j) = rng();
+            block(i,j) = uniform(rng);
       gttoc_(blockTime);
       tictoc_getNode(blockTimeNode, blockTime);
       blockTime = blockTimeNode->secs();
@@ -190,14 +191,14 @@ int main(int argc, char* argv[]) {
       cout << "Row-major matrix, random assignment:" << endl;
 
       // Do a few initial assignments to let any cache effects stabilize
-      for_each(ijs.begin(), ijs.end(), _1 = make_pair(rni(),rnj()));
+      for_each(ijs.begin(), ijs.end(), _1 = make_pair(uniform_i(rng),uniform_j(rng)));
       for(size_t rep=0; rep<1000; ++rep)
-        for(const ij_t& ij: ijs) { mat(ij.first, ij.second) = rng(); }
+        for(const ij_t& ij: ijs) { mat(ij.first, ij.second) = uniform(rng); }
 
       gttic_(basicTime);
-      for_each(ijs.begin(), ijs.end(), _1 = make_pair(rni(),rnj()));
+      for_each(ijs.begin(), ijs.end(), _1 = make_pair(uniform_i(rng),uniform_j(rng)));
       for(size_t rep=0; rep<1000; ++rep)
-        for(const ij_t& ij: ijs) { mat(ij.first, ij.second) = rng(); }
+        for(const ij_t& ij: ijs) { mat(ij.first, ij.second) = uniform(rng); }
       gttoc_(basicTime);
       tictoc_getNode(basicTimeNode, basicTime);
       basicTime = basicTimeNode->secs();
@@ -205,9 +206,9 @@ int main(int argc, char* argv[]) {
       cout << format("  Basic: %1% mus/element") % double(1000000 * basicTime / double(ijs.size()*nReps)) << endl;
 
       gttic_(fullTime);
-      for_each(ijs.begin(), ijs.end(), _1 = make_pair(rni(),rnj()));
+      for_each(ijs.begin(), ijs.end(), _1 = make_pair(uniform_i(rng),uniform_j(rng)));
       for(size_t rep=0; rep<1000; ++rep)
-        for(const ij_t& ij: ijs) { full(ij.first, ij.second) = rng(); }
+        for(const ij_t& ij: ijs) { full(ij.first, ij.second) = uniform(rng); }
       gttoc_(fullTime);
       tictoc_getNode(fullTimeNode, fullTime);
       fullTime = fullTimeNode->secs();
@@ -215,9 +216,9 @@ int main(int argc, char* argv[]) {
       cout << format("  Full:  %1% mus/element") % double(1000000 * fullTime / double(ijs.size()*nReps)) << endl;
 
       gttic_(topTime);
-      for_each(ijs.begin(), ijs.end(), _1 = make_pair(rni()%top.rows(),rnj()));
+      for_each(ijs.begin(), ijs.end(), _1 = make_pair(uniform_i(rng)%top.rows(),uniform_j(rng)));
       for(size_t rep=0; rep<1000; ++rep)
-        for(const ij_t& ij: ijs) { top(ij.first, ij.second) = rng(); }
+        for(const ij_t& ij: ijs) { top(ij.first, ij.second) = uniform(rng); }
       gttoc_(topTime);
       tictoc_getNode(topTimeNode, topTime);
       topTime = topTimeNode->secs();
@@ -225,9 +226,9 @@ int main(int argc, char* argv[]) {
       cout << format("  Top:   %1% mus/element") % double(1000000 * topTime / double(ijs.size()*nReps)) << endl;
 
       gttic_(blockTime);
-      for_each(ijs.begin(), ijs.end(), _1 = make_pair(rni()%block.rows(),rnj()%block.cols()));
+      for_each(ijs.begin(), ijs.end(), _1 = make_pair(uniform_i(rng)%block.rows(),uniform_j(rng)%block.cols()));
       for(size_t rep=0; rep<1000; ++rep)
-        for(const ij_t& ij: ijs) { block(ij.first, ij.second) = rng(); }
+        for(const ij_t& ij: ijs) { block(ij.first, ij.second) = uniform(rng); }
       gttoc_(blockTime);
       tictoc_getNode(blockTimeNode, blockTime);
       blockTime = blockTimeNode->secs();
@@ -250,7 +251,7 @@ int main(int argc, char* argv[]) {
 //    matrix mat(5,5);
 //    for(size_t j=0; j<(size_t)mat.cols(); ++j)
 //      for(size_t i=0; i<(size_t)mat.rows(); ++i)
-//        mat(i,j) = rng();
+//        mat(i,j) = uniform(rng);
 //
 //    tri = ublas::triangular_adaptor<matrix, ublas::upper>(mat);
 //    cout << "  Assigned from triangular adapter: " << tri << endl;
@@ -259,13 +260,13 @@ int main(int argc, char* argv[]) {
 //
 //    for(size_t j=0; j<(size_t)mat.cols(); ++j)
 //      for(size_t i=0; i<(size_t)mat.rows(); ++i)
-//        mat(i,j) = rng();
+//        mat(i,j) = uniform(rng);
 //    mat = tri;
 //    cout << "  Assign matrix from triangular: " << mat << endl;
 //
 //    for(size_t j=0; j<(size_t)mat.cols(); ++j)
 //      for(size_t i=0; i<(size_t)mat.rows(); ++i)
-//        mat(i,j) = rng();
+//        mat(i,j) = uniform(rng);
 //    (ublas::triangular_adaptor<matrix, ublas::upper>(mat)) = tri;
 //    cout << "  Assign triangular adaptor from triangular: " << mat << endl;
 //  }
@@ -281,7 +282,7 @@ int main(int argc, char* argv[]) {
 //    matrix mat(5,7);
 //    for(size_t j=0; j<(size_t)mat.cols(); ++j)
 //      for(size_t i=0; i<(size_t)mat.rows(); ++i)
-//        mat(i,j) = rng();
+//        mat(i,j) = uniform(rng);
 //
 //    tri = ublas::triangular_adaptor<matrix, ublas::upper>(mat);
 //    cout << "  Assigned from triangular adapter: " << tri << endl;
@@ -290,13 +291,13 @@ int main(int argc, char* argv[]) {
 //
 //    for(size_t j=0; j<(size_t)mat.cols(); ++j)
 //      for(size_t i=0; i<(size_t)mat.rows(); ++i)
-//        mat(i,j) = rng();
+//        mat(i,j) = uniform(rng);
 //    mat = tri;
 //    cout << "  Assign matrix from triangular: " << mat << endl;
 //
 //    for(size_t j=0; j<(size_t)mat.cols(); ++j)
 //      for(size_t i=0; i<(size_t)mat.rows(); ++i)
-//        mat(i,j) = rng();
+//        mat(i,j) = uniform(rng);
 //    mat = ublas::triangular_adaptor<matrix, ublas::upper>(mat);
 //    cout << "  Assign matrix from triangular adaptor of self: " << mat << endl;
 //  }
--- gtsam-4.0.3.orig/wrap/Method.h
+++ gtsam-4.0.3/wrap/Method.h
@@ -37,7 +37,7 @@ public:
       boost::optional<const Qualified> instName = boost::none, bool verbose =
           false);
 
-  virtual bool isStatic() const {
+  bool isStatic() const override {
     return false;
   }
 
@@ -64,10 +64,10 @@ public:
 private:
 
   // Emit method header
-  void proxy_header(FileWriter& proxyFile) const;
+  void proxy_header(FileWriter& proxyFile) const override;
 
-  virtual std::string wrapper_call(FileWriter& wrapperFile, Str cppClassName,
-      Str matlabUniqueName, const ArgumentList& args) const;
+  std::string wrapper_call(FileWriter& wrapperFile, Str cppClassName,
+      Str matlabUniqueName, const ArgumentList& args) const override;
 };
 
 } // \namespace wrap
--- gtsam-4.0.3.orig/wrap/Module.cpp
+++ gtsam-4.0.3/wrap/Module.cpp
@@ -248,7 +248,7 @@ void Module::parseMarkup(const std::stri
   // Create type attributes table and check validity
   typeAttributes.addClasses(expandedClasses);
   typeAttributes.addForwardDeclarations(forward_declarations);
-  for (const TypedefPair p: typedefs)
+  for (const TypedefPair& p: typedefs)
     typeAttributes.addType(p.newType);
   // add Eigen types as template arguments are also checked ?
   vector<ForwardDeclaration> eigen;
--- gtsam-4.0.3.orig/wrap/ReturnType.h
+++ gtsam-4.0.3/wrap/ReturnType.h
@@ -30,7 +30,7 @@ struct ReturnType : public Qualified {
   ReturnType(const std::string& name, Category c = CLASS, bool ptr = false)
       : Qualified(name, c), isPtr(ptr) {}
 
-  virtual void clear() {
+  void clear() override {
     Qualified::clear();
     isPtr = false;
   }
--- gtsam-4.0.3.orig/wrap/StaticMethod.h
+++ gtsam-4.0.3/wrap/StaticMethod.h
@@ -41,10 +41,10 @@ struct StaticMethod: public MethodBase {
 
 protected:
 
-  virtual void proxy_header(FileWriter& proxyFile) const;
+  void proxy_header(FileWriter& proxyFile) const override;
 
-  virtual std::string wrapper_call(FileWriter& wrapperFile, Str cppClassName,
-      Str matlabUniqueName, const ArgumentList& args) const;
+  std::string wrapper_call(FileWriter& wrapperFile, Str cppClassName,
+      Str matlabUniqueName, const ArgumentList& args) const override;
 };
 
 } // \namespace wrap
--- gtsam-4.0.3.orig/wrap/utilities.h
+++ gtsam-4.0.3/wrap/utilities.h
@@ -40,7 +40,7 @@ class CantOpenFile : public std::excepti
  public:
  CantOpenFile(const std::string& filename) : what_("Can't open file " + filename) {}
   ~CantOpenFile() throw() {}
-  virtual const char* what() const throw() { return what_.c_str(); }
+  const char* what() const noexcept override { return what_.c_str(); }
 };
 
 class OutputError : public std::exception {
@@ -49,7 +49,7 @@ private:
 public:
   OutputError(const std::string& what) : what_(what) {}
   ~OutputError() throw() {}
-  virtual const char* what() const throw() { return what_.c_str(); }
+  const char* what() const noexcept override { return what_.c_str(); }
 };
 
 class ParseFailed : public std::exception {
@@ -58,7 +58,7 @@ class ParseFailed : public std::exceptio
  public:
    ParseFailed(int length) : what_((boost::format("Parse failed at character [%d]")%(length-1)).str()) {}
    ~ParseFailed() throw() {}
-   virtual const char* what() const throw() { return what_.c_str(); }
+   const char* what() const noexcept override { return what_.c_str(); }
 };
 
 class DependencyMissing : public std::exception {
@@ -68,7 +68,7 @@ public:
   DependencyMissing(const std::string& dep, const std::string& loc) :
     what_("Missing dependency '" + dep + "' in " + loc) {}
   ~DependencyMissing() throw() {}
-  virtual const char* what() const throw() { return what_.c_str(); }
+  const char* what() const noexcept override { return what_.c_str(); }
 };
 
 class DuplicateDefinition : public std::exception {
@@ -78,7 +78,7 @@ public:
   DuplicateDefinition(const std::string& name) :
     what_("Duplicate definition of " + name) {}
   ~DuplicateDefinition() throw() {}
-  virtual const char* what() const throw() { return what_.c_str(); }
+  const char* what() const noexcept override { return what_.c_str(); }
 };
 
 class AttributeError : public std::exception {
@@ -88,7 +88,7 @@ public:
   AttributeError(const std::string& name, const std::string& problem) :
     what_("Class " + name + ": " + problem) {}
   ~AttributeError() throw() {}
-  virtual const char* what() const throw() { return what_.c_str(); }
+  const char* what() const noexcept override { return what_.c_str(); }
 };
 
 // "Unique" key to signal calling the matlab object constructor with a raw pointer
